[{"content":" In October, Rust for linux is under the linux-next, not stable\nThus this article would be out-of-date before Linux 6.1 stable comes.\nmodules, out-of-tree # There are two main ways to develop kernel modules. In-Of-Tree and Out-Of-Tree. In this article, we\u0026rsquo;re going to make the Out-Of-Tree method a Rust kernel module.\nBefore we start # Check your kernel has been compiled with CONFIG_RUST=y. # Check with following command.\nzcat /proc/config.gz | grep -i CONFIG_RUST=y The result comes with CONFIG_RUST=y.\nBut you may not check from /proc/config.gz when using distibution kernel image that downloaded or pre-installed.\nNeed some build \u0026 install rust support kernel see here. See details \u0026rharu; Prepare $KDIR # $KDIR is path of kernel source.\nIn this article path of kernel source that system used for boot with CONFIG_RUST.\nKDIR and other kernel module descriptions See details \u0026rharu; In my case it\u0026rsquo;s ~/Develop/linux\n# /home/pmnxis/Develop/linux export KDIR=$HOME/Develop/linux Looking in to code # Let\u0026rsquo;s preview the code rust_out_of_tree.rs \u0026hellip;\nLicense and imports # 1 2 3 4 5 6 7 8 9 10 11 12 13 // SPDX-License-Identifier: GPL-2.0 //! Rust out-of-tree sample use kernel::prelude::*; module! { type: RustOutOfTree, name: \u0026#34;rust_out_of_tree\u0026#34;, author: \u0026#34;Rust for Linux Contributors\u0026#34;, description: \u0026#34;Rust out-of-tree sample\u0026#34;, license: \u0026#34;GPL\u0026#34;, } Lines 1~3, show file\u0026rsquo;s license information. If you are write the code in company, SomeCompanyName instead GPL-2.0 or just keep GPL-2.0. 1 2 3 4 5 6 7 8 9 10 11 12 13 // SPDX-License-Identifier: GPL-2.0 //! Rust out-of-tree sample use kernel::prelude::*; module! { type: RustOutOfTree, name: \u0026#34;rust_out_of_tree\u0026#34;, author: \u0026#34;Rust for Linux Contributors\u0026#34;, description: \u0026#34;Rust out-of-tree sample\u0026#34;, license: \u0026#34;GPL\u0026#34;, } Line 5 means, bring rust for linux library for this code.\nIn following example module written in C were include like this.\n2 3 4 #include \u0026lt;linux/module.h\u0026gt; #include \u0026lt;linux/kthread.h\u0026gt; #include \u0026lt;linux/irq_work.h\u0026gt; 1 2 3 4 5 6 7 8 9 10 11 12 13 // SPDX-License-Identifier: GPL-2.0 //! Rust out-of-tree sample use kernel::prelude::*; module! { type: RustOutOfTree, name: \u0026#34;rust_out_of_tree\u0026#34;, author: \u0026#34;Rust for Linux Contributors\u0026#34;, description: \u0026#34;Rust out-of-tree sample\u0026#34;, license: \u0026#34;GPL\u0026#34;, } Line 8, implement of the module trait. Line 9, name of the module, if we written c, it\u0026rsquo;s the name of *.ko name field. Line 10~12, those fields are simillar with below the example written in c. Those fields are same purpose.\n56 57 58 MODULE_AUTHOR(\u0026#34;Steven Rostedt\u0026#34;); MODULE_DESCRIPTION(\u0026#34;trace-printk\u0026#34;); MODULE_LICENSE(\u0026#34;GPL\u0026#34;); We preview macro_rule! module shortly. You can see detail here.\nDetails for module! See details \u0026rharu; Actual implements # 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 struct RustOutOfTree { numbers: Vec\u0026lt;i32\u0026gt;, } impl kernel::Module for RustOutOfTree { fn init(_name: \u0026amp;\u0026#39;static CStr, _module: \u0026amp;\u0026#39;static ThisModule) -\u0026gt; Result\u0026lt;Self\u0026gt; { pr_info!(\u0026#34;Rust out-of-tree sample (init)\\n\u0026#34;); let mut numbers = Vec::new(); numbers.try_push(72)?; numbers.try_push(108)?; numbers.try_push(200)?; Ok(RustOutOfTree { numbers }) } } impl Drop for RustOutOfTree { fn drop(\u0026amp;mut self) { pr_info!(\u0026#34;My numbers are {:?}\\n\u0026#34;, self.numbers); pr_info!(\u0026#34;Rust out-of-tree sample (exit)\\n\u0026#34;); } } I just guess working as \u0026hellip;\nOn init (insmod?), print out somewhere with text Rust out-of-tree sample (init) vec\u0026lt;i32\u0026gt;[72, 108, 200] is stored some kernel memory space with struct RustOutOfTree. When drop the module (rmmod?), will print out with text [72, 108, 200]. By the way, we need to keep on eyes here.\n23 24 let mut numbers = Vec::new(); numbers.try_push(72)?; In line 24, try_push is not exsting in std::Vec. In rust kernel programming, need to use try_push instead std::Vec::push.\nDetails for alloc::vec::Vec See details \u0026rharu; Also there's some `init` and `drop` functions in line 20 and 33. The code covers those function with `impl for` pattern. Details for Implementation in rust See details \u0026rharu; I will explain about implementation and it\u0026rsquo;s philosophy later article.\nRun code # Build it # make LLVM=1 My rust acceptable kernel build were buiten with LLVM.\nSo I compile the kernel module with LLVM.\nInstall module # sudo insmod ./rust_out_of_tree.ko After compile, we can there\u0026rsquo;s rust_out_of_tree.ko inside of project directory.\nWe can install module with insmod that normally used before.\nInspect result # # do `sudo rmmod rust_out_of_tree` if you already install the module` # clear all of dmesg log sudo dmesg -C # install the module sudo insmod ./rust_out_of_tree.ko # see log dmesg # uninstall the module sudo rmmod rust_out_of_tree # check log again. dmesg We can check the inspect actual result with above commands.\nAs we guess it prints with [72, 108, 200].\nConclusion # We can summary from this simple kernel module.\nSummary # Need to use use kernel::prelude::*; on top of code. module! macro to define some description and board my own struct to the kernel module. kernel::Module templete functions \u0026hellip;. -WIP- In kernel programming, use alloc::vec::Vec instead std::Vec. pr_info is just same as way to write with C. Reference # https://github.com/Rust-for-Linux/rust-out-of-tree-module https://www.kernel.org/doc/html/latest/kbuild/modules.html https://github.com/Rust-for-Linux/linux https://rust-for-linux.github.io/docs/kernel/prelude/index.html https://rust-for-linux.github.io/docs/kernel/prelude/macro.module.html https://rust-for-linux.github.io/docs/kernel/prelude/struct.Vec.html ","date":"October 2, 2022","permalink":"/posts/look_into_simple_rust_out_of_tree/","section":"Posts","summary":"In October, Rust for linux is under the linux-next, not stable\nThus this article would be out-of-date before Linux 6.1 stable comes.\nmodules, out-of-tree # There are two main ways to develop kernel modules.","title":"[Rust Driver] Let's try build example rust linux driver."},{"content":"","date":"October 2, 2022","permalink":"/tags/armv8a/","section":"Tags","summary":"","title":"ARMv8A"},{"content":"","date":"October 2, 2022","permalink":"/tags/english_article/","section":"Tags","summary":"","title":"English_Article"},{"content":"","date":"October 2, 2022","permalink":"/tags/linux/","section":"Tags","summary":"","title":"Linux"},{"content":"","date":"October 2, 2022","permalink":"/posts/","section":"Posts","summary":"","title":"Posts"},{"content":"Rust\n","date":"October 2, 2022","permalink":"/tags/rust/","section":"Tags","summary":"Rust","title":"Rust"},{"content":"","date":"October 2, 2022","permalink":"/tags/rust-driver/","section":"Tags","summary":"","title":"Rust Driver"},{"content":"\nMore details for rust tags : Rust tag\n","date":"October 2, 2022","permalink":"/tags/","section":"Tags","summary":"More details for rust tags : Rust tag","title":"Tags"},{"content":" Here\u0026rsquo;s my cat Lambdaλ who expert on electronic engineering. This blog mainly cover with Linux, Rust, Embedded, and electronic circuits, and articles in Korean and English are mixed. Sometimes my cat Lambdaλ appears frequently, so I would appreciate it if you liked it. Nyaa\n","date":"October 2, 2022","permalink":"/","section":"Welcome to Jinwoo and Lambda 🐱 's blog","summary":"Here\u0026rsquo;s my cat Lambdaλ who expert on electronic engineering. This blog mainly cover with Linux, Rust, Embedded, and electronic circuits, and articles in Korean and English are mixed. Sometimes my cat Lambdaλ appears frequently, so I would appreciate it if you liked it.","title":"Welcome to Jinwoo and Lambda 🐱 's blog"},{"content":" In October 1, Rust for linux is under the linux-next, not stable\nThus this article would be out-of-date before Linux 6.1 stable comes.\nThis article play with https://github.com/Rust-for-Linux/linux/tree/for-next/rust\nIntroduction # Currently Apple Silicon mac series is only one ARM workstation that have powerful performance as normal desktop class workstation and can purchase anywhere. Of course if you have 32GB or bigger memory and least 8 big cores of apple silicon.\nBtw, this article is in reference to https://github.com/Rust-for-Linux/linux/blob/rust/Documentation/rust/quick-start.rst .\nVM hypervisor software selection. # UTM : Free / OpenSource, QEMU based Sometimes tricky. VM Fusion Tech Preview : Free for now / ClosedSource, Moderate Parallels : Non-Free / ClosedSource, not my taste (sorry). There\u0026rsquo;s some option working with Asahi Linux. But in this article is not consider native asahi linux environment.\nIn my case, I was chosen VM Fusion.\nVirtual Machine Configuration # Debian 11 : https://cdimage.debian.org/debian-cd/current/arm64/iso-dvd/ !! Checked working well.\nUbuntu : There were some issue clang and other gcc build tools version mismatch than broken apt things in aarch64 ubuntu apt repo. But you can try with ubuntu.\nArch Linux : https://gitlab.archlinux.org/tpowa/archboot/-/wikis/Archboot-Homepage#aarch64-architecture I didn\u0026rsquo;t tested yet.\nDebian / Ubuntu Package Requirements # # Install build-requirements for kernel compile with LLVM. apt install clang git llvm-dev libclang-dev build-essential \\ bc kmod cpio flex libncurses5-dev libelf-dev libssl-dev \\ dwarves bison lld curl Before build kernel, we need to install some packages.\ncurl --proto \u0026#39;=https\u0026#39; --tlsv1.2 -sSf https://sh.rustup.rs | sh rustup component add rust-src # rustfmt and clippy is need for later developing and debugging. rustup component add rustfmt rustup component add clippy Install rust with curl. You can select just default options.\nArch Package Requirements # TBD Clone linux from Rust-For-Linux # State of current rust-for-linux, they are under 6.0 RC\n# In my case use `Develop` as worksapce, you can replace this word. mkdir -p ~/Develop cd ~/Develop git clone https://github.com/Rust-for-Linux/linux.git -b rust clone like this.\nCheck RUST_AVAILABLE # cd ~/Develop/linux make LLVM=1 rustavailable $ make LLVM=1 rustavailable *** *** Rust compiler \u0026#39;rustc\u0026#39; is too new. This may or may not work. *** Your version: 1.64.0 *** Expected version: 1.62.0 *** Rust is available! Than if you get result like this it\u0026rsquo;s good to go\nNecessary some rust scripts in Rust-For-Linux # In cloned linux directory.\ngit clone --recurse-submodules \\ --branch $(scripts/min-tool-version.sh rustc) \\ https://github.com/rust-lang/rust \\ $(rustc --print sysroot)/lib/rustlib/src/rust This work clone rustlib repository in your rust toolchain directory.\ncargo install --locked --version $(scripts/min-tool-version.sh bindgen) bindgen This work need to bind existing c code to rust code.\nConfigure linux source code with menuconfig # make ARCH=arm64 defconfig make menuconfig General setup -\u0026gt; Rust support # In General setup -\u0026gt; Rust support , Enable this If you don\u0026rsquo;t see the flag, double-check that the make LLVM=1 rustavailable process was successful. For a detailed mailing thread on CONFIG_RUST see here. See details \u0026rharu; Kernel hacking -\u0026gt; Sample kernel code # For easy to develop rust kernel code we need some examples. You can get them with following menus.\nIn Kernel hacking -\u0026gt; Sample kernel code , enable it (not all of them..) when you interest. I don\u0026rsquo;t recommend you enable them when you write own driver. Because there\u0026rsquo;s some possibility make system slow or make unwanted log in dmesg. In particular, the netflitter example outputs too many dmesg, so it is recommended that you disable it unless you are studying the netfilter example. Kernel hacking -\u0026gt; Rust hacking # For debug rust kernel code or driver, need to enable some debug options.\nIn Kernel hacking -\u0026gt; Rust hacking , enables it and inside menus.\nCompile and install it in virtual machine. # # -j4 for 4 core virtual machine, -j2 for 2 core, -j1 for single core. make LLVM=1 -j4 Build with following command. You need to set number of job considering assigned number of cores for virtual machine. (-j#)\nAlso while you build it, it will ask some flag. I just select default in my case.\nIt takes lot of time (don\u0026rsquo;t worry much better than raspberry pi 4), 13~14 minuites takes in my environment (VM 4core, 8GB)\nAfter than, install via following command\n# should be under the root permision. make modules_install make install update-grub It\u0026rsquo;s done!. Reboot program and then check the kernel working well.\nLinux lambda-next 6.0.0-rc7-175589-g542379556669 #2 SMP PREEMPT Sun Oct 2 19:02:32 KST 2022 aarch64 The programs included with the Debian GNU/Linux system are free software; the exact distribution terms for each program are described in the individual files in /usr/share/doc/*/copyright. Debian GNU/Linux comes with ABSOLUTELY NO WARRANTY, to the extent permitted by applicable law. Last login: Sun Oct 2 18:20:21 2022 from 192.168.99.1 pmnxis@lambda-next:~$ uname -r 6.0.0-rc7-175589-g542379556669 ","date":"October 1, 2022","permalink":"/posts/rust_for_linux_with_m1/","section":"Posts","summary":"In October 1, Rust for linux is under the linux-next, not stable\nThus this article would be out-of-date before Linux 6.1 stable comes.\nThis article play with https://github.com/Rust-for-Linux/linux/tree/for-next/rust\nIntroduction # Currently Apple Silicon mac series is only one ARM workstation that have powerful performance as normal desktop class workstation and can purchase anywhere.","title":"Rust For Linux Development Environment with AppleSilicon MacOS"},{"content":"Introduction # ARMv8A는 흔히 aarch64로도 불리며 현재 ARMv7A를 뒤로한채 널리 사용하는 아키텍처중 하나입니다. 본 글에서는 ARMv8A의 메모리 시스템을 IP단위로 보려합니다.\n사용하는 메모리 (DDR4 , LPDDR4 , DDR3 , LPDDR3 , DDR2)나 사용하는 아키텍처(ARM v8.1 or 8.2)에 조금씩 다르나 대체적으로 위 사진과 같은 형태로 구성이 되어있습니다.\nComponents # CPU # Instruction을 처리합니다.\nGIC # Generic Interrupt Controller; GIC는 각종 Nested한 Interrupt를 관리하며, Interrupt발생시 CPU에서 동작중이던 PC/Register를 백업하고 해당하는 Inetrrupt Vector를 Execution하도록 합니다.\nCCI / CCN # Cache Coherent Interconnect / Netowrk\nDMC # DRAM을 관리합니다. DRAM은 휘발성 메모리로서 Read/Write 이외에 Refresh, Callibration 와 같은 작업이 필요합니다. 추가적으로 EEC, RAS에 대한 관리도 수행합니다. Linux드라이버에서는 edac 디렉터리에서 EEC, RAS에 대한 관리 드라이버 코드를 확인 할 수 있습니다.\nNIC # 각종 Peripheral 을 연결하는데 사용합니다.\nMMU # PA/VA (Physical/Virtual Address) 변환 DMA 컨트롤 Reference # CCI-400 ; https://developer.arm.com/Processors/CoreLink%20CCI-400 CCI-500 ; https://developer.arm.com/Processors/CoreLink%20CCI-500 DMC-400 ; DDR3/DDR2 DMC ; https://developer.arm.com/documentation/ddi0466/f/introduction/about-the-dmc-400 DMC-500 ; LPDDR4/LPDDR3 DMC ; https://developer.arm.com/documentation/100131/0000 ","date":"December 14, 2021","permalink":"/posts/arm_v8a_memory_ip_review/","section":"Posts","summary":"Introduction # ARMv8A는 흔히 aarch64로도 불리며 현재 ARMv7","title":"ARMv8A Memory IP Review"},{"content":"","date":"December 14, 2021","permalink":"/tags/electronics/","section":"Tags","summary":"","title":"Electronics"},{"content":"","date":"December 14, 2021","permalink":"/tags/korean_article/","section":"Tags","summary":"","title":"Korean_Article"},{"content":"","date":"January 1, 1","permalink":"/categories/","section":"Categories","summary":"","title":"Categories"}]