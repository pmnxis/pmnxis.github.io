[{"content":"","date":"October 4, 2022","permalink":"/tags/armv8a/","section":"Tags","summary":"","title":"ARMv8A"},{"content":"","date":"October 4, 2022","permalink":"/tags/cross-compile/","section":"Tags","summary":"","title":"Cross compile"},{"content":" In October 6, Rust for linux is under the linux-next, not stable\nThus this article would be out-of-date before Linux 6.1 stable comes.\nCurrent linux 6.1 rc1 doesn\u0026rsquo;t contain rust for linux with ARM64. Thus this article play with https://github.com/Rust-for-Linux/linux/tree/for-next/rust\nIntroduction\u003e Introduction # This article describes cross-compiling rust for linux on x86_64 debian. There is still not enough computing power to build arm64 native kernel except for Apple Silicon.\nBtw, this article is in reference to these links\nhttps://github.com/Rust-for-Linux/linux/blob/rust/Documentation/rust/quick-start.rst https://docs.kernel.org/kbuild/llvm.html#cross-compiling Debian / Ubuntu Package Requirements\u003e Debian / Ubuntu Package Requirements # # Install build-requirements for kernel compile with LLVM. # Biggest difference to native build is # crossbuild-essential-arm64 needed to build` for arm64 apt install clang git llvm-dev libclang-dev build-essential \\ bc kmod cpio flex libncurses5-dev libelf-dev libssl-dev \\ dwarves bison lld curl crossbuild-essential-arm64 Before build kernel, we need to install some packages.\ncurl --proto \u0026#39;=https\u0026#39; --tlsv1.2 -sSf https://sh.rustup.rs | sh rustup default 1.62 rustup component add rust-src # rustfmt and clippy is need for later developing and debugging. rustup component add rustfmt rustup component add clippy Install rust with curl. You can select just default options. Also current rust for linux working with 1.62. Some native compile is working well with recent version (1.64 tested, but cross compile not working).\nArch Package Requirements\u003e Arch Package Requirements # TBD Clone linux from Rust-For-Linux\u003e Clone linux from Rust-For-Linux # State of current rust-for-linux, they are under 6.0 RC\n# In my case use `Develop` as worksapce, you can replace this word. mkdir -p ~/Develop cd ~/Develop git clone https://github.com/Rust-for-Linux/linux.git -b rust clone like this.\nNecessary some rust scripts in Rust-For-Linux\u003e Necessary some rust scripts in Rust-For-Linux # In cloned linux directory.\ngit clone --recurse-submodules \\ --branch $(scripts/min-tool-version.sh rustc) \\ https://github.com/rust-lang/rust \\ $(rustc --print sysroot)/lib/rustlib/src/rust This work clone rustlib repository in your rust toolchain directory.\ncargo install --locked --version $(scripts/min-tool-version.sh bindgen) bindgen This work need to bind existing c code to rust code. s\nCheck RUST_AVAILABLE\u003e Check RUST_AVAILABLE # cd ~/Develop/linux make LLVM=1 rustavailable $ make LLVM=1 rustavailable *** *** Rust compiler \u0026#39;rustc\u0026#39; is too new. This may or may not work. *** Your version: 1.62.1 *** Expected version: 1.62.0 *** Rust is available! Than if you get result like this it\u0026rsquo;s good to go (1.62.1 was fine to cross compile, but if you consider best fit, run rustup default 1.62.0.)\nConfigure linux source code with menuconfig\u003e Configure linux source code with menuconfig # make ARCH=arm64 CROSS_COMPILE=aarch64-linux-gnu- defconfig make ARCH=arm64 CROSS_COMPILE=aarch64-linux-gnu- menuconfig General setup -\u0026gt; Rust support\u003e General setup -\u0026gt; Rust support # In General setup -\u0026gt; Rust support , Enable this If you don\u0026rsquo;t see the flag, double-check that the make LLVM=1 rustavailable process was successful. For a detailed mailing thread on CONFIG_RUST see here. See details \u0026rharu; Kernel hacking -\u0026gt; Sample kernel code\u003e Kernel hacking -\u0026gt; Sample kernel code # For easy to develop rust kernel code we need some examples. You can get them with following menus.\nIn Kernel hacking -\u0026gt; Sample kernel code , enable it (not all of them..) when you interest. I don\u0026rsquo;t recommend you enable them when you write own driver. Because there\u0026rsquo;s some possibility make system slow or make unwanted log in dmesg. In particular, the netflitter example outputs too many dmesg, so it is recommended that you disable it unless you are studying the netfilter example. Kernel hacking -\u0026gt; Rust hacking\u003e Kernel hacking -\u0026gt; Rust hacking # For debug rust kernel code or driver, need to enable some debug options.\nIn Kernel hacking -\u0026gt; Rust hacking , enables it and inside menus.\nCross compile\u003e Cross compile # # -j4 for 4 core virtual machine, -j2 for 2 core, -j1 for single core. make ARCH=arm64 CROSS_COMPILE=aarch64-linux-gnu- LLVM=1 -j32 Build with following command. You need to set number of job considering assigned number of cores for virtual machine. (-j#)\nAlso while you build it, it will ask some flag. I just select default in my case.\nSimple compile speed comparation.\u003e Simple compile speed comparation. # Machine / Environment Compile time M1 Max Virtual Machine (4 core 8GB RAM with aarch64 debian11) 16 minutes M1 Asahi Linux (4P+4E core 16GB RAM MacMini with 6.1.0-rc6-asahi) 11 minutes AMD Ryzen 5950x Native (16 core 32 thread, 64GB with x86_64) 3 minutes AMD Threadripper Pro 5975wx Native (32 core 64 thread, 256GB with x86_64) 2 minutes Install cross compiled kernel to arm64 virtual machine\u003e Install cross compiled kernel to arm64 virtual machine # TBD, will update asap. Install cross compiled kernel to raspberry pi\u003e Install cross compiled kernel to raspberry pi # TBD, will update asap. ","date":"October 4, 2022","permalink":"/posts/cross_compiling_aarch64_rust_for_linux_from_x86_64_linux/","section":"Posts","summary":"In October 6, Rust for linux is under the linux-next, not stable\nThus this article would be out-of-date before Linux 6.1 stable comes.\nCurrent linux 6.1 rc1 doesn\u0026rsquo;t contain rust for linux with ARM64.","title":"Cross compiling aarch64(arm64) rust for linux from x86_64 machine"},{"content":"","date":"October 4, 2022","permalink":"/tags/english_article/","section":"Tags","summary":"","title":"English_Article"},{"content":"","date":"October 4, 2022","permalink":"/tags/linux/","section":"Tags","summary":"","title":"Linux"},{"content":"","date":"October 4, 2022","permalink":"/posts/","section":"Posts","summary":"","title":"Posts"},{"content":"Rust\n","date":"October 4, 2022","permalink":"/tags/rust/","section":"Tags","summary":"Rust","title":"Rust"},{"content":"\nMore details for rust tags : Rust tag\n","date":"October 4, 2022","permalink":"/tags/","section":"Tags","summary":"More details for rust tags : Rust tag","title":"Tags"},{"content":" Here\u0026rsquo;s my cat Lambdaλ who expert on electronic engineering. This blog mainly cover with Linux, Rust, Embedded, and electronic circuits, and articles in Korean and English are mixed. Sometimes my cat Lambdaλ appears frequently, so I would appreciate it if you liked it. Nyaa\n","date":"October 4, 2022","permalink":"/","section":"Welcome to Jinwoo and Lambda 🐱 's blog","summary":"Here\u0026rsquo;s my cat Lambdaλ who expert on electronic engineering. This blog mainly cover with Linux, Rust, Embedded, and electronic circuits, and articles in Korean and English are mixed. Sometimes my cat Lambdaλ appears frequently, so I would appreciate it if you liked it.","title":"Welcome to Jinwoo and Lambda 🐱 's blog"},{"content":" In October, Rust for linux is under the linux-next, not stable\nThus this article would be out-of-date before Linux 6.1 stable comes.\nmodules, out-of-tree\u003e modules, out-of-tree # There are two main ways to develop kernel modules. In-Of-Tree and Out-Of-Tree. In this article, we\u0026rsquo;re going to make the Out-Of-Tree method a Rust kernel module.\nBefore we start\u003e Before we start # Check your kernel has been compiled with CONFIG_RUST=y.\u003e Check your kernel has been compiled with CONFIG_RUST=y. # Check with following command.\nzcat /proc/config.gz | grep -i CONFIG_RUST=y The result comes with CONFIG_RUST=y.\nBut you may not check from /proc/config.gz when using distibution kernel image that downloaded or pre-installed.\nNeed some build \u0026 install rust support kernel see here. See details \u0026rharu; Prepare $KDIR\u003e Prepare $KDIR # $KDIR is path of kernel source.\nIn this article path of kernel source that system used for boot with CONFIG_RUST.\nKDIR and other kernel module descriptions See details \u0026rharu; In my case it\u0026rsquo;s ~/Develop/linux\n# /home/pmnxis/Develop/linux export KDIR=$HOME/Develop/linux Looking in to code\u003e Looking in to code # Let\u0026rsquo;s preview the code rust_out_of_tree.rs \u0026hellip;\nLicense and imports\u003e License and imports # 1 2 3 4 5 6 7 8 9 10 11 12 13 // SPDX-License-Identifier: GPL-2.0 //! Rust out-of-tree sample use kernel::prelude::*; module! { type: RustOutOfTree, name: \u0026#34;rust_out_of_tree\u0026#34;, author: \u0026#34;Rust for Linux Contributors\u0026#34;, description: \u0026#34;Rust out-of-tree sample\u0026#34;, license: \u0026#34;GPL\u0026#34;, } Lines 1~3, show file\u0026rsquo;s license information. If you are write the code in company, SomeCompanyName instead GPL-2.0 or just keep GPL-2.0. 1 2 3 4 5 6 7 8 9 10 11 12 13 // SPDX-License-Identifier: GPL-2.0 //! Rust out-of-tree sample use kernel::prelude::*; module! { type: RustOutOfTree, name: \u0026#34;rust_out_of_tree\u0026#34;, author: \u0026#34;Rust for Linux Contributors\u0026#34;, description: \u0026#34;Rust out-of-tree sample\u0026#34;, license: \u0026#34;GPL\u0026#34;, } Line 5 means, bring rust for linux library for this code.\nIn following example module written in C were include like this.\n2 3 4 #include \u0026lt;linux/module.h\u0026gt; #include \u0026lt;linux/kthread.h\u0026gt; #include \u0026lt;linux/irq_work.h\u0026gt; 1 2 3 4 5 6 7 8 9 10 11 12 13 // SPDX-License-Identifier: GPL-2.0 //! Rust out-of-tree sample use kernel::prelude::*; module! { type: RustOutOfTree, name: \u0026#34;rust_out_of_tree\u0026#34;, author: \u0026#34;Rust for Linux Contributors\u0026#34;, description: \u0026#34;Rust out-of-tree sample\u0026#34;, license: \u0026#34;GPL\u0026#34;, } Line 8, implement of the module trait. Line 9, name of the module, if we written c, it\u0026rsquo;s the name of *.ko name field. Line 10~12, those fields are simillar with below the example written in c. Those fields are same purpose.\n56 57 58 MODULE_AUTHOR(\u0026#34;Steven Rostedt\u0026#34;); MODULE_DESCRIPTION(\u0026#34;trace-printk\u0026#34;); MODULE_LICENSE(\u0026#34;GPL\u0026#34;); We preview macro_rule! module shortly. You can see detail here.\nDetails for module! See details \u0026rharu; Actual implements\u003e Actual implements # 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 struct RustOutOfTree { numbers: Vec\u0026lt;i32\u0026gt;, } impl kernel::Module for RustOutOfTree { fn init(_name: \u0026amp;\u0026#39;static CStr, _module: \u0026amp;\u0026#39;static ThisModule) -\u0026gt; Result\u0026lt;Self\u0026gt; { pr_info!(\u0026#34;Rust out-of-tree sample (init)\\n\u0026#34;); let mut numbers = Vec::new(); numbers.try_push(72)?; numbers.try_push(108)?; numbers.try_push(200)?; Ok(RustOutOfTree { numbers }) } } impl Drop for RustOutOfTree { fn drop(\u0026amp;mut self) { pr_info!(\u0026#34;My numbers are {:?}\\n\u0026#34;, self.numbers); pr_info!(\u0026#34;Rust out-of-tree sample (exit)\\n\u0026#34;); } } I just guess working as \u0026hellip;\nOn init (insmod?), print out somewhere with text Rust out-of-tree sample (init) vec\u0026lt;i32\u0026gt;[72, 108, 200] is stored some kernel memory space with struct RustOutOfTree. When drop the module (rmmod?), will print out with text [72, 108, 200]. By the way, we need to keep on eyes here.\n23 24 let mut numbers = Vec::new(); numbers.try_push(72)?; In line 24, try_push is not exsting in std::Vec. In rust kernel programming, need to use try_push instead std::Vec::push.\nDetails for alloc::vec::Vec See details \u0026rharu; Also there's some `init` and `drop` functions in line 20 and 33. The code covers those function with `impl for` pattern. Details for Implementation in rust See details \u0026rharu; I will explain about implementation and it\u0026rsquo;s philosophy later article.\nRun code\u003e Run code # Build it\u003e Build it # make LLVM=1 My rust acceptable kernel build were buiten with LLVM.\nSo I compile the kernel module with LLVM.\nInstall module\u003e Install module # sudo insmod ./rust_out_of_tree.ko After compile, we can there\u0026rsquo;s rust_out_of_tree.ko inside of project directory.\nWe can install module with insmod that normally used before.\nInspect result\u003e Inspect result # # do `sudo rmmod rust_out_of_tree` if you already install the module` # clear all of dmesg log sudo dmesg -C # install the module sudo insmod ./rust_out_of_tree.ko # see log dmesg # uninstall the module sudo rmmod rust_out_of_tree # check log again. dmesg We can check the inspect actual result with above commands.\nAs we guess it prints with [72, 108, 200].\nConclusion\u003e Conclusion # We can summary from this simple kernel module.\nSummary\u003e Summary # Need to use use kernel::prelude::*; on top of code. module! macro to define some description and board my own struct to the kernel module. kernel::Module templete functions \u0026hellip;. -WIP- In kernel programming, use alloc::vec::Vec instead std::Vec. pr_info is just same as way to write with C. Reference\u003e Reference # https://github.com/Rust-for-Linux/rust-out-of-tree-module https://www.kernel.org/doc/html/latest/kbuild/modules.html https://github.com/Rust-for-Linux/linux https://rust-for-linux.github.io/docs/kernel/prelude/index.html https://rust-for-linux.github.io/docs/kernel/prelude/macro.module.html https://rust-for-linux.github.io/docs/kernel/prelude/struct.Vec.html ","date":"October 2, 2022","permalink":"/posts/look_into_simple_rust_out_of_tree/","section":"Posts","summary":"In October, Rust for linux is under the linux-next, not stable\nThus this article would be out-of-date before Linux 6.1 stable comes.\nmodules, out-of-tree\u003e modules, out-of-tree # There are two main ways to develop kernel modules.","title":"[Rust Driver] Let's try build example rust linux driver."},{"content":"","date":"October 2, 2022","permalink":"/tags/rust-driver/","section":"Tags","summary":"","title":"Rust Driver"},{"content":" In October 1, Rust for linux is under the linux-next, not stable\nThus this article would be out-of-date before Linux 6.1 stable comes.\nThis article play with https://github.com/Rust-for-Linux/linux/tree/for-next/rust\nIntroduction\u003e Introduction # Currently Apple Silicon mac series is only one ARM workstation that have powerful performance as normal desktop class workstation and can purchase anywhere. Of course if you have 32GB or bigger memory and least 8 big cores of apple silicon.\nBtw, this article is in reference to https://github.com/Rust-for-Linux/linux/blob/rust/Documentation/rust/quick-start.rst .\nVM hypervisor software selection.\u003e VM hypervisor software selection. # UTM : Free / OpenSource, QEMU based Sometimes tricky. VM Fusion Tech Preview : Free for now / ClosedSource, Moderate Parallels : Non-Free / ClosedSource, not my taste (sorry). There\u0026rsquo;s some option working with Asahi Linux. But in this article is not consider native asahi linux environment.\nIn my case, I was chosen VM Fusion.\nVirtual Machine Configuration\u003e Virtual Machine Configuration # Debian 11 : https://cdimage.debian.org/debian-cd/current/arm64/iso-dvd/ !! Checked working well.\nUbuntu : There were some issue clang and other gcc build tools version mismatch than broken apt things in aarch64 ubuntu apt repo. But you can try with ubuntu.\nArch Linux : https://gitlab.archlinux.org/tpowa/archboot/-/wikis/Archboot-Homepage#aarch64-architecture I didn\u0026rsquo;t tested yet. But tested with Asahi linux with M1 Mac Mini\nDebian / Ubuntu Package Requirements\u003e Debian / Ubuntu Package Requirements # # Install build-requirements for kernel compile with LLVM. apt install clang git llvm-dev libclang-dev build-essential \\ bc kmod cpio flex libncurses5-dev libelf-dev libssl-dev \\ dwarves bison lld curl Asahi Linux Package Requirements\u003e Asahi Linux Package Requirements # pacman -S base-devel cpio lld llvm llvm-libs bc libdwarf Ready for rust\u003e Ready for rust # Before build kernel, we need to install some packages.\ncurl --proto \u0026#39;=https\u0026#39; --tlsv1.2 -sSf https://sh.rustup.rs | sh rustup default 1.62 rustup component add rust-src # rustfmt and clippy is need for later developing and debugging. rustup component add rustfmt rustup component add clippy Install rust with curl. You can select just default options. Also current rust for linux working with 1.62. Some native compile is working well with recent version (1.64 tested, but cross compile not working).\nClone linux from Rust-For-Linux\u003e Clone linux from Rust-For-Linux # State of current rust-for-linux, they are under 6.0 RC\n# In my case use `Develop` as worksapce, you can replace this word. mkdir -p ~/Develop cd ~/Develop git clone https://github.com/Rust-for-Linux/linux.git -b rust clone like this.\nNecessary some rust scripts in Rust-For-Linux\u003e Necessary some rust scripts in Rust-For-Linux # In cloned linux directory.\ngit clone --recurse-submodules \\ --branch $(scripts/min-tool-version.sh rustc) \\ https://github.com/rust-lang/rust \\ $(rustc --print sysroot)/lib/rustlib/src/rust This work clone rustlib repository in your rust toolchain directory.\ncargo install --locked --version $(scripts/min-tool-version.sh bindgen) bindgen This work need to bind existing c code to rust code. s\nCheck RUST_AVAILABLE\u003e Check RUST_AVAILABLE # cd ~/Develop/linux make LLVM=1 rustavailable $ make LLVM=1 rustavailable *** *** Rust compiler \u0026#39;rustc\u0026#39; is too new. This may or may not work. *** Your version: 1.64.0 *** Expected version: 1.62.0 *** Rust is available! Than if you get result like this it\u0026rsquo;s good to go\nConfigure linux source code with menuconfig\u003e Configure linux source code with menuconfig # make ARCH=arm64 defconfig make menuconfig Disable GCC plugins\u003e Disable GCC plugins # General architecture-dependent options -\u0026gt; GCC plugins For now (6.1 rc*), GCC_PLUGINS config should be disabled for RUST_CONFIG config. Be sure disable it.\nGeneral setup -\u0026gt; Rust support\u003e General setup -\u0026gt; Rust support # In General setup -\u0026gt; Rust support , Enable this If you don\u0026rsquo;t see the flag, double-check that the make LLVM=1 rustavailable process was successful. For a detailed mailing thread on CONFIG_RUST see here. See details \u0026rharu; Kernel hacking -\u0026gt; Sample kernel code\u003e Kernel hacking -\u0026gt; Sample kernel code # For easy to develop rust kernel code we need some examples. You can get them with following menus.\nIn Kernel hacking -\u0026gt; Sample kernel code , enable it (not all of them..) when you interest. I don\u0026rsquo;t recommend you enable them when you write own driver. Because there\u0026rsquo;s some possibility make system slow or make unwanted log in dmesg. In particular, the netflitter example outputs too many dmesg, so it is recommended that you disable it unless you are studying the netfilter example. Kernel hacking -\u0026gt; Rust hacking\u003e Kernel hacking -\u0026gt; Rust hacking # For debug rust kernel code or driver, need to enable some debug options.\nIn Kernel hacking -\u0026gt; Rust hacking , enables it and inside menus.\nCompile and install it in virtual machine.\u003e Compile and install it in virtual machine. # # -j4 for 4 core virtual machine, -j2 for 2 core, -j1 for single core. make LLVM=1 -j4 Build with following command. You need to set number of job considering assigned number of cores for virtual machine. (-j#)\nAlso while you build it, it will ask some flag. I just select default in my case.\nIt takes lot of time (don\u0026rsquo;t worry much better than raspberry pi 4), 13~14 minuites takes in my environment (VM 4core, 8GB)\nAfter than, install via following command\n# should be under the root permision. make modules_install make install update-grub It\u0026rsquo;s done!. Reboot program and then check the kernel working well.\nLinux lambda-next 6.0.0-rc7-175589-g542379556669 #2 SMP PREEMPT Sun Oct 2 19:02:32 KST 2022 aarch64 The programs included with the Debian GNU/Linux system are free software; the exact distribution terms for each program are described in the individual files in /usr/share/doc/*/copyright. Debian GNU/Linux comes with ABSOLUTELY NO WARRANTY, to the extent permitted by applicable law. Last login: Sun Oct 2 18:20:21 2022 from 192.168.99.1 pmnxis@lambda-next:~$ uname -r 6.0.0-rc7-175589-g542379556669 Simple compile speed comparation.\u003e Simple compile speed comparation. # Machine / Environment Compile time M1 Max Virtual Machine (4 core 8GB RAM with aarch64 debian11) 16 minutes M1 Asahi Linux (4P+4E core 16GB RAM MacMini with 6.1.0-rc6-asahi) 11 minutes AMD Ryzen 5950x Native (16 core 32 thread, 64GB with x86_64) 3 minutes AMD Threadripper Pro 5975wx Native (32 core 64 thread, 256GB with x86_64) 2 minutes ","date":"October 1, 2022","permalink":"/posts/rust_for_linux_with_m1/","section":"Posts","summary":"In October 1, Rust for linux is under the linux-next, not stable\nThus this article would be out-of-date before Linux 6.1 stable comes.\nThis article play with https://github.com/Rust-for-Linux/linux/tree/for-next/rust\nIntroduction\u003e Introduction # Currently Apple Silicon mac series is only one ARM workstation that have powerful performance as normal desktop class workstation and can purchase anywhere.","title":"Rust For Linux Development Environment with AppleSilicon MacOS"},{"content":"Introduction\u003e Introduction # ARMv8A는 흔히 aarch64로도 불리며 현재 ARMv7A를 뒤로한채 널리 사용하는 아키텍처중 하나입니다. 본 글에서는 ARMv8A의 메모리 시스템을 IP단위로 보려합니다.\n사용하는 메모리 (DDR4 , LPDDR4 , DDR3 , LPDDR3 , DDR2)나 사용하는 아키텍처(ARM v8.1 or 8.2)에 조금씩 다르나 대체적으로 위 사진과 같은 형태로 구성이 되어있습니다.\nComponents\u003e Components # CPU\u003e CPU # Instruction을 처리합니다.\nGIC\u003e GIC # Generic Interrupt Controller; GIC는 각종 Nested한 Interrupt를 관리하며, Interrupt발생시 CPU에서 동작중이던 PC/Register를 백업하고 해당하는 Inetrrupt Vector를 Execution하도록 합니다.\nCCI / CCN\u003e CCI / CCN # Cache Coherent Interconnect / Netowrk\nDMC\u003e DMC # DRAM을 관리합니다. DRAM은 휘발성 메모리로서 Read/Write 이외에 Refresh, Callibration 와 같은 작업이 필요합니다. 추가적으로 EEC, RAS에 대한 관리도 수행합니다. Linux드라이버에서는 edac 디렉터리에서 EEC, RAS에 대한 관리 드라이버 코드를 확인 할 수 있습니다.\nNIC\u003e NIC # 각종 Peripheral 을 연결하는데 사용합니다.\nMMU\u003e MMU # PA/VA (Physical/Virtual Address) 변환 DMA 컨트롤 Reference\u003e Reference # CCI-400 ; https://developer.arm.com/Processors/CoreLink%20CCI-400 CCI-500 ; https://developer.arm.com/Processors/CoreLink%20CCI-500 DMC-400 ; DDR3/DDR2 DMC ; https://developer.arm.com/documentation/ddi0466/f/introduction/about-the-dmc-400 DMC-500 ; LPDDR4/LPDDR3 DMC ; https://developer.arm.com/documentation/100131/0000 ","date":"December 14, 2021","permalink":"/posts/arm_v8a_memory_ip_review/","section":"Posts","summary":"Introduction\u003e Introduction # ARMv8A는 흔히 aarch64로도 불리며 현재 ARMv","title":"ARMv8A Memory IP Review"},{"content":"","date":"December 14, 2021","permalink":"/tags/electronics/","section":"Tags","summary":"","title":"Electronics"},{"content":"","date":"December 14, 2021","permalink":"/tags/korean_article/","section":"Tags","summary":"","title":"Korean_Article"},{"content":"","date":"January 1, 1","permalink":"/categories/","section":"Categories","summary":"","title":"Categories"}]