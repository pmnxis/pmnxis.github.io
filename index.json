[{"content":"1. Fourier series coefficients for Continuous signal\u003e 1. Fourier series coefficients for Continuous signal # Asking deriving coefficients comes with periodic signal.: \\(x(t) \\rightarrow a_k\\)\n1.1 (CT FS) Basic concept of continuous Fourier coefficients\u003e 1.1 (CT FS) Basic concept of continuous Fourier coefficients # $$ \\begin{gathered} x(t): \\text { Periodic signal } \\ T: \\text { Fundamental Period } \\ \\end{gathered} $$\n$$ \\begin{gathered} \\omega_0=\\frac{2 \\pi}{T} \\quad \u0026amp; \\quad f_0=\\frac{1}{T}(\\text { freq }) \\ \\end{gathered} $$\n$$ \\begin{gathered} \\quad x(t)=\\sum_{k=-\\infty}^{+\\infty} a_k e^{j k \\omega_0 t}=\\sum_{k=-\\infty}^{+\\infty} a_k e^{j k(2 \\pi / T) t} \\end{gathered} $$\n1.2 (CT FS) Continuous-Time, Fourier Series\u003e 1.2 (CT FS) Continuous-Time, Fourier Series # Convert periodic signal to fourier coefficients : \\(x(t) \\stackrel{F S}{\\rightarrow} a_k\\)\n$$ \\begin{gathered} a_k=\\frac{1}{T} \\int _T x(t) e^{-j k \\omega_0 t} d t \\ \\end{gathered} $$ $$ or $$\n$$ \\begin{gathered} a_k=\\frac{1}{T} \\int_T x(t) e^{-j k(2 \\pi / T) t} d t \\end{gathered} $$\n1.3 (CT IFS) Continuous-Time, Inverse Fourier Series\u003e 1.3 (CT IFS) Continuous-Time, Inverse Fourier Series # Fourier coefficients to peridoic signal : \\(a_k \\stackrel{I F S}{\\longrightarrow} x(t)\\)\n$$ x(t)=\\sum_{k=-\\infty}^{+\\infty} a_k e^{j k \\omega_0 t}=\\sum_{k=-\\infty}^{+\\infty} a_k e^{j k(2 \\pi / T) t} $$\n1.4 Properties of Continuous-Time Fourier Series\u003e 1.4 Properties of Continuous-Time Fourier Series # Fourier transform for Continuous-time signal $x(t)$ Most of case, aperiodic signals comes...\n2. Fourier coefficients for Discrete signal\u003e 2. Fourier coefficients for Discrete signal # $$ \\begin{gathered} x[n] \\rightarrow \\boldsymbol{a}_{\\boldsymbol{k}} \\end{gathered} $$ Asking deriving coefficients comes with periodic signal.\n2.1 (DT FS) Basic concept of discrete Fourier coefficients \\(x[n]: Periodic\\)\u003e 2.1 (DT FS) Basic concept of discrete Fourier coefficients \\(x[n]: Periodic\\) # $$ \\begin{gathered} x[n]: \\text { Periodic signal } \\end{gathered} $$\n$$ N \\text { : Fundamental Period (LCM of } 2 \\pi \\text { ) } $$\n$$ \\begin{gathered} \\omega_0=\\frac{2 \\pi}{N} \\quad \u0026amp; \\quad f_0=\\frac{1}{T}(\\text { freq }) \\end{gathered} $$\n$$ x[n]=\\sum_{k=\\langle N\\rangle} a_k e^{j k \\omega_0 n}=\\sum_{k=\\langle N\\rangle} a_k e^{j k(2 \\pi / N) n} $$\n2.3 (DT FS) Discrete-Time, Fourier Series\u003e 2.3 (DT FS) Discrete-Time, Fourier Series # $$\\begin{gathered} a_{k}=\\frac{1}{N} \\sum_{n=\\langle N\\rangle} x[n] e^{-j k \\omega_{0} n} \\ a_{k}=\\frac{1}{N} \\sum_{n=\\langle N\\rangle} x[n] e^{-j k(2 \\pi / N) n} \\end{gathered}$$\n$$\\begin{aligned} \u0026amp; x[n] \\stackrel{F S}{\\rightarrow} a_{k} \\end{aligned}$$\n2.4 (DT IFS) Discrete-Time, Inverse Fourier Series\u003e 2.4 (DT IFS) Discrete-Time, Inverse Fourier Series # $$a_{k} \\stackrel{I F S}{\\rightarrow} x[n] \\quad x[n]=\\sum_{k=\\langle N\\rangle} a_{k} e^{j k \\omega_{0} n}=\\sum_{k=\\langle N\\rangle} a_{k} e^{j k(2 \\pi / N) n}$$\n2.5 Properties of Continuous-Time Fourier Series\u003e 2.5 Properties of Continuous-Time Fourier Series # 3 Fourier transform for Continuous-time signal \\x(t)\\) :\u003e 3 Fourier transform for Continuous-time signal \\x(t)\\) : # 3.1 (CT FT) Continuous-Time, Fourier Transform ( periodic)\u003e 3.1 (CT FT) Continuous-Time, Fourier Transform ( periodic) # $$ x(t) \\stackrel{F T}{\\longrightarrow} X(j \\omega) $$\n$$ \\tilde{x}(t): \\text { single sliced periodic sig } \\ $$\n$$ a_k=\\frac{1}{T} \\int_{-\\frac{T}{2}}^{\\frac{T}{2}} \\tilde{x}(t) e^{-j k \\omega_0 t} d t $$ $$ X(j \\omega)=T a_k $$\n3.2 (CT FT) Continuous-Time, Fourier Transform (aperiodic)\u003e 3.2 (CT FT) Continuous-Time, Fourier Transform (aperiodic) # $$x(t) \\stackrel{F T}{\\rightarrow} X(j \\omega) \\quad X(j \\omega)=\\int_{-\\infty}^{+\\infty} x(t) e^{-j \\omega t} d t$$\n3.3 (CT IFT) Continuous-Time, Inverse Fourier Transform\u003e 3.3 (CT IFT) Continuous-Time, Inverse Fourier Transform # $$X(j w) \\stackrel{I F T}{\\rightarrow} x(t) \\quad x(t)=\\frac{1}{2 \\pi} \\int_{-\\infty}^{+\\infty} X(j \\omega) e^{j \\omega t} d \\omega$$\n3.4 Properties of Continuous Fourier Transform\u003e 3.4 Properties of Continuous Fourier Transform # 3.5 Basic Continuous Fourier Transform Pairs\u003e 3.5 Basic Continuous Fourier Transform Pairs # 4 Fourier transform for Discrete-time signal \\(x[n])\u003e 4 Fourier transform for Discrete-time signal \\(x[n]) # Most of case, aperiodic signals comesâ€¦\n4.1 (DT FT) Discrete-Time, Fourier Transform\u003e 4.1 (DT FT) Discrete-Time, Fourier Transform # $$x[n] \\stackrel{F T}{\\rightarrow} X\\left(e^{j \\omega}\\right) \\quad X\\left(e^{j \\omega}\\right)=\\sum_{n=-\\infty}^{+\\infty} x[n] e^{-j \\omega n}$$\n4.2 (DT IFT) Discrete-Time, Inverse Fourier Transform\u003e 4.2 (DT IFT) Discrete-Time, Inverse Fourier Transform # $$X\\left(e^{j \\omega}\\right) \\stackrel{I F T}{\\rightarrow} x[n] \\quad x[n]=\\frac{1}{2 \\pi} \\int_{2 \\pi} X\\left(e^{j \\omega}\\right) e^{j \\omega n} d \\omega$$\n4.3 Properties of Discrete Fourier Transform\u003e 4.3 Properties of Discrete Fourier Transform # 4.4 Basic Discrete Fourier Transform Pairs\u003e 4.4 Basic Discrete Fourier Transform Pairs # PDF version\u003e PDF version # Related files DSP_Fourier_CheatNote.pdf (275 KBytes) ","date":"December 20, 2022","permalink":"/posts/discrete_signal_processing_cheat_note/","section":"Posts","summary":"1. Fourier series coefficients for Continuous signal\u003e 1. Fourier series coefficients for Continuous signal # Asking deriving coefficients comes with periodic signal.: \\(x(t) \\rightarrow a_k\\)\n1.1 (CT FS) Basic concept of continuous Fourier coefficients\u003e 1.","title":"Discrete Signal Processing Fourier Transform Cheat Note"},{"content":"","date":"December 20, 2022","permalink":"/tags/dsp/","section":"Tags","summary":"","title":"DSP"},{"content":"","date":"December 20, 2022","permalink":"/tags/english_article/","section":"Tags","summary":"","title":"English_Article"},{"content":"","date":"December 20, 2022","permalink":"/tags/mathmatics/","section":"Tags","summary":"","title":"Mathmatics"},{"content":"","date":"December 20, 2022","permalink":"/posts/","section":"Posts","summary":"","title":"Posts"},{"content":"","date":"December 20, 2022","permalink":"/tags/signal-processing/","section":"Tags","summary":"","title":"Signal Processing"},{"content":"\nMore details for rust tags : Rust tag\n","date":"December 20, 2022","permalink":"/tags/","section":"Tags","summary":"More details for rust tags : Rust tag","title":"Tags"},{"content":" Here\u0026rsquo;s my cat LambdaÎ» who expert on electronic engineering. This blog mainly cover with Linux, Rust, Embedded, and electronic circuits, and articles in Korean and English are mixed. Sometimes my cat LambdaÎ» appears frequently, so I would appreciate it if you liked it. Nyaa ","date":"December 20, 2022","permalink":"/","section":"Welcome to Jinwoo and Lambda ğŸ± 's blog","summary":"Here\u0026rsquo;s my cat LambdaÎ» who expert on electronic engineering. This blog mainly cover with Linux, Rust, Embedded, and electronic circuits, and articles in Korean and English are mixed. Sometimes my cat LambdaÎ» appears frequently, so I would appreciate it if you liked it.","title":"Welcome to Jinwoo and Lambda ğŸ± 's blog"},{"content":"","date":"November 27, 2022","permalink":"/tags/korean_article/","section":"Tags","summary":"","title":"Korean_Article"},{"content":"Rust\n","date":"November 27, 2022","permalink":"/tags/rust/","section":"Tags","summary":"Rust","title":"Rust"},{"content":"ìƒˆë¡œ ì´ì§í•œ íšŒì‚¬ì—ì„œ Rustë¥¼ ì“°ê³  ìˆìŠµë‹ˆë‹¤. ì´ì§í•œì§€ 5ê°œì›”ì´ ì§€ë‚˜ê³  ëŠë‚€ ë°”ë¥¼ ì„œìˆ  í•´ë³´ê³ ì í•©ë‹ˆë‹¤. ë¬¸ë²•ì ì¸ ì„¸ì„¸í•œ ì¥ì ì€ ì œì³ë‘ê³  ê·¸ëƒ¥ ê°„ë‹¨í•˜ê²Œ ëŠë‚€ ë°”ë¥¼ ì„œìˆ  í•©ë‹ˆë‹¤.\nì¥ì \u003e ì¥ì  # ê°œë°œí•˜ë ¤ëŠ” ë„ë©”ì¸ì— ì˜ì•„ëŠ” ê°œë°œìê°€ ìˆìœ¼ë©°, ìµœì†Œ 2ì¸ì—ì„œ ì½”ë“œë¦¬ë·°ë¥¼ ì„œë¡œ ì˜í•´ì£¼ë©´ ì•ˆì „í•˜ê²Œ ì½”ë”©í• ìˆ˜ ìˆìŠµë‹ˆë‹¤. Cì–¸ì–´ì™€ ë¹„êµë¥¼ í•˜ë©´ ë§¤ìš° í¸ë¦¬í•œì ì´ ë§ìŠµë‹ˆë‹¤. Cì–¸ì–´/íŒì›¨ì–´ ë§Œ í•˜ë˜ ì‚¬ëŒìœ¼ë¡œì„œëŠ” ë‹¤ë¥¸ í˜„ëŒ€ì–¸ì–´ ëŒ€ë¹„ ì¢€ë” ì¹œìˆ™í•˜ê²Œ ëŠê»´ì§€ê³  ëŒ€ë¶€ë¶„ì˜ í–‰ìœ„/ì„¤ê³„ê°€ reasonable í•˜ê²Œ ëŠê»´ì§‘ë‹ˆë‹¤. ê°œì¸ì ì¸ ì˜ê²¬ìœ¼ë¡œëŠ” í”„ë¡ íŠ¸ì—”ë“œ ë¹¼ê³ ëŠ” ë§ì€ ë¶€ë¶„ì— ì ìš©í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤. [íŒì›¨ì–´, ìš´ì˜ì²´ì œ ì¢…ì† ìœ í‹¸ë¦¬í‹°, ë°±ì—”ë“œ] ê°œë°œí•˜ëŠ” ë¹„ì¦ˆë‹ˆìŠ¤ ë¡œì§ì— ëŒ€í•œê²ƒì´ ì•„ë‹Œ ìˆœìˆ˜ CSì— ëŒ€í•œ ê³µë¶€/ë„ì „ ìš”ì†Œê°€ ê³„ì† ìƒê¹ë‹ˆë‹¤. íƒ€ê²Ÿ ì•„í‚¤í…ì²˜ (CPU, Operating System)ê°€ ì–´ë–¤ ê²ƒì´ ì˜¤ë“ , ëŒ€ì‘í•˜ê¸° ë§¤ìš° í¸ë¦¬í•©ë‹ˆë‹¤. ë‹¨ì \u003e ë‹¨ì  # ìš°ë¦¬ëŠ” FullStackì„ ë„˜ì–´ EntireStack ê°œë°œìê°€ ë  ìˆ˜ ìˆì„ê¹Œ?\nê°ê°ì˜ ê³ ë‚œí¬ì¸íŠ¸ ë§ˆë‹¤ ê¸°ë³¸ì ìœ¼ë¡œ ìš”êµ¬í•˜ëŠ” ì§€ì‹ì´ í½ë‹ˆë‹¤. ê°€ë”ì€ ê°œì¸ì‹œê°„ì„ ë„˜ì–´ë“œëŠ” ê³µë¶€/ë„ì „ ìš”ì†Œê°€ ê³„ì† ìƒê¹ë‹ˆë‹¤. [ì €ì—ê² ë‹¨ì ì´ ì•„ë‹ˆë‚˜, ì‚¬ëŒì— ë”°ë¼ ë‹¨ì ì´ë¼ê³  ëŠë‚„ ìˆ˜ ìˆë‹¤ê³  ìƒê°í•©ë‹ˆë‹¤.] êµ¬ì¸ì‹œ ì œí•œì´ ë§ìŠµë‹ˆë‹¤. ì´ ì–¸ì–´ì˜ ì¥ì ì´ ë­ì•¼? ë¼ëŠ” ì§ˆë¬¸ì„ ë°›ì•˜ì„ ë•Œ, ìš”êµ¬í•˜ëŠ” ì§€ì‹ ë²”ìœ„ê°€ ë§¤ìš° ì»¤ì§ˆ ìˆ˜ ë°–ì— ì—†ìŠµë‹ˆë‹¤. ê·¸ë¦¬ê³  ê·¸ ì§€ì‹ë²”ìœ„ëŠ” ëŒ€ë‹¤ìˆ˜ì˜ ê´€ì‹¬ì‚¬ ì € ë©€ë¦¬ ì¼ ìˆ˜ ìˆìŠµë‹ˆë‹¤. ì„ë² ë””ë“œì—ì„œ ì‚¬ìš©í•˜ê³ , êµ­ë‚´ ê°œë°œì í’€ì„ ë³¸ë‹¤ë©´, ê°™ì´ ëŸ¬ìŠ¤íŠ¸ë¥¼ ì“¸ ì„ë² ë””ë“œ ê°œë°œìë¥¼ êµ¬í•˜ê¸°ê°€ ì–´ë µê³ , ì„ë² ë””ë“œ ê°œë°œìì—ê²Œ ì¶”ê°€ì ìœ¼ë¡œ ìš”êµ¬ë˜ëŠ” ëŠ¥ë ¥ì˜ í’€ì´ ê½¤ ê¸°í•˜ê¸‰ìˆ˜ì ìœ¼ë¡œ ëŠ˜ì–´ë‚©ë‹ˆë‹¤. ì„ë² ë””ë“œ ê°œë°œì„ ì£¼(ä¸»)ë¡œ í•˜ì§„ ì•Šìœ¼ë‚˜ rustë¥¼ ê³ ë ¤í•˜ì§€ì•Šì•„ë„ ì„ë² ë””ë“œ ê°œë°œì í’€ì´ ë„ˆë¬´ ì ìŠµë‹ˆë‹¤. ê¼­ ì œê°€ ì“°ë ¤ê³ í•˜ëŠ” ì¹©ì€ rust ì„ë² ë””ë“œ ì§€ì›ì´ ì• ë§¤í•©ë‹ˆë‹¤. (ì—¬ê¸°ì— ëŒ€í•œ ë‹µì€ ì œê°€ ìŠ¤ìŠ¤ë¡œ ê¸°ì—¬ë¥¼ í•˜ëŠ” ê²ƒì´ê¸´í•©ë‹ˆë‹¤.) ì•„ì§ê¹Œì§€ëŠ” ì»¤ë®¤ë‹ˆí‹°ê°€ chip-shortageì¸ ìƒí™©ì— ì•Œì§œë² ê¸° ë‹¨ê°€/lead time ë©´ì—ì„œ ì“¸ë§Œí•œ ì¹©ë³´ë‹¤ëŠ” toy-projectë¡œ ì“¸ë§Œí•œ ì¹©ì— ë” ì¹˜ì¤‘ì— ë˜ì–´ìˆìŠµë‹ˆë‹¤. ê¸°íƒ€\u003e ê¸°íƒ€ # ì´ì „íšŒì‚¬ì—ì„œ ì½”ë“œë¦¬ë·°ê´€ë ¨í•´ì„œ ë§¤ìš° ê¹ê¹í•˜ê²Œ í–ˆì—ˆê³  ì§€ê¸ˆ íšŒì‚¬ì—ì„œëŠ” ì–´ë–»ê²Œ ë˜ë‚˜ ê±±ì •í–ˆì—ˆëŠ”ë°. ì œê°€ ì´ˆë°˜ì— ëŠë‚€ë°”ë¡œëŠ” Cì–¸ì–´ ëŒ€ë¹„ ë¬¸ë²•ì´ ê³ ë„í™” ë˜ì–´ìˆê¸°ì— ìŠ¤íƒ€ì¼ì´ ì§€ë‚˜ì¹˜ê²Œ ê°œì¸ë§ˆë‹¤ ë‹¬ë¼ì„œ ë¦¬ë·°í•  ë•Œ ì´ ë¬¸ì œê°€ ë³‘ëª©ì‚¬í•­ì´ë¼ ìƒê°í–ˆìŠµë‹ˆë‹¤ë§Œ. ë§ì€ê²ƒ ë“¤ì„ clippyê°€ ì–´ëŠì •ë„ í•´ì£¼ê³  typo checkì™€ ì–´ëŠì •ë„ ì„ ì—ì„œ í•©ì˜ë³¼ìˆ˜ ìˆëŠ” ìˆ˜ì¤€ì˜ testë§Œ ìˆìœ¼ë©´ ë¦¬ë·°ëŠ” ë¬¸ì œì—†ë„¤ìš”. ì„œë¡œê°€ ìì—°ìŠ¤ë ˆ ê±´ì „í•œ CS ì£¼ì œë¡œ í† ë¡ ì„ í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤ ì—¬ëŸ¬ ì•„í‚¤í…ì²˜ì— ì ì ˆí•œ ëŒ€ì‘ì´ ê°€ëŠ¥\u003e ì—¬ëŸ¬ ì•„í‚¤í…ì²˜ì— ì ì ˆí•œ ëŒ€ì‘ì´ ê°€ëŠ¥ # ì´ë¡ ì´ë‚˜ ê°œë…ìƒìœ¼ë¡œëŠ” ìˆœìˆ˜íˆ ì¸í„°í”„ë¦¬í„° ì–¸ì–´ ê°€ ë©€í‹°í”Œë«í¼ ëŒ€ì‘ì— ìœ ë¦¬í•©ë‹ˆë‹¤. í•˜ì§€ë§Œ ì œê°€ ì‹¤ì œë¡œ Rustë¥¼ í•´ë³¸ ê²½í—˜ ì¡°ê¸ˆ ë‹¤ë¥´ê²Œ ëŠê¼ˆìŠµë‹ˆë‹¤. ì•„ë¬´ë¦¬ ì´ë¡ ê³¼ ê°œë…ìƒìœ¼ë¡œ ì¸í„°í”„ë¦¬í„° ì–¸ì–´ê°€ ìœ ë¦¬í•˜ë‹¤ê³ ëŠ” í•˜ë‚˜, ì§„ì •ìœ¼ë¡œ ëª¨ë“  ì•„í‚¤í…ì²˜(CPU Archì™€ ì—¬ëŸ¬ OSì— ëŒ€ì‘)ë¥¼ ì ì ˆí•˜ê²Œ ì˜ ëŒ€ì‘ í•˜ê¸°ì—ëŠ” Rustê°€ ë§¤ìš° í¸í–ˆìŠµë‹ˆë‹¤.\nìš°ì„  ëª¨ë“  ì•„í‚¤í…ì²˜ë¥¼ ì ì ˆí•˜ê²Œ ëŒ€ì‘í•œë‹¤ë¼ëŠ” ë©´ì€ ì‹œìŠ¤í…œ í”„ë¡œê·¸ë˜ë° í˜¹ì€ íŒì›¨ì–´ í”„ë¡œê·¸ë˜ë°ì˜ ê°€ì¹˜ ì¤‘ í•˜ë‚˜ì…ë‹ˆë‹¤. ê·¸ëŸ¼ ê¸°ì¡´ì— ì´ëŸ¬í•œ í”„ë¡œê·¸ë˜ë°ì„ í•˜ê¸°ìœ„í•´ì„œ ì–´ë– í•œ ì–¸ì–´ë¥¼ ì¼ì„ê¹Œìš”. ë°”ë¡œ Cì™€ **C++**ì…ë‹ˆë‹¤. í•˜ì§€ë§Œ í•´ë‹¹ ì–¸ì–´ë¡œ ë°”ë¡œ ë¹ ë¥´ê²Œ ë¹ ë¥´ê²Œ ì‹œì‘(Getting Start) í•˜ê¸°ìœ„í•´ì„œëŠ” Makefile ì´ë‚˜ CMake ì„¤ì •ë¶€í„° í•´ì¤˜ì•¼ í–ˆìœ¼ë©°, ì•„í‚¤í…ì²˜ê°€ ì¶”ê°€ë  ë•Œ ë§ˆë‹¤ ì´ì— ëŒ€ì‘í•´ì¤˜ì•¼ í–ˆìŠµë‹ˆë‹¤. ì—¬ê¸°ì— í•´ë‹¹ ì•„í‚¤í…ì²˜ë¥¼ ìœ„í•œ ì»´íŒŒì¼ëŸ¬, ê°œë°œí™˜ê²½, ë¼ì´ë¸ŒëŸ¬ë¦¬ ì„¸íŒ…ì€ ë³„ë„ì…ë‹ˆë‹¤.\nê·¸ëŸ¼ ë‹¤ë¥¸ ì–¸ì–´ì™€ ë¹„êµë¥¼ í•´ë³´ê² ìŠµë‹ˆë‹¤. í˜„ì¬ëŠ” Go-Langê³¼ Rustë¥¼ ë¹„êµí•˜ëŠ” ì‚¬ëŒì€ ê±°ì˜ ì—†ìœ¼ë‚˜, 5ë…„ì „ì—ëŠ” ë§ì´ë“¤ ë¹„êµí–ˆë˜ ê²ƒ ê°™ìŠµë‹ˆë‹¤. ì‹œìŠ¤í…œ í”„ë¡œê·¸ë˜ë°ì˜ ì˜ì—­ì„ OSìœ„ì—ì„œë§Œ ë¹„êµí•œë‹¤ê³  í–ˆì„ë•Œì—ëŠ” ë‘˜ ë‹¤ í›Œë¥­í•œ ì–¸ì–´ì…ë‹ˆë‹¤. ì•ìœ¼ë¡œ ë§í•œ ê²ƒì€ ë§¤ìš° ë¬´ë¦¬ìˆ˜ì¸ ë°œì–¸ì´ë‚˜, Rustê°œë…ìƒì˜ no-std, OSê°€ ì—†ê±°ë‚˜ ì¼ë°˜ì ì¸ OSì™€ëŠ” ë§¤ìš° í˜•ì§ˆì´ ë‹¤ë¥¸ê²½ìš°ì—ëŠ” ëŒ€ì‘ì´ ì–´ë µìŠµë‹ˆë‹¤. [í•„ìëŠ” íŒì›¨ì–´ ê°œë°œì„ ì´ì „ì— í•˜ì˜€ìœ¼ë©°, ì œí’ˆ ì¶œí•˜ê°€ ê°€ëŠ¥í•œ íŒì›¨ì–´ ê°œë°œì´ ê°€ëŠ¥í•œê°€ë¥¼ ì¶”ê°€ë¡œ ë”°ì§€ê³  ìˆìŠµë‹ˆë‹¤.]\nRustëŠ” ë‹¹ì¥ì— ë¹ ë¥´ê²Œ í”„ë¡œí† íƒ€ì´í•‘ í•˜ê¸°ëŠ” ì–´ë µë‹¤.\u003e RustëŠ” ë‹¹ì¥ì— ë¹ ë¥´ê²Œ í”„ë¡œí† íƒ€ì´í•‘ í•˜ê¸°ëŠ” ì–´ë µë‹¤. # ì•ì—ì„œëŠ” Rustì˜ ì¥ì ì— ëŒ€í•´ ì¹­ì°¬í•˜ì˜€ì§€ë§Œ ì´ë²ˆ ë¬¸ë‹¨ì—ì„œëŠ” ì‚´ì§ ì•„ì‰¬ìš´ë©´ì„ ì„œìˆ í•©ë‹ˆë‹¤. RustëŠ” ì“°ê¸° ì–´ë ¤ìš´ ì–¸ì–´ì…ë‹ˆë‹¤. ì •í™•íˆ ë§í•˜ë©´ Rustì˜ ì¥ì ì„ ìµœëŒ€í•œ ì‚´ë ¤ì„œ RustìŠ¤ëŸ½ê²Œ, Rustì˜ ì¥ì ì„ ìµœëŒ€í•œ ë¶€ê°ì‹œí‚¤ë©° ê°œë°œí•˜ê¸° ë§¤ìš° ì–´ë µìŠµë‹ˆë‹¤. í˜„ì‹¤ì ìœ¼ë¡œ ëª¨ë“  ì–¸ì–´ê°€ ì¥ì ì„ ì‚´ë ¤ì„œ ê°œë°œí•˜ê¸°ì—ëŠ” ë§¤ìš° ì–´ë ¤ìš¸ ê²ƒì…ë‹ˆë‹¤. í•˜ì§€ë§Œ ì˜ë¦¬í™œë™(íšŒì‚¬/ê°œë°œì¡°ì§ì—ì„œ ì‚¬ìš© ì–¸ì–´? í”„ë ˆì„ì›Œí¬)ìœ¼ë¡œì„œ Rustë¥¼ ì„ íƒí•œë‹¤ë©´, ê°œì¸ì ì¸ ì„ í˜¸ëŠ” í›„ìˆœìœ„ë¡œ ë¯¸ë£¬ ì±„ íšŒì‚¬ì˜ ì…ì¥ì—ì„œ ìƒê°í•´ë´ì•¼í•©ë‹ˆë‹¤.\nìš°ë¦¬ê°€ ê°œë°œí•  ìˆ˜ ìˆëŠ” ê²ƒì„ ì‹¤í˜„í•´ì¤„ ìˆ˜ ìˆëŠ” ë§¤ê²Œì²´ì¸ê°€. ê°œë°œìë¥¼ ì ì ˆíˆ êµ¬ì¸í•  ìˆ˜ ìˆëŠ”ê°€. ê°œë°œ ì‹œê°„ ì†Œìš”ê°€ ì–´ë–»ê²Œ ë˜ëŠ”ê°€. ë¹ ë¥´ê³  ì •í™•í•˜ê²Œ ëŒì•„ê°€ëŠ”ê°€. êµ¬ì„±ì›ë“¤ì´ ì“°ê³ ì‹¶ì–´í•˜ëŠ”ê°€. (ë‹¤ë¥¸ ì˜ë¯¸ë¡œ ì·¨í–¥) RustëŠ” (2), (3) í•­ëª©ì—ì„œ ë‚®ì€ ì ìˆ˜ë¥¼ ë°›ì„ ê°€ëŠ¥ì„±ì´ í¬ë©°, íŠ¹íˆë‚˜ (2) í•­ëª©ì—ì„œëŠ” ì ˆëŒ€ì ìœ¼ë¡œ ê·¸ë ‡ë‹¤ê³  ìƒê°í•©ë‹ˆë‹¤.\nìœ„ì™€ ê°™ì€ ë‹¨ì ì„ ê·¹ë³µí•˜ê³ ë¼ë„ Rustë¥¼ ì„ íƒí•´ì•¼ë§Œ í•œë‹¤ë©´ íŠ¹íˆë‚˜ (4), (5) ì˜ ì›ì¸ì´ í´ ê²ƒì…ë‹ˆë‹¤. ì´ë ‡ê²Œ ëœë‹¤ë©´ ê°œë°œì¡°ì§, ê°œë°œì ì…ì¥ì—ì„œëŠ” ìµœëŒ€í•œ Rustì˜ ì¥ì ì„ ë¶€ê°í•˜ëŠ” ì‚¬ê±´ì´ë‚˜ ê²°ê³¼ê°€ ìˆì–´ì•¼ì§€ë§Œ ì´ë¥¼ ìì˜ì ì´ë“  íƒ€ì˜ì ì´ë“  ìœ ì§€í•˜ê²Œ ë  ê²ƒ ì…ë‹ˆë‹¤.\nì•„ë¬´ë¦¬ íšŒì‚¬ì—ì„œ ì •í•´ì£¼ëŠ” ì–¸ì–´ë¥¼ ì“°ë©´ë˜ì§€ë§Œ, ê·¸ë˜ë„ ì„ íƒí• ìˆ˜ ìˆê³  Rustë¥¼ ê³„ì† ì“°ê³ ì‹¶ë‹¤ë©´ ë¶€ê°í•˜ê³  ì‹¶ì„ ê²ë‹ˆë‹¤. (ì¢€ ì„œìˆ í•˜ê¸° ì–´ë ¤ìš´ ë¶€ë¶„ì…ë‹ˆë‹¤. ê°ì •ì ì¸ ì˜ì—­ì´ ê²¹ì³ì ¸ ìˆì–´ì„œìš”)\nê·¸ëŸ¬ë©´ Rust ì˜ ì¥ì ì„ ìµœëŒ€í•œ ì‚´ë ¤ì„œ ê°œë°œí•˜ë ¤ë©´ ë§ì€ ì§€ì‹ì„ ìš”êµ¬í•˜ê²Œ ë˜ë²„ë¦½ë‹ˆë‹¤. ë‹¤ë¥¸ ë¬¸ì¥ìœ¼ë¡œ ëŸ¬ë‹ ì»¤ë¸Œê°€ ë†’ì•„ì§‘ë‹ˆë‹¤. ì–´ë–»ê²Œ ë³´ë©´ ìŠ¤ìŠ¤ë¡œ ë¬´ë¤ì„ íŒŒëŠ” í–‰ìœ„ê°€ ë  ìˆ˜ë„, ê¸°íšŒê°€ ë  ìˆ˜ ë„ ìˆìŠµë‹ˆë‹¤.\ní•˜ì§€ë§Œ ë§ì€ ì§€ì  ê°€ì¹˜ë¥¼ ì–»ì„ ìˆ˜ ìˆëŠ” ê¸°íšŒ\u003e í•˜ì§€ë§Œ ë§ì€ ì§€ì  ê°€ì¹˜ë¥¼ ì–»ì„ ìˆ˜ ìˆëŠ” ê¸°íšŒ # ì²˜ìŒì— Cì–¸ì–´ê°€ ë‚˜ì™”ì„ ë•ŒëŠ” ë©€í‹° í”„ë¡œì„¸ì‹±/í”„ë¡œì„¸ì„œ(SMP) ê°œë…ì´ë‚˜ ìºì‹œì˜ ê°œë…, GPGPUì´ ì—†ìœ¼ë©°, ì„¸ì„¸í•œ ë¶€ë¶„ì— ìˆì–´ì„œ í˜„ëŒ€ì ì¸ ë©”ëª¨ë¦¬ ëª¨ë¸ê³¼ëŠ” ë‹¤ë¥´ë˜ ì‹œì ˆì…ë‹ˆë‹¤. ê·¸ë¦¬ê³  ì§€ê¸ˆê¹Œì§€ëŠ” Cì–¸ì–´ë¡œ ì´ëŸ¬í•œ ë¶€ë¶„ì„ í•¸ë“¤ë§ í•˜ê³  ìˆìŠµë‹ˆë‹¤. ê·¸ë¦¬ê³  ì´ëŸ¬í•œ ê°œë…ë“¤ì„ ê³ ë ¤í•˜ë©´ì„œ ê°œë°œí•´ì•¼í•˜ëŠ” ìƒí™©ì— ë†“ì¸ë‹¤ë©´ ë§ì€ ì–´ë ¤ì›€ì´ ìˆìŠµë‹ˆë‹¤.\ní•˜ì§€ë§Œ RustëŠ” ì´ë¥¼ ì–´ëŠì •ë„ ì‰½ê²Œ ê·¹ë³µí•  ìˆ˜ ìˆëŠ” ì¸í”„ë¼ê°€ ë§ˆë ¨ë˜ì–´ ìˆê±°ë‚˜, ì•ìœ¼ë¡œë„ ë” ë§ˆë ¨ë  ì—¬ì§€ê°€ ìˆìŠµë‹ˆë‹¤. ê·¸ë¦¬ê³  ì• ë§¤í•œ ë¬¸ì¥ì´ì§€ë§Œ, Rustë¥¼ í†µí•´ ê°„ì ‘ìœ¼ë¡œ ì–´ë ¤ìš´ ì»´í“¨í„°ë‚˜ ìš´ì˜ì²´ì œì˜ ì•„í‚¤í…ì²˜ ì„¤ê³„ì— ëŒ€í•´ ì¢€ë” ë©´ë°€íˆ ë³¼ ìˆ˜ ìˆëŠ” ê¸°íšŒê°€ ë§ˆë ¨ì´ ë˜ëŠ” ê²ƒ ê°™ìŠµë‹ˆë‹¤. ì´ëŠ” Rust ì»´íŒŒì¼ëŸ¬ì˜ ì•ˆì „ì„ ìœ„í•œ ì œì•½ê²½ê³ ë¥¼ í†µí•´ì„œë„ ì–»ì„ ìˆ˜ ìˆìœ¼ë©°, ìš°ì—°ì¹˜ ì•Šê²Œ ë§ì€ ê³ ìˆ˜ë“¤ë¡œ ì´ë¤„ì§„ ì‹œìŠ¤í…œ í”„ë¡œê·¸ë˜ë° ê°œë°œìë“¤ì´ ë§ì€ ì»¤ë®¤ë‹ˆí‹°ì˜ ì˜í–¥ì´ ì›ì¸ìœ¼ë¡œ ì‘ìš©í•œë‹¤ê³  ìƒê°í•©ë‹ˆë‹¤. ë©€í‹° í”Œë«í¼ì— ëŒ€í•œ ì–˜ê¸°ë¥¼ ì¡°ê¸ˆë” í•˜ìë©´, ì»¤ë®¤ë‹ˆí‹°ì˜ ê°•ë ¥í•¨ìœ¼ë¡œ ì¸í•´ ë©€í‹°í”Œë«í¼ì´ ë§¤ìš° ì˜ ëŒ€ì‘ ëœë‹¤ê³ ë„ ìƒê°í•©ë‹ˆë‹¤.\nì–¸ì œ ì¯¤ ì¶©ë¶„í•œ Rust ê°œë°œìê°€ ë˜ì—ˆë‹¤ê³  í•  ìˆ˜ ìˆì„ê¹Œ?\u003e ì–¸ì œ ì¯¤ ì¶©ë¶„í•œ Rust ê°œë°œìê°€ ë˜ì—ˆë‹¤ê³  í•  ìˆ˜ ìˆì„ê¹Œ? # ë‚˜ëŠ” ____ ê°œë°œìì•¼ ë¼ê³  ë‹¤ë“¤ ê°€ë” ì‹ ë§í•˜ê³¤ í•©ë‹ˆë‹¤. ê·¸ëŸ¬ë©´ ì–¸ì œ ì¯¤ ìš°ë¦¬ëŠ” ì¶©ë¶„í•œ Rust ê°œë°œìê°€ ë˜ì—ˆë‹¤~ ë¼ê³  ë§í•  ìˆ˜ ìˆì„ê¹Œìš”.\nì •ë‹µì€ ì—†ìŠµë‹ˆë‹¤.\ní•˜ì§€ë§Œ ê°œì¸ì ì¸ ìƒê°ìœ¼ë¡œëŠ” í•´ë‹¹ í”„ë ˆì„ì›Œí¬ í˜¹ì€ ì–¸ì–´ê°€ ê°€ì ¸ë‹¤ì£¼ëŠ” ì¥ì ì„ ë‚¨ë“¤ì´ ì´í•´í•  ìˆ˜ ìˆê²Œë” ì„¤ëª…í•  ìˆ˜ ìˆë‹¤ë©´ ____ ê°œë°œìë¼ê³  ë§ í•  ìˆ˜ ìˆì§€ ì•Šì„ê¹Œ? ë¼ê³  ìƒê°í•©ë‹ˆë‹¤.\ní•˜ì§€ë§Œ ì•„ì‰½ê²Œë„ Rust ëŠ” ì´ë¥¼ ì„œìˆ  í•˜ê¸°ê°€ ë§¤ìš° ì–´ë µìŠµë‹ˆë‹¤. ë‹¹ì¥ì— ì†Œìœ ê¶Œ ë¶€í„° ì„¤ëª…í•´ì•¼ í•©ë‹ˆë‹¤ë§Œ. ì¼ë‹¨ ê¸°ë³¸ì ìœ¼ë¡œ ì‹¤í–‰ ì¤‘ì¸ processsì˜ stack, heap ë¶€í„° ì´í•´ë¥¼ í•´ì•¼í•©ë‹ˆë‹¤.\nì°¸ê³  ìë£Œ : 4.1 ì†Œìœ ê¶Œì´ ë­”ê°€ìš” - The Rust Programming Language í•œêµ­ì–´ ë²ˆì—­\nì´ëŸ¬í•œ ë¬¸ì œë¡œ ì„¤ë“ì‹œí‚¤ë ¤ê³  í•˜ëŠ” ëŒ€ìƒì—ê²Œ ë§ì€ê²ƒì„ ì„¤ëª…í•´ì¤„ ëŠ¥ë ¥ì´ ë˜ì•¼í•˜ê±°ë‚˜, ë“£ëŠ” ëŒ€ìƒì´ ìˆ˜ì¤€ì´ ë†’ê¸°ì— ì •í™•í•˜ê³  ë§¤ìš° ê¹Šì€ ì„¤ëª…ì´ ìš”êµ¬ë˜ëŠ” ìƒí™©ì…ë‹ˆë‹¤.\nì²˜ìŒë¶€í„° ì„¤ëª…ì˜ ë‚œì´ë„ê°€ HARD MODE ì¸ ê²ƒì€ ì•„ì‰½ì§€ë§Œ, í˜¼ì ê°œë°œí•˜ëŠ” ì„¸ìƒë„ ì•„ë‹ ë¿ë”ëŸ¬, ìš°ë¦¬ê°€ ê°œë°œì„ í• ë•Œì— Pull-Requestë¥¼ ì§„ì •ìœ¼ë¡œ ë„£ê³  ì‹¶ë‹¤ë©´ Reviewë¥¼ í•´ì£¼ëŠ” ì‚¬ëŒì—ê²Œ ì„¤ëª…ì„ ì˜ í•˜ê±°ë‚˜, ì˜ í• ìˆ˜ ìˆë„ë¡ ì½”ë“œë¥¼ ì§œëŠ” ê²ƒì€ ì–´ëŠì •ë„ í•„ìš”í•˜ë‹¤ ìƒê°í•©ë‹ˆë‹¤.\nê·¸ëŸ¬í•œ ê³¼ì • ì†ì—ì„œ ì„¤ëª…ì„ í•  ìˆ˜ ìˆëŠ” ì§€ì‹ì˜ ë°”íƒ•ê³¼ ë§ ì†œì”¨ë¥¼ ëŠ˜ë¦´ ìˆ˜ ìˆìœ¼ë©°, ë” ë‚˜ì•„ê°€ì„œ ì„œìˆ  í•œëŒ€ë¡œ ì–´ë– í•œ ê¸°ìˆ ì— ëŒ€í•´ ì„¤ëª…í•  ìˆ˜ ìˆëŠ” ëŠ¥ë ¥ì´ ê°–ì¶°ì§€ì§€ ì•Šì„ê¹Œ ìƒê°í•©ë‹ˆë‹¤.\në‹¤ìŒ í˜¹ì€ ë‹¤ë‹¤ìŒì— íšŒê³ ë¡ì„ ì‘ì„± í•  ë•Œì—ëŠ” Rust íšŒì‚¬ì—ì„œ ì¨ì„œ ì–»ì—ˆë˜ ì‹¤ì œì˜ ì´ë“, ì†ì‹¤ì— ëŒ€í•´ì„œ ë‹¤ë¤„ë³´ë„ë¡ í•˜ê² ìŠµë‹ˆë‹¤.\n","date":"November 27, 2022","permalink":"/posts/five_mothes_ago_from_using_rust_as_work_kr/","section":"Posts","summary":"ìƒˆë¡œ ì´ì§í•œ íšŒì‚¬ì—ì„œ Rustë¥¼ ì“°ê³  ìˆìŠµë‹ˆë‹¤. ì´ì§í•œì§€ 5ê°œì›”ì´ ì§€","title":"Rustë¥¼ íšŒì‚¬ ì—…ë¬´ë¡œ ì“°ê³ ë‚œì§€ 5ê°œì›” ì •ë„"},{"content":"","date":"November 27, 2022","permalink":"/tags/%ED%9A%8C%EA%B3%A0%EB%A1%9D/","section":"Tags","summary":"","title":"íšŒê³ ë¡"},{"content":"","date":"October 4, 2022","permalink":"/tags/armv8a/","section":"Tags","summary":"","title":"ARMv8A"},{"content":"","date":"October 4, 2022","permalink":"/tags/cross-compile/","section":"Tags","summary":"","title":"Cross compile"},{"content":" In October 6, Rust for linux is under the linux-next, not stable\nThus this article would be out-of-date before Linux 6.1 stable comes.\nCurrent linux 6.1 rc1 doesn\u0026rsquo;t contain rust for linux with ARM64. Thus this article play with https://github.com/Rust-for-Linux/linux/tree/for-next/rust\nIntroduction\u003e Introduction # This article describes cross-compiling rust for linux on x86_64 debian. There is still not enough computing power to build arm64 native kernel except for Apple Silicon.\nBtw, this article is in reference to these links\nhttps://github.com/Rust-for-Linux/linux/blob/rust/Documentation/rust/quick-start.rst https://docs.kernel.org/kbuild/llvm.html#cross-compiling Debian / Ubuntu Package Requirements\u003e Debian / Ubuntu Package Requirements # # Install build-requirements for kernel compile with LLVM. # Biggest difference to native build is # crossbuild-essential-arm64 needed to build` for arm64 apt install clang git llvm-dev libclang-dev build-essential \\ bc kmod cpio flex libncurses5-dev libelf-dev libssl-dev \\ dwarves bison lld curl crossbuild-essential-arm64 Before build kernel, we need to install some packages.\ncurl --proto \u0026#39;=https\u0026#39; --tlsv1.2 -sSf https://sh.rustup.rs | sh rustup default 1.62 rustup component add rust-src # rustfmt and clippy is need for later developing and debugging. rustup component add rustfmt rustup component add clippy Install rust with curl. You can select just default options. Also current rust for linux working with 1.62. Some native compile is working well with recent version (1.64 tested, but cross compile not working).\nArch Package Requirements\u003e Arch Package Requirements # TBD Clone linux from Rust-For-Linux\u003e Clone linux from Rust-For-Linux # State of current rust-for-linux, they are under 6.0 RC\n# In my case use `Develop` as worksapce, you can replace this word. mkdir -p ~/Develop cd ~/Develop git clone https://github.com/Rust-for-Linux/linux.git -b rust clone like this.\nNecessary some rust scripts in Rust-For-Linux\u003e Necessary some rust scripts in Rust-For-Linux # In cloned linux directory.\ngit clone --recurse-submodules \\ --branch $(scripts/min-tool-version.sh rustc) \\ https://github.com/rust-lang/rust \\ $(rustc --print sysroot)/lib/rustlib/src/rust This work clone rustlib repository in your rust toolchain directory.\ncargo install --locked --version $(scripts/min-tool-version.sh bindgen) bindgen This work need to bind existing c code to rust code. s\nCheck RUST_AVAILABLE\u003e Check RUST_AVAILABLE # cd ~/Develop/linux make LLVM=1 rustavailable $ make LLVM=1 rustavailable *** *** Rust compiler \u0026#39;rustc\u0026#39; is too new. This may or may not work. *** Your version: 1.62.1 *** Expected version: 1.62.0 *** Rust is available! Than if you get result like this it\u0026rsquo;s good to go (1.62.1 was fine to cross compile, but if you consider best fit, run rustup default 1.62.0.)\nConfigure linux source code with menuconfig\u003e Configure linux source code with menuconfig # make ARCH=arm64 CROSS_COMPILE=aarch64-linux-gnu- defconfig make ARCH=arm64 CROSS_COMPILE=aarch64-linux-gnu- menuconfig General setup -\u0026gt; Rust support\u003e General setup -\u0026gt; Rust support # In General setup -\u0026gt; Rust support , Enable this If you don\u0026rsquo;t see the flag, double-check that the make LLVM=1 rustavailable process was successful. For a detailed mailing thread on CONFIG_RUST see here. See details \u0026rharu; Kernel hacking -\u0026gt; Sample kernel code\u003e Kernel hacking -\u0026gt; Sample kernel code # For easy to develop rust kernel code we need some examples. You can get them with following menus.\nIn Kernel hacking -\u0026gt; Sample kernel code , enable it (not all of them..) when you interest. I don\u0026rsquo;t recommend you enable them when you write own driver. Because there\u0026rsquo;s some possibility make system slow or make unwanted log in dmesg. In particular, the netflitter example outputs too many dmesg, so it is recommended that you disable it unless you are studying the netfilter example. Kernel hacking -\u0026gt; Rust hacking\u003e Kernel hacking -\u0026gt; Rust hacking # For debug rust kernel code or driver, need to enable some debug options.\nIn Kernel hacking -\u0026gt; Rust hacking , enables it and inside menus.\nCross compile\u003e Cross compile # # -j4 for 4 core virtual machine, -j2 for 2 core, -j1 for single core. make ARCH=arm64 CROSS_COMPILE=aarch64-linux-gnu- LLVM=1 -j32 Build with following command. You need to set number of job considering assigned number of cores for virtual machine. (-j#)\nAlso while you build it, it will ask some flag. I just select default in my case.\nSimple compile speed comparation.\u003e Simple compile speed comparation. # Machine / Environment Compile time M1 Max Virtual Machine (4 core 8GB RAM with aarch64 debian11) 16 minutes M1 Asahi Linux (4P+4E core 16GB RAM MacMini with 6.1.0-rc6-asahi) 11 minutes AMD Ryzen 5950x Native (16 core 32 thread, 64GB with x86_64) 3 minutes AMD Threadripper Pro 5975wx Native (32 core 64 thread, 256GB with x86_64) 2 minutes Install cross compiled kernel to arm64 virtual machine\u003e Install cross compiled kernel to arm64 virtual machine # TBD, will update asap. Install cross compiled kernel to raspberry pi\u003e Install cross compiled kernel to raspberry pi # TBD, will update asap. ","date":"October 4, 2022","permalink":"/posts/cross_compiling_aarch64_rust_for_linux_from_x86_64_linux/","section":"Posts","summary":"In October 6, Rust for linux is under the linux-next, not stable\nThus this article would be out-of-date before Linux 6.1 stable comes.\nCurrent linux 6.1 rc1 doesn\u0026rsquo;t contain rust for linux with ARM64.","title":"Cross compiling aarch64(arm64) rust for linux from x86_64 machine"},{"content":"","date":"October 4, 2022","permalink":"/tags/linux/","section":"Tags","summary":"","title":"Linux"},{"content":" In October, Rust for linux is under the linux-next, not stable\nThus this article would be out-of-date before Linux 6.1 stable comes.\nmodules, out-of-tree\u003e modules, out-of-tree # There are two main ways to develop kernel modules. In-Of-Tree and Out-Of-Tree. In this article, we\u0026rsquo;re going to make the Out-Of-Tree method a Rust kernel module.\nBefore we start\u003e Before we start # Check your kernel has been compiled with CONFIG_RUST=y.\u003e Check your kernel has been compiled with CONFIG_RUST=y. # Check with following command.\nzcat /proc/config.gz | grep -i CONFIG_RUST=y The result comes with CONFIG_RUST=y.\nBut you may not check from /proc/config.gz when using distibution kernel image that downloaded or pre-installed.\nNeed some build \u0026 install rust support kernel see here. See details \u0026rharu; Prepare $KDIR\u003e Prepare $KDIR # $KDIR is path of kernel source.\nIn this article path of kernel source that system used for boot with CONFIG_RUST.\nKDIR and other kernel module descriptions See details \u0026rharu; In my case it\u0026rsquo;s ~/Develop/linux\n# /home/pmnxis/Develop/linux export KDIR=$HOME/Develop/linux Looking in to code\u003e Looking in to code # Let\u0026rsquo;s preview the code rust_out_of_tree.rs \u0026hellip;\nLicense and imports\u003e License and imports # 1 2 3 4 5 6 7 8 9 10 11 12 13 // SPDX-License-Identifier: GPL-2.0 //! Rust out-of-tree sample use kernel::prelude::*; module! { type: RustOutOfTree, name: \u0026#34;rust_out_of_tree\u0026#34;, author: \u0026#34;Rust for Linux Contributors\u0026#34;, description: \u0026#34;Rust out-of-tree sample\u0026#34;, license: \u0026#34;GPL\u0026#34;, } Lines 1~3, show file\u0026rsquo;s license information. If you are write the code in company, SomeCompanyName instead GPL-2.0 or just keep GPL-2.0. 1 2 3 4 5 6 7 8 9 10 11 12 13 // SPDX-License-Identifier: GPL-2.0 //! Rust out-of-tree sample use kernel::prelude::*; module! { type: RustOutOfTree, name: \u0026#34;rust_out_of_tree\u0026#34;, author: \u0026#34;Rust for Linux Contributors\u0026#34;, description: \u0026#34;Rust out-of-tree sample\u0026#34;, license: \u0026#34;GPL\u0026#34;, } Line 5 means, bring rust for linux library for this code.\nIn following example module written in C were include like this.\n2 3 4 #include \u0026lt;linux/module.h\u0026gt; #include \u0026lt;linux/kthread.h\u0026gt; #include \u0026lt;linux/irq_work.h\u0026gt; 1 2 3 4 5 6 7 8 9 10 11 12 13 // SPDX-License-Identifier: GPL-2.0 //! Rust out-of-tree sample use kernel::prelude::*; module! { type: RustOutOfTree, name: \u0026#34;rust_out_of_tree\u0026#34;, author: \u0026#34;Rust for Linux Contributors\u0026#34;, description: \u0026#34;Rust out-of-tree sample\u0026#34;, license: \u0026#34;GPL\u0026#34;, } Line 8, implement of the module trait. Line 9, name of the module, if we written c, it\u0026rsquo;s the name of *.ko name field. Line 10~12, those fields are simillar with below the example written in c. Those fields are same purpose.\n56 57 58 MODULE_AUTHOR(\u0026#34;Steven Rostedt\u0026#34;); MODULE_DESCRIPTION(\u0026#34;trace-printk\u0026#34;); MODULE_LICENSE(\u0026#34;GPL\u0026#34;); We preview macro_rule! module shortly. You can see detail here.\nDetails for module! See details \u0026rharu; Actual implements\u003e Actual implements # 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 struct RustOutOfTree { numbers: Vec\u0026lt;i32\u0026gt;, } impl kernel::Module for RustOutOfTree { fn init(_name: \u0026amp;\u0026#39;static CStr, _module: \u0026amp;\u0026#39;static ThisModule) -\u0026gt; Result\u0026lt;Self\u0026gt; { pr_info!(\u0026#34;Rust out-of-tree sample (init)\\n\u0026#34;); let mut numbers = Vec::new(); numbers.try_push(72)?; numbers.try_push(108)?; numbers.try_push(200)?; Ok(RustOutOfTree { numbers }) } } impl Drop for RustOutOfTree { fn drop(\u0026amp;mut self) { pr_info!(\u0026#34;My numbers are {:?}\\n\u0026#34;, self.numbers); pr_info!(\u0026#34;Rust out-of-tree sample (exit)\\n\u0026#34;); } } I just guess working as \u0026hellip;\nOn init (insmod?), print out somewhere with text Rust out-of-tree sample (init) vec\u0026lt;i32\u0026gt;[72, 108, 200] is stored some kernel memory space with struct RustOutOfTree. When drop the module (rmmod?), will print out with text [72, 108, 200]. By the way, we need to keep on eyes here.\n23 24 let mut numbers = Vec::new(); numbers.try_push(72)?; In line 24, try_push is not exsting in std::Vec. In rust kernel programming, need to use try_push instead std::Vec::push.\nDetails for alloc::vec::Vec See details \u0026rharu; Also there's some `init` and `drop` functions in line 20 and 33. The code covers those function with `impl for` pattern. Details for Implementation in rust See details \u0026rharu; I will explain about implementation and it\u0026rsquo;s philosophy later article.\nRun code\u003e Run code # Build it\u003e Build it # make LLVM=1 My rust acceptable kernel build were buiten with LLVM.\nSo I compile the kernel module with LLVM.\nInstall module\u003e Install module # sudo insmod ./rust_out_of_tree.ko After compile, we can there\u0026rsquo;s rust_out_of_tree.ko inside of project directory.\nWe can install module with insmod that normally used before.\nInspect result\u003e Inspect result # # do `sudo rmmod rust_out_of_tree` if you already install the module` # clear all of dmesg log sudo dmesg -C # install the module sudo insmod ./rust_out_of_tree.ko # see log dmesg # uninstall the module sudo rmmod rust_out_of_tree # check log again. dmesg We can check the inspect actual result with above commands.\nAs we guess it prints with [72, 108, 200].\nConclusion\u003e Conclusion # We can summary from this simple kernel module.\nSummary\u003e Summary # Need to use use kernel::prelude::*; on top of code. module! macro to define some description and board my own struct to the kernel module. kernel::Module templete functions \u0026hellip;. -WIP- In kernel programming, use alloc::vec::Vec instead std::Vec. pr_info is just same as way to write with C. Reference\u003e Reference # https://github.com/Rust-for-Linux/rust-out-of-tree-module https://www.kernel.org/doc/html/latest/kbuild/modules.html https://github.com/Rust-for-Linux/linux https://rust-for-linux.github.io/docs/kernel/prelude/index.html https://rust-for-linux.github.io/docs/kernel/prelude/macro.module.html https://rust-for-linux.github.io/docs/kernel/prelude/struct.Vec.html ","date":"October 2, 2022","permalink":"/posts/look_into_simple_rust_out_of_tree/","section":"Posts","summary":"In October, Rust for linux is under the linux-next, not stable\nThus this article would be out-of-date before Linux 6.1 stable comes.\nmodules, out-of-tree\u003e modules, out-of-tree # There are two main ways to develop kernel modules.","title":"[Rust Driver] Let's try build example rust linux driver."},{"content":"","date":"October 2, 2022","permalink":"/tags/rust-driver/","section":"Tags","summary":"","title":"Rust Driver"},{"content":" In October 1, Rust for linux is under the linux-next, not stable\nThus this article would be out-of-date before Linux 6.1 stable comes.\nThis article play with https://github.com/Rust-for-Linux/linux/tree/for-next/rust\nIntroduction\u003e Introduction # Currently Apple Silicon mac series is only one ARM workstation that have powerful performance as normal desktop class workstation and can purchase anywhere. Of course if you have 32GB or bigger memory and least 8 big cores of apple silicon.\nBtw, this article is in reference to https://github.com/Rust-for-Linux/linux/blob/rust/Documentation/rust/quick-start.rst .\nVM hypervisor software selection.\u003e VM hypervisor software selection. # UTM : Free / OpenSource, QEMU based Sometimes tricky. VM Fusion Tech Preview : Free for now / ClosedSource, Moderate Parallels : Non-Free / ClosedSource, not my taste (sorry). There\u0026rsquo;s some option working with Asahi Linux. But in this article is not consider native asahi linux environment.\nIn my case, I was chosen VM Fusion.\nVirtual Machine Configuration\u003e Virtual Machine Configuration # Debian 11 : https://cdimage.debian.org/debian-cd/current/arm64/iso-dvd/ !! Checked working well.\nUbuntu : There were some issue clang and other gcc build tools version mismatch than broken apt things in aarch64 ubuntu apt repo. But you can try with ubuntu.\nArch Linux : https://gitlab.archlinux.org/tpowa/archboot/-/wikis/Archboot-Homepage#aarch64-architecture I didn\u0026rsquo;t tested yet. But tested with Asahi linux with M1 Mac Mini\nDebian / Ubuntu Package Requirements\u003e Debian / Ubuntu Package Requirements # # Install build-requirements for kernel compile with LLVM. apt install clang git llvm-dev libclang-dev build-essential \\ bc kmod cpio flex libncurses5-dev libelf-dev libssl-dev \\ dwarves bison lld curl Asahi Linux Package Requirements\u003e Asahi Linux Package Requirements # pacman -S base-devel cpio lld llvm llvm-libs bc libdwarf Ready for rust\u003e Ready for rust # Before build kernel, we need to install some packages.\ncurl --proto \u0026#39;=https\u0026#39; --tlsv1.2 -sSf https://sh.rustup.rs | sh rustup default 1.62 rustup component add rust-src # rustfmt and clippy is need for later developing and debugging. rustup component add rustfmt rustup component add clippy Install rust with curl. You can select just default options. Also current rust for linux working with 1.62. Some native compile is working well with recent version (1.64 tested, but cross compile not working).\nClone linux from Rust-For-Linux\u003e Clone linux from Rust-For-Linux # State of current rust-for-linux, they are under 6.0 RC\n# In my case use `Develop` as worksapce, you can replace this word. mkdir -p ~/Develop cd ~/Develop git clone https://github.com/Rust-for-Linux/linux.git -b rust clone like this.\nNecessary some rust scripts in Rust-For-Linux\u003e Necessary some rust scripts in Rust-For-Linux # In cloned linux directory.\ngit clone --recurse-submodules \\ --branch $(scripts/min-tool-version.sh rustc) \\ https://github.com/rust-lang/rust \\ $(rustc --print sysroot)/lib/rustlib/src/rust This work clone rustlib repository in your rust toolchain directory.\ncargo install --locked --version $(scripts/min-tool-version.sh bindgen) bindgen This work need to bind existing c code to rust code. s\nCheck RUST_AVAILABLE\u003e Check RUST_AVAILABLE # cd ~/Develop/linux make LLVM=1 rustavailable $ make LLVM=1 rustavailable *** *** Rust compiler \u0026#39;rustc\u0026#39; is too new. This may or may not work. *** Your version: 1.64.0 *** Expected version: 1.62.0 *** Rust is available! Than if you get result like this it\u0026rsquo;s good to go\nConfigure linux source code with menuconfig\u003e Configure linux source code with menuconfig # make ARCH=arm64 defconfig make menuconfig Disable GCC plugins\u003e Disable GCC plugins # General architecture-dependent options -\u0026gt; GCC plugins For now (6.1 rc*), GCC_PLUGINS config should be disabled for RUST_CONFIG config. Be sure disable it.\nGeneral setup -\u0026gt; Rust support\u003e General setup -\u0026gt; Rust support # In General setup -\u0026gt; Rust support , Enable this If you don\u0026rsquo;t see the flag, double-check that the make LLVM=1 rustavailable process was successful. For a detailed mailing thread on CONFIG_RUST see here. See details \u0026rharu; Kernel hacking -\u0026gt; Sample kernel code\u003e Kernel hacking -\u0026gt; Sample kernel code # For easy to develop rust kernel code we need some examples. You can get them with following menus.\nIn Kernel hacking -\u0026gt; Sample kernel code , enable it (not all of them..) when you interest. I don\u0026rsquo;t recommend you enable them when you write own driver. Because there\u0026rsquo;s some possibility make system slow or make unwanted log in dmesg. In particular, the netflitter example outputs too many dmesg, so it is recommended that you disable it unless you are studying the netfilter example. Kernel hacking -\u0026gt; Rust hacking\u003e Kernel hacking -\u0026gt; Rust hacking # For debug rust kernel code or driver, need to enable some debug options.\nIn Kernel hacking -\u0026gt; Rust hacking , enables it and inside menus.\nCompile and install it in virtual machine.\u003e Compile and install it in virtual machine. # # -j4 for 4 core virtual machine, -j2 for 2 core, -j1 for single core. make LLVM=1 -j4 Build with following command. You need to set number of job considering assigned number of cores for virtual machine. (-j#)\nAlso while you build it, it will ask some flag. I just select default in my case.\nIt takes lot of time (don\u0026rsquo;t worry much better than raspberry pi 4), 13~14 minuites takes in my environment (VM 4core, 8GB)\nAfter than, install via following command\n# should be under the root permision. make modules_install make install update-grub It\u0026rsquo;s done!. Reboot program and then check the kernel working well.\nLinux lambda-next 6.0.0-rc7-175589-g542379556669 #2 SMP PREEMPT Sun Oct 2 19:02:32 KST 2022 aarch64 The programs included with the Debian GNU/Linux system are free software; the exact distribution terms for each program are described in the individual files in /usr/share/doc/*/copyright. Debian GNU/Linux comes with ABSOLUTELY NO WARRANTY, to the extent permitted by applicable law. Last login: Sun Oct 2 18:20:21 2022 from 192.168.99.1 pmnxis@lambda-next:~$ uname -r 6.0.0-rc7-175589-g542379556669 Simple compile speed comparation.\u003e Simple compile speed comparation. # Machine / Environment Compile time M1 Max Virtual Machine (4 core 8GB RAM with aarch64 debian11) 16 minutes M1 Asahi Linux (4P+4E core 16GB RAM MacMini with 6.1.0-rc6-asahi) 11 minutes AMD Ryzen 5950x Native (16 core 32 thread, 64GB with x86_64) 3 minutes AMD Threadripper Pro 5975wx Native (32 core 64 thread, 256GB with x86_64) 2 minutes ","date":"October 1, 2022","permalink":"/posts/rust_for_linux_with_m1/","section":"Posts","summary":"In October 1, Rust for linux is under the linux-next, not stable\nThus this article would be out-of-date before Linux 6.1 stable comes.\nThis article play with https://github.com/Rust-for-Linux/linux/tree/for-next/rust\nIntroduction\u003e Introduction # Currently Apple Silicon mac series is only one ARM workstation that have powerful performance as normal desktop class workstation and can purchase anywhere.","title":"Rust For Linux Development Environment with AppleSilicon MacOS"},{"content":"Introduction\u003e Introduction # ARMv8AëŠ” í”íˆ aarch64ë¡œë„ ë¶ˆë¦¬ë©° í˜„ì¬ ARMv7Aë¥¼ ë’¤ë¡œí•œì±„ ë„ë¦¬ ì‚¬ìš©í•˜ëŠ” ì•„í‚¤í…ì²˜ì¤‘ í•˜ë‚˜ì…ë‹ˆë‹¤. ë³¸ ê¸€ì—ì„œëŠ” ARMv8Aì˜ ë©”ëª¨ë¦¬ ì‹œìŠ¤í…œì„ IPë‹¨ìœ„ë¡œ ë³´ë ¤í•©ë‹ˆë‹¤.\nì‚¬ìš©í•˜ëŠ” ë©”ëª¨ë¦¬ (DDR4 , LPDDR4 , DDR3 , LPDDR3 , DDR2)ë‚˜ ì‚¬ìš©í•˜ëŠ” ì•„í‚¤í…ì²˜(ARM v8.1 or 8.2)ì— ì¡°ê¸ˆì”© ë‹¤ë¥´ë‚˜ ëŒ€ì²´ì ìœ¼ë¡œ ìœ„ ì‚¬ì§„ê³¼ ê°™ì€ í˜•íƒœë¡œ êµ¬ì„±ì´ ë˜ì–´ìˆìŠµë‹ˆë‹¤.\nComponents\u003e Components # CPU\u003e CPU # Instructionì„ ì²˜ë¦¬í•©ë‹ˆë‹¤.\nGIC\u003e GIC # Generic Interrupt Controller; GICëŠ” ê°ì¢… Nestedí•œ Interruptë¥¼ ê´€ë¦¬í•˜ë©°, Interruptë°œìƒì‹œ CPUì—ì„œ ë™ì‘ì¤‘ì´ë˜ PC/Registerë¥¼ ë°±ì—…í•˜ê³  í•´ë‹¹í•˜ëŠ” Inetrrupt Vectorë¥¼ Executioní•˜ë„ë¡ í•©ë‹ˆë‹¤.\nCCI / CCN\u003e CCI / CCN # Cache Coherent Interconnect / Netowrk\nDMC\u003e DMC # DRAMì„ ê´€ë¦¬í•©ë‹ˆë‹¤. DRAMì€ íœ˜ë°œì„± ë©”ëª¨ë¦¬ë¡œì„œ Read/Write ì´ì™¸ì— Refresh, Callibration ì™€ ê°™ì€ ì‘ì—…ì´ í•„ìš”í•©ë‹ˆë‹¤. ì¶”ê°€ì ìœ¼ë¡œ EEC, RASì— ëŒ€í•œ ê´€ë¦¬ë„ ìˆ˜í–‰í•©ë‹ˆë‹¤. Linuxë“œë¼ì´ë²„ì—ì„œëŠ” edac ë””ë ‰í„°ë¦¬ì—ì„œ EEC, RASì— ëŒ€í•œ ê´€ë¦¬ ë“œë¼ì´ë²„ ì½”ë“œë¥¼ í™•ì¸ í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.\nNIC\u003e NIC # ê°ì¢… Peripheral ì„ ì—°ê²°í•˜ëŠ”ë° ì‚¬ìš©í•©ë‹ˆë‹¤.\nMMU\u003e MMU # PA/VA (Physical/Virtual Address) ë³€í™˜ DMA ì»¨íŠ¸ë¡¤ Reference\u003e Reference # CCI-400 ; https://developer.arm.com/Processors/CoreLink%20CCI-400 CCI-500 ; https://developer.arm.com/Processors/CoreLink%20CCI-500 DMC-400 ; DDR3/DDR2 DMC ; https://developer.arm.com/documentation/ddi0466/f/introduction/about-the-dmc-400 DMC-500 ; LPDDR4/LPDDR3 DMC ; https://developer.arm.com/documentation/100131/0000 ","date":"December 14, 2021","permalink":"/posts/arm_v8a_memory_ip_review/","section":"Posts","summary":"Introduction\u003e Introduction # ARMv8AëŠ” í”íˆ aarch64ë¡œë„ ë¶ˆë¦¬ë©° í˜„ì¬ ARMv","title":"ARMv8A Memory IP Review"},{"content":"","date":"December 14, 2021","permalink":"/tags/electronics/","section":"Tags","summary":"","title":"Electronics"},{"content":"","date":"January 1, 1","permalink":"/categories/","section":"Categories","summary":"","title":"Categories"}]