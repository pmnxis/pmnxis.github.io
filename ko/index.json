[{"content":"","date":"2023년 11월 13일","externalUrl":null,"permalink":"/ko/categories/","section":"Categories","summary":"","title":"Categories","type":"categories"},{"content":"","date":"2023년 11월 13일","externalUrl":null,"permalink":"/ko/tags/embedded/","section":"Tags","summary":"","title":"Embedded","type":"tags"},{"content":"","date":"2023년 11월 13일","externalUrl":null,"permalink":"/ko/tags/korean_article/","section":"Tags","summary":"","title":"Korean_Article","type":"tags"},{"content":"","date":"2023년 11월 13일","externalUrl":null,"permalink":"/ko/categories/my-frist-mass-production-with-rust-embedded/","section":"Categories","summary":"","title":"My Frist Mass Production With Rust Embedded","type":"categories"},{"content":"","date":"2023년 11월 13일","externalUrl":null,"permalink":"/ko/posts/","section":"Posts","summary":"","title":"Posts","type":"posts"},{"content":"","date":"2023년 11월 13일","externalUrl":null,"permalink":"/ko/tags/rust/","section":"Tags","summary":"","title":"Rust","type":"tags"},{"content":"","date":"2023년 11월 13일","externalUrl":null,"permalink":"/ko/tags/","section":"Tags","summary":"","title":"Tags","type":"tags"},{"content":" WARN! 아직 작성 중인 글입니다. 중도에 내용이 변경될 수 있습니다. 읽기 앞서서 # 이 글은 이전 글 3 컴파일 타임에 맡기세요 의 연장선이나 const fn/trait/impl 보다는 build.rs 에 초점을 맞추어 설명합니다.\nrust 문법에 대한 이해가 부족하다면 이전 글 2탄 기초 공부 방법 및 특징 에 적힌 #러스트-공부 문단을 읽고 올 것을 권합니다. 이 외에도 김기오 님이 남겨주신 좋은 글평범한 C개발자의 Rust입문기: Rust에 입문하는 C개발자를 위한 안내서또한 추천드립니다.\n빌드 스크립트 (build.rs) # C, C++에는 Makefile이 있듯, rust에는 Cargo가 있다. Cargo는 컴파일 시작 전에 실행할 수 있는 build.rs를 간단하게 쓸 수 있도록 제공하고 있다.\n자세한 build.rs에 대한 설명은 여기서 확인할 수 있다. The Cargo Book - Build Scripts\nbuild.rs는 src 디렉터리에 있는 소스코드 혹은 외부 라이브러리를 컴파일하기 전에 실행이 된다. 그리고 중요한 점은 no_std를 위해 코드를 개발 중이라 하더라도, build.rs는 no_std뿐만 아니라 alloc crate를 비롯한 OS 위에서 사용 가능한 라이브러리를 사용할 수 있다.\n별도의 main.rs에 있는 프로그램은 const 상수 데이터를 컴파일 타임에 만들어야 하지만, 사용해야 하는 함수 및 메서드가 const 형태로 제공하지 않는 경우가 있다.\nbuild.rs 와 env!()로 문자열 가져오기 # build.rs와 env!() 매크로를 사용해 문자열(\u0026amp;str)을 컴파일 타임에 가져오는 실습을 해보고자 한다.\n프로젝트 구조는 이렇게 구성된다. main.rs(혹은 lib.rs)는 src 디렉터리에 없으며, 프로젝트 파일의 루트 디렉터리에 들어간다.\nCargo.toml 예시 # # End of Cargo.toml [build-dependencies] chrono = \u0026#34;0.4.31\u0026#34; 위에서 언급한 것과 같이 build.rs는 기존에 OS 타겟에서 쓸 수 있는 라이브러리를 사용할 수 있다. 쓰고 싶은 crate가 있다면 dependencies 아래에 build-dependencies 리스트에 넣어주자. 아래는 예시를 위한 chrono crate를 넣어주었다.\nbuild.rs 예시 # // build.rs fn main() { let now = chrono::Utc::now().to_rfc3339(); println!(\u0026#34;cargo:rustc-env=GIVEN_BUILD_TIME={}\u0026#34;, now); } build.rs를 Cargo가 컴파일한 뒤 실행하면 chrono 라이브러리를 통해 현재 시간을 UTC로 가져온 다음 String으로 만든다.\n그다음 \u0026ldquo;GIVEN_BUILD_TIME\u0026rdquo; 환경 변수로 prinln! 을 통해서 rustc(컴파일러)에 넘긴다.\nsrc/main.rs 예시 # // src/main.rs const BUILD_TIME: \u0026amp;str = env!(\u0026#34;GIVEN_BUILD_TIME\u0026#34;); fn main() { // if you working with firmware environment, // use defmt::info!(..) instead of println!(..) println!(\u0026#34;passed build time is {}\u0026#34;, BUILD_TIME); // \u0026#34;passed build time is 2023-11-14T06:14:02.366899222+00:00\u0026#34; } src/main.rs에는 const \u0026amp;str로 환경 변수로 존재하는 \u0026ldquo;GIVEN_BUILD_TIME\u0026quot;을 env!(..)라는 내장 매크로를 통해 가져온다.\nenv!(..)의 정확한 모듈 위치는 core::env!(..)이며 core::env!(..)는 컴파일 타임에 환경 변수를 가져온다. 컴파일 타임이 아닌 OS 위에서 돌아가는 타겟 개발에 있어서 런타임 중의 환경 변수나 실행 인자를 알고 싶다면 std::env 모듈에 있는 것들을 사용해야 한다. build.rs를 사용하면서 둘 다 사용하게 될 가능성이 있으니 혼동하지 않도록 주의하자.\nenv!() 매크로에 대한 자세한 설명은 https://doc.rust-lang.org/core/macro.env.html에서 확인할 수 있다.\n고정길이 바이너리 데이터 만들어서 받아오기 # include_bytes를 통해서 받아오기 # core::include_bytes는 컴파일 타임에 프로젝트 디렉터리에 있는 파일을 바이너리 데이터로 가져올 수 있다. https://doc.rust-lang.org/core/macro.include_bytes.html\n더미 바이너리 생성 # echo -n \u0026#34;\\x00\\x01\\x02\\x03\u0026#34; \u0026gt;\u0026gt; ./src/stuff0123.bin 실습에서 사용할 더미 바이너리를 생성해 준다. [0x00, 0x01, 0x02, 0x03]으로 총 4바이트이며 위치는 main.rs가 있는 곳에 넣어준다.\n이 글에서는 터미널상에서 더미 바이너리를 만들어주지만 build.rs에서도 할 수 있다.\nsrc/main.rs 예시 # const DATA0123: \u0026amp;[u8; 4] = include_bytes!(\u0026#34;stuff0123.bin\u0026#34;); fn main() { println!(\u0026#34;binary data is {:?}\u0026#34;, DATA0123); } src/main.rs에는 const \u0026amp;[u8; 4]로 아까 생성한 바이너리를 컴파일 타임에 가져온다. 여기서 주의할 점은 위에서 \u0026amp;str을 가져온 것과는 다르게 [u8; N]과 같이 원자의 개수를 정해줘야 한다.\n원자의 개수를 신경 쓰지 않고 가져오기 위해서는 매크로를 사용해서 써야 한다. 이에 대한 내용은 뒤에서 후술한다\n가변 길이 바이너리 가져오기 # build.rs src/**.rs String const \u0026amp;str Vec\u0026lt;u8\u0026gt; const [u8; N] build.rs에서는 가변 길이 속성을 가지고 있으나 src/**.rs안에서 타겟을 위해서 컴파일 할 때는 proc_macro의 힘을 빌려야 한다. 다만 가변적으로 컴파일할 때마다 데이터의 사이즈가 바뀌는 상황이 철저히 통제되지 않는다면 위험하니 이점은 유의하면서 활용해야 한다.\nproc-macro 사용하여 가변길이 바이너리 받아오기 # 데이터를 tmp에 저장한뒤 include_bytes!와 proc_macro 하는 방법도 있으나 여기서 소개할 방법은 env! 에다가 proc_macro를 같이 사용하는 방법이다.\nproc_macro을 서술하기위해서는 과거에 C언어에서 ##을 사용해 문장을 붙여서 코드를 만들거나 컴파일러 종속 기능을 통해서 흑마법을 부리던것을 토큰과 파서의 개념을 가져와 어느정도 안정적으로 메타프로그래밍할 수 있는 매크로 시스템이다.\n한국어로는 절차형 매크로라고 부르며 proc_macro, 절차형 매크로를 잘 활용한다면 뛰어난 메타프로그래밍을 할 수 있다. 여기에 대해서는 차후 다른 글에서 서술하도록 하겠다.\nproc_macro의 자세한 공식 설명은 Procedural Macros 에서 확인할 수 있습니다.\n전반적인 흐름 # stateDiagram-v2 state \"Total flow\" as total_flow state \"data prepare\" as data_prepare state \"hex::encode(..)\" as hex_encode state \"hex encoded\" as hex_encoded state \"passing to env\" as passing_to state \"passing from env\" as passing_from state \"proc_macro\" as proc_macro state \"decoding at build time\" as decoding state \"decoded data\" as decoded_data state \"code generation\" as code_generation state \"src/**.rs\" as src_rs state \"const NAME: [u8; N] = [...]\" as const_u8_n state total_flow { [*] --\u003e build.rs state build.rs { [*] --\u003e data_prepare data_prepare --\u003e hex_encode hex_encode --\u003e hex_encoded hex_encoded --\u003e passing_to } -- state src_rs { passing_from --\u003e proc_macro state proc_macro { [*] --\u003e decoding decoding --\u003e decoded_data decoded_data --\u003e code_generation } proc_macro --\u003e const_u8_n } } 전반적인 흐름은 아래와 같다.\nbuild.rs 에서 넣어줄 데이터를 만든다. hex로 encoding한 뒤 환경변수로 만들어서 rustc에게 건네준다. src/**.rs 에서 환경변수를 받은뒤 proc_macro로 만든 함수로 보낸다. 매크로 함수에서 컴파일 타임에 디코딩을 하여 원본 데이터를 어레이로 만든다. 만든 배열로 지시된 이름으로 const 상수 데이터를 배열의 길이와 함께 코드생성 해준다. 컴파일 타임에 디코딩을 하기위한 proc_macro 코드 # 위에서 설명한 절차 4, 5번을 행하기 위해서 아래와 같은 코드가 필요하다.\nfn slice_to_auto_sized ( arr_name: String, input: \u0026amp;[u8], ) -\u0026gt; TokenStream { format!( \u0026#34;const {}: [u8; {}] = [{}];\u0026#34;, arr_name, input.len(), input.iter().join(\u0026#34;, \u0026#34;) ) .parse::\u0026lt;proc_macro2::TokenStream\u0026gt;() .expect(\u0026#34;Failed to parse array\u0026#34;) .into() } struct NameAndEnvInput { arr_name: syn::LitStr, _comma0: Token![,], env_var: syn::LitStr, } impl Parse for NameAndEnvInput { fn parse(input: syn::parse::ParseStream) -\u0026gt; syn::Result\u0026lt;Self\u0026gt; { Ok(Self { arr_name: input.parse()?, _comma0: input.parse()?, env_var: input.parse()?, }) } } #[proc_macro] pub fn c(inputs: TokenStream) -\u0026gt; TokenStream { let inputs = parse_macro_input!(inputs as NameAndEnvInput); slice_to_auto_sized( inputs.link_section_name.value(), inputs.arr_name.value(), hex::decode(std::env::var(inputs.env_var.value()).expect(\u0026#34;This env not found\u0026#34;)) .expect(\u0026#34;Can\u0026#39;t decode hex\u0026#34;) .as_slice(), ) } 예시로 main.rs에 slice_to_auto_sized!(SOME_DATA, GIVEN_ENV); 와 같은 코드가 선언되어있다고 가정하자\nconst_from_hex_env에서는 NameAndEnvInput의 구조체 구조에 맞게 \u0026ldquo;SOME_DATA\u0026quot;와 콤마(,) 그리고 \u0026ldquo;GIVEN_ENV\u0026rdquo; 총 3개의 토큰을 가져온다. 이 토큰을 가장 위에있는 slice_to_auto_sized에서 가져온뒤, 만들 코드를 생성해주는 방식이다.\n위 코드는 fork된 env-to-array 커밋 에서 확인할 수 있습니다. 해당 코드에서는 linker쪽에 더미 섹션을 만들기위해서 개조되어 있어 살짝 다릅니다. 해당 코드는 env-to-array crate코드를 살짝 수정한 포크입니다. hex encode를 위한 데이터 생성 예시 # fn main { // https://github.com/pmnxis/billmock-mptool/blob/master/otp-proof-of-concept/build.rs // 중략 let fingerprint = MpFingerprint { firmware_fingerprint: FirmwareFingerprint { model_name: main_package.name.clone(), // reference package name temporary model_ver: feature_based_model_ver, firmware_ver: main_package.version.to_string(), firmware_git_hash: format!(\u0026#34;{}\u0026#34;, commit_hash), }, }; // cargo objdump --release -- -s --section .mp_fingerprint println!( \u0026#34;cargo:rustc-env=MP_FINGERPRINT_TOML_HEX={}\u0026#34;, fingerprint.to_hex_string(), ); } hex스타일로 encoding할때는 hex를 사용해 \u0026ldquo;hex::encode()\u0026rdquo; 로 인코딩할 수 있습니다.\n위 코드에서는 toml로 현재 패키지의 정보와 git hash를 만든뒤 hex로 인코딩해주고 있습니다.\n실제 응용 # 응용 - EUC-KR 문자열을 컴파일 시간 내에 가져오기 # use encoding_rs::EUC_KR; fn main() { // encoding_rs::Encoding::encode(..) is not const fn let ret: \u0026amp;[u8] = EUC_KR.encode(\u0026#34;안녕하세요\u0026#34;).0.to_vec().as_slice(); } billmock-app-rs를 개발하면서 NDA 쪽 금융사 전문 통신 라이브러리를 만들 때, 몇 가지 문제점이 있었다. EUC-KR의 문자열들을 const로 갖고 있어야 했다. 하지만 EUC-KR 문자열 인코딩 라이브러리 encoding-rs는 const 한 함수를 제공해 주지 않는다.\nEUC-KR도 결국 문자열 인코딩이기에, 문장만 사전에 정해진다는 가정하에 컴파일 타임 안에 만들 수 있는 바이너리 데이터이다.\n위에서 소개한 기법들을 조합하여 금융사 전문 통신 라이브러리에서 EUC-KR을 컴파일 타임에 const [u8; N]으로 변환해 주는 코드를 작성하였다.\n응용 - dummy ELF header # 펌웨어 개발을 하면서 MP Tool (Mass Production Tool)을 만들어 펌웨어를 대량으로 넣을 때에 실수 방지 및 하드웨어에 대한 버전 기록을 위해 ELF에 더미 헤더를 넣었다. 이때 ELF 더미 헤더는 실제로 flash에 적재되지 않는 데이터로서 가변 길이를 사용해도 아무런 문제가 없었다.\n전반적인 구조는 위에서 서술한 \u0026ldquo;proc-macro 사용하여 가변 길이 바이너리 받아오기\u0026rdquo; 내용과 비슷하다.\n관련된 커밋은 아래와 같다.\nhttps://github.com/pmnxis/billmock-app-rs/pull/42/files https://github.com/pmnxis/env-to-array/commit/782c2b265d8a23653321d163ac5cea96c04bc85d 마치며 # 이 글은 이전 글 3 컴파일 타임에 맡기세요 의 연장선이나 const fn/trait/impl 보다는 build.rs 에 초점을 맞추어 설명을 하였다. build.rs를 통해 고정길이, 가변길이를 다루는 법과 실제 사용 예시를 나열했다.\n도중에 proc_macro (절차형 매크로) 에 대해서 설명하기에는 내용이 너무 길어지기에 다음 기회에 서술할 예정이다.\n","date":"2023년 11월 13일","externalUrl":null,"permalink":"/ko/posts/my_first_commerical_rust_embedded_product_4/","section":"Posts","summary":" WARN! 아직 작성 중인 글입니다. 중도에 내용이 변경될 수 있습니다. ","title":"러스트 임베디드 양산 제품 개발기 - 4 빌드 스크립트 활용","type":"posts"},{"content":" 전자기술 전문가인 내 고양이 Lambdaλ 소개합니다. 이 블로그는 주로 Linux, Rust, Embedded, 전자 회로를 다루며, 한국어와 영어 글이 섞여 있습니다. 때때로 내 고양이 Lambdaλ가 자주 등장하니 좋아해 주시면 감사하겠습니다. 냐 ","date":"2023년 11월 13일","externalUrl":null,"permalink":"/ko/","section":"박진우 블로그","summary":" 전자기술 전문가인 내 고양이 Lambdaλ 소개합니다. ","title":"박진우 블로그","type":"page"},{"content":"","date":"2023년 11월 13일","externalUrl":null,"permalink":"/ko/tags/%ED%9A%8C%EA%B3%A0%EB%A1%9D/","section":"Tags","summary":"","title":"회고록","type":"tags"},{"content":" WARN! 아직 작성 중인 글입니다. 중도에 내용이 변경될 수 있습니다. 서론 # 이 글을 읽기 전에 rust 문법에 대한 이해가 부족하다면 이전 글 2탄 기초 공부 방법 및 특징 에 적힌 #러스트-공부 문단을 읽고 올 것을 권합니다. 이 외에도 김기오 님이 남겨주신 좋은 글평범한 C개발자의 Rust입문기: Rust에 입문하는 C개발자를 위한 안내서또한 추천드립니다.\n컴파일 타임에 맡기세요 # 일반적인 함수는 컴파일 내에 결과가 예측이 되면 상수 (불변의 값)을 그대로 사용한다.\n하지만 불변의 값으로 저장하는 것이 비효율적이라고 판단될 시 함수 형태로 instruction 상에 남아있다.\n임베디드, 특히 저가의 MCU위에서 동작하는 펌웨어의 경우 램의 용량은 매우 작다. (필자가 사용한 MCU STM32G030C8 은 8KiB이다.).\n최대한 컴파일 시간에 복잡한 연산도 상수의 성격을 띠는 데이터로 남긴 뒤 Flash 영역 (.text 혹은 .rodata) 에 적재시키기 위해서 일반적인 러스트 프로그래밍을 가끔씩 벗어나 이를 고려하여 코드를 작성했다.\nconst fn # const fn은 일반 fn과는 다르게 컴파일 타임에 상수 성격을 띠는 데이터를 가져오는 것을 보장한다.\nconst fn const_add(a: i32, b: i32) -\u0026gt; i32 { a + b } const fn const_add_round_up(a: i32, b: i32) -\u0026gt; i32 { let added = const_add(a, b); // 안에 있는 함수는 무조건 const 형태여야 한다. (added / 10) * 10 } 하지만 그만큼 제약도 많다. const fn 스코프 안에 있는 함수는 const fn로 구성되어 있어야 하며, 다른 연산자들 또한 컴파일 타임 내에 연산이 가능한 형태여야만 한다.\n반대로 일반적인 fn 혹은 async fn 스코프 안에서는 const fn을 사용할 수 있다.\nconst impl # 일반적인 함수를 const 형태로 만드는 것은 간단하지만 구조체 struct를 위한 함수로 만드는 순간 어려운 문제들에 봉착하게 된다. 이 부분은 후술하게 될 const trait 에서 다루게 된다.\n우선은 가장 간단한 특정 구조체 struct의 default에 대해서 다뤄보도록 하겠습니다.\npub enum Player { Undefined = 0, Player1 = 1, Player2 = 2, } impl Player { pub const fn default() -\u0026gt; Self { Self::Undefined } } 결과적으로 코드는 매우 간단하지만 이와 같이 사용함으로서 default() 를 호출하는 쪽에서는 컴파일 타임 내에 상수를 얻을 수 있다. 더 복잡한 것을 원하는 경우에는 복잡한 값을 넣어주면된다. 위에서도 언급한것과 인자가 유동적이지 않는 한 함수 형태로 남지않기에 분기문, 스택에서 왔다 갔다 하는 과정, 그 와중에 레지스터를 백업하고 롤백 하는 과정의 생략을 보장받을 수 있다.\nconst trait # 이제 대망의 const trait 이며 글을 작성한 시점(2023년 11월)에선 nightly feature이다. 여기서 부터는 왜 러스트가 const fn / impl / trait 이 아직까지 논의중인 RFC인지 동시에 서술한다.\n이미 존재하는 trait과의 충돌 # 위에서 언급한 pub const fn default()에서 이상한 점을 찾았는가?\n그것은 바로 Default trait이 이미 따로 있다는 것이다.\n하지만 Default trait 의 정의는 const 형태가 아니다.\n불특정 다수의 구조체 struct가 core::default::Default trait의 impl가 딱 봐도 너무 간단한 경우가 많다. 하지만 눈대중으로 판단하기에 아무리 간단하더라도 이 경우엔 const fn 안에서는 사용할 수 없다.\nInto/From의 경우 # 아직까지는 const 특성을 이용해 Default trait을 통한 추상화를 할 일은 거의 없었지만 외외로 into, from 가 문제였다.\n현재로서는 core::default::From 의 Trait정의를 const trait에 맞게 ConstInto, ConstFrom으로 수정하여 사용하면 아래와 같이 사용할 수 있다.\nProduct에 사용한 ConstConvert 정의 const 형태를 띄는 Into/From 의 사용 예시\npub struct UnpackedQuad4Bits { pub b0: u8, pub b1: u8, pub b2: u8, pub b3: u8, } #[derive(PartialEq)] pub struct PackedQuad4Bits { inner: u16, } impl const ConstFrom\u0026lt;UnpackedQuad4Bits\u0026gt; for PackedQuad4Bits { fn const_from(value: UnpackedQuad4Bits) -\u0026gt; Self { PackedQuad4Bits { inner: ((value.b0 as u16 \u0026amp; 0xF) \u0026lt;\u0026lt; 12) | ((value.b1 as u16 \u0026amp; 0xF) \u0026lt;\u0026lt; 8) | ((value.b2 as u16 \u0026amp; 0xF) \u0026lt;\u0026lt; 4) | (value.b3 as u16 \u0026amp; 0xF), } } } #[test] fn test() { assert_eq!( PackedQuad4Bits::const_from(UnpackedQuad4Bits { b0: 0x0, b1: 0x1, b2: 0x2, b3: 0x3 }), PackedQuad4Bits { inner: 0x0123 } ); } ConstInto / ConstFrom과 const 형태로 만들어서 사용하면 기존의 Into/From으로 .into() 형태로 곧바로 사용할 수 없으며 또다시 Into/From trait 정의에서 앞의 const 메서드를 호출해야 하지만 컴파일 타임 안에 into를 정의할 수 있다.\nnightly feature인 const trait # 아직까지 const trait은 nigtly feature이다. 개인적인 감상으로는 niglty compiler의 버전을 조금씩 바꿀 때마다 플래그 변경을 해줘야만 그대로 쓸 수 있었다. 하지만 그럼에도 불구하고 경우에 따라서는 매우 필요한 기능이다.(물론 안 쓰고 const fn 만 써서 할 수 있다.)\nconst trait을 정의하는 경우에는 #[const_trait]을 trait 정의 앞에 붙여줘야하며 lib.rs 혹은 main.rs에 #![feature(const_trait_impl)] 를 선언해줘야한다.\ntodo! const trait 에 대한 논의 역사 서술 Tracking issue for RFC 2632, impl const Trait for Ty and ~const (tilde const) syntax 이 시리즈의 다른 글도 같이 봐주세요 : 러스트 임베디드 양산 제품 개발기 ","date":"2023년 11월 12일","externalUrl":null,"permalink":"/ko/posts/my_first_commerical_rust_embedded_product_3/","section":"Posts","summary":" WARN! 아직 작성 중인 글입니다. 중도에 내용이 변경될 수 있습니다. ","title":"러스트 임베디드 양산 제품 개발기 - 3 컴파일 타임에 맡기세요","type":"posts"},{"content":" WARN! 아직 작성 중인 글입니다. 중도에 내용이 변경될 수 있습니다. RIIR BEAM\n서론 # 저번 글에 이어서 러스트를 임베디드에 적용했을 때 얻었던 장단점과 러스트 임베디드의 공부 방법 대해서 간단히 다루려고 한다.\n러스트를 임베디드에 쓰고 나서 느낀 점 # C언어와 러스트 사이에는 38년의 간격이 존재한다. # 이미지 출처 : History Of Programming Languages\nC언어는 1972년 발표됐으며, 러스트는 2010년에 발표되었다. 이 사이에는 최소 38년의 간격이 있으며 그 사이에 많은 언어들과 개념들, 변화들이 있었다.\nC언어는 구조체 struct가 있긴 하나 절차 지향이며 일단은 강타입 언어입니다. 러스트는 C++ 하고는 다른 상속 없는 객체지향을 갖고 있는 강타입 언어임과 동시에 C와 C++를 이어서 시스템 프로그래밍을 고려한 언어입니다.\n개인적인 해석에 있어서 C언어가 강타입이긴 하지만 CPU 레지스터에 강하게 바인드 되는 언어라고 생각합니다. 그에 비해 러스트는 C언어보다는 덜 CPU 레지스터에 종속되지만 그래도 경우에 따라 CPU 레지스터를 의식하고 프로그래밍할 수 있으며 \u0026ldquo;객체\u0026quot;의 개념에 있어서 강타입 속성을 갖고 있다고 생각합니다.\nC언어는 오래동안 유지되어 왔으며, 임베디드만 한다고 하면 C언어는 매우 유창하게 구사할 수 있으나 현대 언어인 러스트를 적응할 때에 많은 문제가 있을 수 있습니다. 가장 큰 문제가 \u0026ldquo;객체\u0026rdquo; 와 \u0026ldquo;메서드\u0026quot;설계하는 것일 겁니다. 절차 지향만 여태 해왔다 한다면 최소 몇 개월은 이 문제로 많은 어려움이 있을 수 있습니다.\n이 외에도 nullable 을 명확하게 구분하려는 철학, 소유권 등의 생각보다 기존의 생각의 틀에서 깨야 할 것들이 많습니다. 이걸 이해하고 특히 로우 레벨 제어에서 가끔 이것들을 깨고 프로그래밍하거나 (unsafe) 프로그램 용량을 고려해서 튜닝을 하는 과정에 있어서 CS 지식? 과 철학을 많이 얻을 수 있다고 생각하며 이것이 가장 값지다고 생각합니다.\n임베디드(펌웨어) 프로젝트에 적용 시 장점 # 언어 스펙상으로 내장된 Test 덕에, 부분적으로 Unit Test를 짜기 용이하다. 로직 생으로 문제없고 Unit Test가 거들어준다면 Integration Test를 매우 적게 하고 버그를 잡을 수 있었다. 썼던 코드 어느 정도 그대로 백엔드 서버에 적용할 수 있었다. clippy, fomatter가 기본으로 내장되어 불필요한 코드나 코드 컨벤션을 통일하기 좋다. (상속 없는) 객체지향 덕에 코드 재활용이 유용하다. Cargo 생태계 덕에 라이브러리를 추가하기 정말 편하다. 툴체인 설정도 매우 간단하다. 펌웨어에서 epoll 이 아닌 async / await를 사용할 수 있다. 절차형 매크로를 사용할 수 있다. C로 짠 것보다는 안전하며 개발 과정 중에 실수를 많이 줄일 수 있다. 임베디드(펌웨어) 프로젝트에 적용 시 단점 # 아직 참고할 프로젝트가 많이 없다. 8비트 프로세서는 아무래도 적용하기 힘들다. Queue나 array에 데이터를 넣을 때는 아무래도 사이즈를 최대한 줄이기 위해 enum, option, struct 등을 더 작게 만든 별도의 타입을 지정하게 된다. 이때 Into/From을 만드는 것이 조금 번거롭다. nightly feature을 어느 정도는 고려를 해야 한다. Ghidra/objdump로 컴파일 된 바이너리를 볼 때 기존의 C 코드와 결이 은근히 많이 다르다. (어셈블리 단위 정적 분석하기 아직까진 힘들다. 이건 단점이기보다는 특징이다.) 객체지향에 대한 경험이 없다면, 절차 지향적인 러스트 코드를 만들 수 있다. 이렇게 단점이 많은데 써야 하나요? # 결국에는 각 개인, 조직의 선택이긴 하나, 저는 썼으면 좋겠습니다.\n그 이유는 백날 C언어만 고집할 수는 없다고 생각하며 아무리 제조업/로우 레벨의 특수성이 존재한다고는 하나, 임베디드 개발 자라고서 개발자의 범주에서 벗어나는 것은 아닙니다. 현재 전체적인 범주에서의 개발자들이 사용하는 언어는 많이 발전해 왔고 계속 변경되고 있습니다. 제조업/로우 레벨 쪽이라고 해서 이 현대의 흐름을 벗어날 수 없으며, 계속 피한다면 이쪽 업계로 사람이 언젠가는 끊길 것이라고 생각합니다.\n물론 C언어를 완전히 버릴 수는 없습니다. 하지만 많은 C언어 개발자들이 리눅스 커널 코어 코드처럼 매우 견고하고 매우 빠른 코드를 짤 수 있는 것은 아니니까요.\n러스트 공부 # 글 선택 # 가능하면 러스트를 처음 접하는 사람들을 위하여 C언어 개발자 입장에서 알아두면 좋은 러스트 문법을 소개하고 싶으나 이미 김기오 님께서 좋은 글평범한 C 개발자의 Rust 입문기: Rust에 입문하는 C 개발자를 위한 안내서을 남겨주셔서 인용을 남겨두고자 한다.\n이 외에도 아래에 있는 설명들이 러스트의 문법들을 잘 설명하고 있다.\nThe Rust Programming Language 한국어 번역 Comprehensive Rust 한국어 평범한 C 개발자의 Rust 입문기: Rust에 입문하는 C 개발자를 위한 안내서 공부 방식 # 러스트 임베디드를 목표로 공부를 한다고 하면, 곧바로 MCU나 리눅스 드라이버를 개발을 하는 것은 별로 좋은 선택지는 아니다. 우선 임베디드라고 하면 대략적으로 3가지 방향성이 있다.\n\u0026ldquo;MCU에서 돌아가는 펌웨어 개발\u0026rdquo; \u0026ldquo;커널 개발 혹은 커널 드라이버 개발\u0026rdquo; \u0026ldquo;FPGA 개발\u0026rdquo; 여기서 다루는 것은 1번 \u0026ldquo;MCU에서 돌아가는 펌웨어 개발\u0026quot;이며, 2번에 대해서는 차후 개인 공부와 실무에서 해본 다음에 따로 서술할 예정이다. 하지만 엄밀히 말하면 서로의 지식이 도움이 되는 도메인이긴 하나 전혀 다른 도메인이다. 특히 3번은 더더욱 다른 도메인이다.\n(러스트로 FPGA에 적용하는 사례가 있어서 넣긴 했으나 HDL 류를 잘 몰라서 앞으로 언급은 하지 않는다.)\n1번과 2번의 목표를 잡고 했을 때 도메인 외에 러스트 언어만 한정 지어서 공부해야 할 것이라고 하면 언어 자체를 일단 공부해야 한다.\n우선은 위에 언급한 좋은 자료들을 보고 OS 위에서 돌아가는 토이 프로젝트를 먼저 잰 행 해보기를 권장한다.\n언어는 도구에 불구하기에 곧바로 알고 있던 도메인에 적용하려는 시도가 있으나 장기적으로 본다면 별로 좋은 선택지는 아니라고 생각한다. 이렇게 생각하는 이유에 대해서는 다른 섹션에서 다루도록 하겠습니다.\nno_std를 의식할 것 # no_std는 땜쟁이에게 러프하게 비유하자면 non-eabi 같은 것이다. 풀어서 설명하자면 OS에서 제공하는 표준 API 없이 돌아가는 환경을 말한다. 이 경우에 heap 혹은 dynamic allocation과 같은 부분에 있어서 많은 제약을 가지며 표준 입출력이 없기에 OS 위에서 개발하던 때와 달리 하드웨어적인 부분을 고려하여 개발을 할 수밖에 없다.\nno_std는 rustc (컴파일러)한테는 예약어이며, cargo (패키지 매니저)에서는 암묵적인 예약어이다. 라이브러리의 lib.rs 초입부에 #![no_std]라고 표기가 되어있다면 이 라이브러리는 no_std환경에서 사용할 수 있다.\n이 외에도 crates.io에 올려서 no_std라는 것을 홍보하기 위해서 Cargo.toml에 no_std를 표기해두는 경우도 있다.\nA no_std Rust Environment 앞으로 러스트 임베디드 위에서 개발하게 된다면 1번 2번의 경우 둘 다 no_std 라이브러리를 작성하거나 가져와서 쓰는 경우가 많아진다. 왜냐면 우리가 삼는 타깃은 운영체제의 지원에 대해서 매우 제약적이기 때문이다.\n코어 라이브러리를 사용할 때 std대신 core사용 # use core::borrow::BorrowMut; use core::cell::UnsafeCell; use core::marker::PhantomData; 우선 당장 신경 쓸 수 있는 부분은 코드를 작성할 때 std에서 가져오지 말고 최대한 core에서 가져오도록 한다. std에는 core에 있는 것들을 re-export 하고 있기에 core에 있는 것들로 구성해도 된다.\nhttps://doc.rust-lang.org/src/std/lib.rs.html#431-459 처음에는 최대한 unsafe를 쓰지 말자 # 러스트로 임베디드를 작성하면서 결국에는 최적화를 위해 unsafe를 사용했지만 unsafe는 사용이 힘들고 C로서 이해하고 있던 프로그래밍 모델, 컴퓨터 구조를 러스트의 철학? 을 답습하며 이해해야 하는 과정이 들어간다. 그리고 가장 큰 문제는 물어볼 수 있는 사람이 줄어든다.\n우선은 러스트라는 언어에 대해서 어느 정도 익숙해진 다음 다루는 것을 권장한다.\n혹시라도 써야 한다면 아래의 문서가 매우 상세하게 서술되어 있다.\nThe Rustonomicon 이 시리즈의 다른 글도 같이 봐주세요 : 러스트 임베디드 양산 제품 개발기 ","date":"2023년 11월 4일","externalUrl":null,"permalink":"/ko/posts/my_first_commerical_rust_embedded_product_2/","section":"Posts","summary":" WARN! 아직 작성 중인 글입니다. 중도에 내용이 변경될 수 있습니다. RIIR BEAM\n","title":"러스트 임베디드 양산 제품 개발기 - 2 기초 공부 방법 및 특징","type":"posts"},{"content":"아직 작성 중인 글입니다. 중도에 내용이 변경 될 수 있습니다.\n최근에 현장에 내보낸 테스트용 기기\n서론 # C를 대체할 언어로서, 러스트는 주목을 받는 언어이며, 현재는 백엔드 개발을 하고있지만 과거 펌웨어에 빠져살던 나의 기준으로서, 예나 지금이나 프로그래밍 언어는 HDL언어가 아니라면 \u0026ldquo;500원 짜리 MCU에서 돌아가야한다\u0026rdquo; 라는 생각을 갖고있다.\n이런 관점에서는 현재 뜨고 있는 zig 외에는 러스트만이 C를 대체할 언어라고 생각한다. 하지만 이 주장에는 내가 러스트로 펌웨어를 양산레벨로 개발해본적이 없다 라는 결점이 존재한다. 이러한 문제점을 인지하고 몇번이나 시도를 2-3년 정도 하다가, 드디어 2023년 7월 부터 시작한 상용 러스트 임베디드 프로젝트가 제품 초기 양산 페이즈를 밟게되었다.\n내가 경험한 러스트 임베디드 그리고 장점과 기법등을 여러 글에 나눠서 다루고자 한다. 이 글에서는 사용한 개발 프레임워크, 프로젝트를 위해 개발 한 것들, 간단히 느낀 것에 대해 소개하고자 한다.\n개인적인 욕심으로 이번 경험을 통해 러스트 임베디드 에 관한 책을 싶으나 독자층을 3가지 분류에서 정하지를 못해, 책을 위해 독자층을 마음속에서 정하기전까지는 생각 나는대로 정리하는 형태로 예상하고 있다.\n\u0026ldquo;이미 러스트를 경험한 개발자\u0026rdquo; \u0026ldquo;취미로 아두이노를 하는 임베디드가 주업무가 아닌 개발자\u0026rdquo; \u0026ldquo;이미 임베디드 개발자\u0026rdquo; 번거럽게 이걸 설명하는 이유는, 러스트를 쓰는 임베디드 개발자가 너무 적기 때문에 대다수는 러스트에 관심이 있는 개발자의 범주에서 당장은 쓸 것이며 미지의 러스트 와 임베디드 둘 다 동시에 설명하기에는 너무나도 불친절하기 때문에 글의 서술이 느리더라도 임베디드 의 개발과정의 면을 조금 바라볼 수 있도록 서술 하는 과정을 걸치려고한다.\n제품 기획 # 2023년이 되서야 카드단말기를 달게 됬는가 라는 질문에는 오락실 산업 자체의 역사를 봐야한다. 2007년 경 바다이야기 이슈로 2020년까지 카드단말기와 같은 것을 달수 없다가 2020년부터 달 수 있게됬으나 이 경우에는 카드단말기를 다는 경우 게임 자체의 심의를 다시 받아야만 했다 하지만 이에 관해서 법이 최근에 와 허들이 낮아지게 되었고 최근에 와 나에게 카드단말기를 달수 있게 해주는 모듈의 개발 의뢰가 들어왔다.\n게임위, 내달 1일부터 아케이드 게임 결제 방식 다양화하기로 결정 - 2019-06-28 전체이용가 아케이드 게임물 결제방식 변경 관련 - 2022-03-21 지폐입력기의 예시\n카드 단말기는 RS232 시리얼 통신을 사용하고 있으며, 기존 게임기는 molex 2.00mm 간격의 10핀 커넥터를 지폐입력기 용으로 사용하며 혹은 2~4핀의 커넥터를 동전입력기 용으로 사용한다. 특수한 기능을 쓰지않으면 10핀을 쓰는 지폐입력기와 동전입력기의 신호체계는 호환이 되며 과거와 달리 물가가 많이 오른 시점에서 500원, 100원 주화보다는 1000원 지폐를 지불방식으로 많이 사용하고 있기에 지폐입력기의 배선을 좀 더 우선하기로 했다.\n기존 게임기에 카드단말기를 추가하기 위해서는 기존 화폐 지불 신호선을 공유하여 사용하여 지폐입력기 (혹은 동전입력기) 대신 신호를 만들어 주는 수 밖에 없다. 이 때 단순히 기존 배선에 그대로 신호를 주게되면 지폐입력기의 신호와 카드단말기에서 나온 신호가 중첩되게 된다. 따라서 각 신호의 출력쪽에 대해 FIFO Queue를 적용하여 지폐입력과 카드단말기 입력이 중첩되도 순차처리 할 수 있도록 구성하고 하드웨어도 이를 고려하여 구성하였다.\n하드웨어 개발 # STM32G030C8Tx 칩선정 # STM32G030C8Tx 은 ST 사의 Cortex-M0 (ARM cortex-Mv6) MCU이다. MCU는 32비트 CPU를 내장하고 임베디드를 위한 주변장치를 탑재하는 물건을 말한다. 이 제품은 64KBytes의 프로그램을 담을 수 있는 Flash와 8KB SRAM(컴퓨터의 RAM과 비슷) 이 있으며 16Mhz로 동작한다. 절반의 용량인 32KBytes 을 갖고있는 제품도 있지만 회사에서 간단한 제품을 개발할때 32Kbyte는 rust에서 debug build를 올리기엔 무리가 있었다라는 경험과 비교적 기능이나 비즈니스 로직이 커질 것 같다라는 예상이 있어 확 늘리진 않고 64Kbyte로 정했다. 그리고 전반적으로 최소한의 컴퓨팅 리소스를 갖고있는 저렴한 MCU에서 러스트 임베디드 제품을 만들수 있어야 러스트로 임베디드를 양산, 업무용으로 쓸수 있다라는것을 증명 할 수 있다 라는 생각도 기반했다. (Go, Python, Javascript로도 임베디드에 돌아가는 코드를 만들수는 있다고한다 하지만 양산용으로 쓸수있는 단가가 매우 낮은 환경에선 많이 힘들다고 생각하고 비싼 칩에서만 돌아가면 의미 없다고 생각한다.)\nPCB (회로) 개발 # 왼쪽의 Gerber 데이터는 공개를 하지않지만 schematic (회로도) 는 공개를 하고있다. BillMock-HW-RELEASE\n회로 개발에는 KiCad 를 사용하였다. KiCad 는 CERN이 공개한 오픈소스 EDA 캐드 프로그램이다. 보편적으로 사용하는 OS, Linux, macOS, Windows 를 전부 지원하며 5.x 버젼부터 써왔으며 현재 6.x를 거쳐 7.x에서는 꽤 쓸만하져 이번 프로젝트에도 적용했다.\nPCB (회로) 개발은 대략적으로 schematic개발과 gerber artwork으로 나뉜다. schematic은 오른쪽 이미지와 같이 회로를 어떻게 구성할지에 대한 도식표로 나타낸 형태이다. gerber artwork은 왼쪽 이미지와 같이, 실제로 어떻게 구리배선과 부품들을 인쇄/실장 할 것인지 나타내는 형태이다. 회로상에서 요구되는 커넥터의 위치, 배선에 흐르는 통신의 속도나 전기적인 신호의 크기, 전원 요구사항 등에 따라 가까이 배치하거나 멀리배치, 그리고 두껍거나 비교적 얇게 배선을 라우팅한다.\n프로그램도 최적화를 하듯이 회로도 최적화가 필요하며 적거나 적은 종류의 부품, 적당히 값싼 부품, 전체적인 사이즈 감소나 사양 을 낮추면서 단가를 줄이되 기획상 하드웨어의 기능과 안정성은 어느정도 들고가는 것이 중요하다.\n프로토 타입 생산 # 프로토 타입은 JLCPCB를 이용하였다. 회사에서 진행하는 프로젝트라고 한다면 국내 턴키 업체에 맞기는 게 정석적인 선택이나, 이미 JLCPCB의 SMT(부품 조립) 서비스를 여러 번 써본 입장에서는 오히려 적응을 따로 할 필요도 없고 JLCPCB에서 소량에 대해 매우 저렴하게 결과물이 잘 나온다면, 나중에 다른 업체에서 양산을 한다고 해도 웬만해서 될 거라는 믿음이 있었다. (소량 샘플은 JLCPCB가 이례적으로 저렴하다.)\n백엔드 서버 개발자의 입장에서 비유를 한다면, \u0026ldquo;10년된 학교 동아리 서버에서 돌아가니, 최종 릴리즈때 IDC에서 잘 돌아가지 않을까\u0026rdquo; 라는 생각과 비슷하지 않을까 생각한다.\n최종 양산 # BOM정리 및 부품 구매 # 소프트웨어와 다르게 하드웨어에 가까워지면, BOM이라는 단어를 많이 듣게 된다. Bill Of Matterial 은 말 그대로 부품 리스트이며 가격이나 이것저것 정보를 필연적으로 포함하게 된다. 여기서 가격이 너무 비싸면 설계단으로 되돌아와 크게 설계를 바꾸거나 설계 변경 없이 변경 가능한 부품이 있으면 대체 부품으로 채워 넣기도 한다. 이 과정에서 한번 자체적으로 너무 비싸다는 판단을 내려 커넥터 개수를 줄이고 어느 정도의 수요 예측을 통해 \u0026ldquo;Reel\u0026rdquo; 단위로 부품을 미리 당겨서 구매하도록 했다.\n양산을 위해 조립 공장에 보낸 부품들, Reel은 원통형으로 부품이 필름테이프 처럼 감겨있는것을 Reel이라고 한다.\nBOM 정리 / 최적화는 매우 중요하나 일반적인 소프트웨어 개발자에게는 감흥이 없는 주제이므로 유튜버 승우아빠의 레스토랑 BOM을 보면 재미를 느낄 수 있다고 생각한다. 전자 회로에 대한 이야기가 아닌 레스토랑 운영에서의 BOM(음식재료) 관리이긴 하나 매우 유익하다고 생각한다.\n왜 이렇게 되는지 알려드리겠습니다. - 승우아빠 일상채널\n생산 위탁 / 조립 위탁 # PCB를 만드는것과 부품을 그위에 올려서 납땜하는 것(조립, PCB Assembly)은 별개의 일이다. 턴키 업체에 부품 구매까지 맡기는 경우가 있으나 나의 경우엔 사급(이쪽에서 구매해서 제공함)으로 진행하였다.\n그리고 업체는 이미 양산 경험이 있는 회사 선배의 추천을 받은 턴키업체를 이용하였다. (신뢰 기반으로 발품 파는 시간을 줄였다.)\n국내에서 양산을 한 이유 (JLCPCB 혹은 다른 중국에서 하지 않은 이유) # 현재의 중국이 있기 전까지 한국은 전 세계로부터 PCB 제조부터 조립 (+개발)과 함께 제품의 케이스 사출, 판금을 모두 빠르게 해낼 수 있었고, 그 서플라이 체인이 아직 남아있기 때문에 아직은 전자제품의 제조, 생산의 대부분의 공정을 해낼 수 있는 나라다. 하지만 저렴한 가격과 홍보로 해외에서 샘플링 및 소규모 양산을 중국 업체에 주로 맡기는 경우가 유튜브와 커뮤니티를 중심으로 많이 퍼져있는 상황이다. 한국에서는 실무자들만 알고 있는 루트(업체)를 잘 찾고, (업체들이 일을 받아 준다면) 어느 정도 수량의 양산까지 국내에서 진행하는 것이 유리하다. 수량이 매달 수십만 개 이상 만든다고 하면 해외 가공 업체에 의뢰하는 것이 가격적으로 유리할 수 있겠지만 수 천 또는 수 만개 정도의 소량이라면 해외 공장이 매번 잘하는지 검사할 능력과 인력, 그리고 잘못되었을 때 책임질 방법 없다.\n내가 만든 PCB기준으로 1000대를 양산한다고 가정했을 때, JLCPCB가 압도적으로 저렴하긴 하나, 어느 시점에서는 20~30%정도 밖에 차이가 나지않는 지점이 존재했다. 거기에 운송비, 관부가세, 기타 행정 비용을 고려하면 JLCPCB쪽이 별로 이득을 가져다 주지도 않았고 다른 것 보다 문제가 발생했을때에 대해 책임을 제대로 지지않는 다는 것이다. 이 외에 JLCPCB 말고 다른 해외 업체들은 퀄리티는 좋으나 결국에는 문제가 발생했을때 직접 찾아가서 논의를 하기 힘들다라는 문제점은 여전히 존재한다.\n초창기 PCB 10대를 주문했는데 5대가 불량이였다, 하지만 내가 먼저 클레임을 걸어야한다.\n프로그램 다운로드 # MP Tool\nPCB를 만들었다고 해도, 그냥 돌아가는게 아니라 프로그램을 넣어줘야한다. 조립 위탁 단계에서 요청하면 프로그램 바이너리를 넣어주는 경우도 있으나 이번에는 커스텀 프로그램이 필요하여 이쪽에서 직접 넣는 방향으로 했다.\n왜 그런 과정을 거치고 어떻게 개발했는지에 다루면 너무 길어지기에 차후 다른 글에서 다루도록 하고\n대략적인 과정은 이러하다\ngraph LR; A[Power Up] --\u003e|Flash \\nLock Check| B(Unlock Flash\\nTemporary) B --\u003e C[Program\\nDownload] C --\u003e |OTP section\\n check|D{S/N Exist?} D --\u003e|Yes| E[Update to DB] D --\u003e|No| F[Write New OTP\\n\u0026 Insert to DB] 여기서 OTP섹션에 있는 시리얼 넘버를 확인하고 유무에 따라 정보를 추가하거나 갱신하는 과정이 추가로 들어간다. OTP에 시리얼 넘버가 없으면 OTP섹션에 시리얼 넘버를 기입한다.\n글을 마치며 # 최종 양산한 기판\n다음에는 rust로 개발한 펌웨어 소프트웨어 개발 측면에서 다루고 그 뒤에는 러스트 임베디드 생태계, 터득한 테크닉? 같은것을 다루지 않을까 싶다.\n처음으로 개인 양산을 경험한 것이 러스트로 개발한 펌웨어 위에서 돌아가는 것 과 성공적으로 양산을 마칠 수 있어서 매우 기쁘게 생각한다.\n다음에도 개인에서 양산을 하라고 하면 못할 것 같다. 개발을 하는데 있어서의 도움되는 귀중한 경험으로 삼고 이걸 주업으로 혼자서 다 소화하기에는 큰 무리가 있다. 그래도 한번쯤은 혼자서 양산을 태워볼 기회가 있으면 해보는 것을 추천한다.\n이 시리즈의 다른 글도 같이 봐주세요 : 러스트 임베디드 양산 제품 개발기 ","date":"2023년 11월 2일","externalUrl":null,"permalink":"/ko/posts/my_first_commerical_rust_embedded_product_1/","section":"Posts","summary":"아직 작성 중인 글입니다. 중도에 내용이 변경 될 수 있습니다.\n최근에 현장에 내보낸 테스트용 기기\n","title":"러스트 임베디드 양산 제품 개발기 - 1 개발/양산 과정부터 설명","type":"posts"},{"content":"","date":"2023년 4월 8일","externalUrl":null,"permalink":"/ko/tags/amd/","section":"Tags","summary":"","title":"AMD","type":"tags"},{"content":"","date":"2023년 4월 8일","externalUrl":null,"permalink":"/ko/tags/cache/","section":"Tags","summary":"","title":"Cache","type":"tags"},{"content":"","date":"2023년 4월 8일","externalUrl":null,"permalink":"/ko/categories/cpu/","section":"Categories","summary":"","title":"CPU","type":"categories"},{"content":"","date":"2023년 4월 8일","externalUrl":null,"permalink":"/ko/tags/ryzen/","section":"Tags","summary":"","title":"Ryzen","type":"tags"},{"content":"","date":"2023년 4월 8일","externalUrl":null,"permalink":"/ko/tags/silicon-bug/","section":"Tags","summary":"","title":"Silicon Bug","type":"tags"},{"content":"이제 어느정도 ZEN4가 팔린지도 오래되었으며 ZEN3도 stepping? 내부적인 revision이 몇번 바뀌어 개선이 된 것 같아 적당한 시기다 싶어서 이 글을 작성합니다. 이 글은 다른 커뮤니티에도 올렸고 어떻게 보면 개발과 거리가 있으나 CPU 내부를 다루는 관계로 개발블로그에도 옮깁니다.\n전력사용량이 크게 달라지는 경우 Instruction L1, L2 cache 가 장애가 발생함 # 퀘이사존에 WHEA 만 검색해도 수많은 글을 볼 수 가 있습니다.\n과거에 수많은 사람들이 AMD Zen2/ Zen3를 쓰면서 이러한 문제점들은 보고했습니다.\n갑자기 WHEA 18에러가 Windows상의 Event Logger에 뜬다. 갑자기 꺼진다. [Halt] (로그 찾을 수 없음) 갑자기 리셋된다. [Reset] (로그 찾을 수 없음) 아무것도 안하고있는데 위와 같은 현상이 일어난다. C-State를 Disable하니 이러한 이슈가 덜 생긴다. C-State를 끄세요 저 또한 3950x를 과거에 쓰면서 이러한 이슈를 겪었으며 이로 인해서 매우 많은 시간을 허비했으며 결국에는 3950x를 5950x(최근의 Stepping Revision) 그리고 그 중간에 임시로 쓰게되는 5900x를 구매하면서\n컴퓨터가 2대가 되는 자가증식까지 하는 상황까지 겪었습니다. 그리고 이과정에 메인보드는 3번 구매했습니다.\n여기 까지 글을 읽으시면 몇가지 키워드가 보이실겁니다.\n키워드1 키워드2 키워드3 Instruction L1, L2 cache C-State Reset/Halt C-State란 # C-State부터 먼저 설명하겠습니다. 출처 : https://www.dell.com/support/kbdoc/ko-kr/000060621/c-state%EB%8A%94-%EB%AC%B4%EC%97%87%EC%9D%B8%EA%B0%80\nC-State 는 CPU소모전력을 줄일 수 있는 기능으로, 사용을 덜하는 경우 최대한으로 줄입니다.\n실제로 AMD은 Intel이든 C-State를 켠상태에서 PC가 Idle시 사용되는 전력사용량은 UPS로 확인시 매우 큽니다. 10W정도에서 20W정도 차이가 납니다. 이정도 차이면 이번에 새로나온 Intel Alderlake-N100 MiniPC를 충분히 구동할 수 있는 전력이죠. 또한 이 기능은 1990년대에 나온 기능으로 사실상 그냥 지원을 온전히 보장 해주는게 맞는 좋은 기능입니다.\nInstruction L1, L2 cache 란 # 컴퓨터공학과 학부에서 배우는 \u0026ldquo;컴퓨터 구조론\u0026rdquo; 과목에서 배우는 메모리 모델부터 설명을 해보겠습니다.\n[출처 : https://diveintosystems.org/book/C11-MemHierarchy/mem_hierarchy.html ]\n근대의 메모리 시스템은 이와같이 피라미드 형태로 되어있습니다.\n가장 꼭대기에 있는 register부터 cache을 거쳐 Flash Disk 그리고 그아래까지 접근시간과 대신 담고 있는 양 (용량)의 차이가 비례해서 올라갑니다.\nCPU입장에서 register에 접근하는데는 가장 짧은 시간이 걸리는 대신 register의 면적당 가격은 매우 비싸며\n뒤로 갈수록 시간은 좀 걸리는 대신 가격은 싸집니다.\n이 그림에서는 register/cache/Main Memory 사이의 용량이 나와있지는 않지만 사용하는 시스템/목적에 따라 사용될 용량의 분배는 매우 중요할것이며, \u0026ldquo;어떻게 나뉘냐\u0026rdquo; 를 잘 배분 하는 것이 중요합니다. 여기서 사용자가 마음대로 할 수 있는것이라면 디램을 많이 때려박아주는게 될 수 있겠습니다.\n그러면 Instruction L1, L2 cache 은 무엇인가 하면\nCPU는 데이터를 처리를 빨리 접근/읽기 위해서도 cache가 필요하지만\ncache는 CPU가 명령어 소화를 빨리 하기위해서도 cache가 필요합니다.\n데이터를 읽는 목적이나 명령어를 처리하는 과정에서 cache에 데이터가 없다면 DRAM(main memory)에서 가져오는 동안 사실상 일을 멈추고 있는 상태가 됩니다. (파이프라이닝 개념은 여기서 고려안하겠습니다.)\n그리고 뒤에있는 1/2는 1은 CPU각 코어에 가장 빨리 접근할수 있는 공간이며 2는 1보다는 약간 멀리떨어진 계층입니다. (그래도 DRAM보다는 가깝습니다.)\n다시 Zen2/3로 돌아와서 설명하자면 Zen2/3에서 나온 CPU는 16코어 짜리 제품으로서 가장 코어가 많습니다. 그리고 멀티다이 구조를 채택하여 8코어를 두개씩 패키징한 제품입니다.\n그래서 실제로는 메모리 모델이 위에잇는 세모 피라미드 모양이 되지않고 피라미드위에 피라미드 2개가 있고 그 2개의 피라미드 위에 피라미드가 8개씩 추가로 있는 구조가 나옵니다.\n위에서 제기한 증상에 대한 자세한 보고 # 조립 PC를 사용하는 대다수의 사용자들은 Windows를 사용하고 있으시며, 이 글에서 언급한 문제를 겪으셨다면\nWindows Event Logger에서 WHEA18?이란 에러가 뜨거나 아예 에러가 뜨지 않은채 꺼지시(reset)거나 멈추셨(Halt)겁니다. Reset이냐 Halt냐는 아마 메인보드에 다를겁니다. 이는 제가 Asrock/Gigabyte/Asus, B550/X570을 3개다 써보면서 각기 다른식으로 에러가 나오는 것을 확인했습니다.\n이 문제를 정확히 분석하려면 우리는 Windows를 들여다볼게 아니라 Linux 커뮤니티에서 해답을 찾을 수 잇습니다.\n[Correctable MCE errors logged for CPU0/CPU12 L1 instruction cache with AMD Ryzen 9 3900X 12-Core Processor] https://bugzilla.redhat.com/show_bug.cgi?id=1830404 [Random freezes and reboots AMD Ryzen] https://bugzilla.kernel.org/show_bug.cgi?id=210261 (두개의 링크 말고도 수많은 보고가 있으나 일단 2개만 게시합니다.)\n글자체가 매우 기니 요약만 한다면\n랜덤한 시간에 아래와 같은 에러가 뜨며 멈춘다. 그리고 CPU를 바꾸니 그냥 해결됬다\nC-State를 키면 문제가 발생하지않거나 덜 발생한다.\nMay 01 15:06:59 kernel: mce: [Hardware Error]: Machine check events logged May 01 15:06:59 kernel: [Hardware Error]: Corrected error, no action required. May 01 15:06:59 kernel: [Hardware Error]: CPU:12 (17:71:0) MC1_STATUS[Over|CE|MiscV|AddrV|-|-|SyndV|-|-|-]: 0xdc20000000030151 May 01 15:06:59 kernel: [Hardware Error]: Error Addr: 0x000000076da32ae0 May 01 15:06:59 kernel: [Hardware Error]: IPID: 0x000100b000000000, Syndrome: 0x000000001a030507 May 01 15:06:59 kernel: [Hardware Error]: Instruction Fetch Unit Ext. Error Code: 3, IC Data Array Parity Error. May 01 15:06:59 kernel: [Hardware Error]: cache level: L1, tx: INSN, mem-tx: IRD May 01 15:06:59 kernel: mce: [Hardware Error]: Machine check events logged May 01 15:06:59 kernel: [Hardware Error]: Corrected error, no action required. May 01 15:06:59 kernel: [Hardware Error]: CPU:0 (17:71:0) MC1_STATUS[Over|CE|MiscV|AddrV|-|-|SyndV|-|-|-]: 0xdc20000000030151 May 01 15:06:59 kernel: [Hardware Error]: Error Addr: 0x0000000fbedc2ae0 May 01 15:06:59 kernel: [Hardware Error]: IPID: 0x000100b000000000, Syndrome: 0x000000001a030507 May 01 15:06:59 kernel: [Hardware Error]: Instruction Fetch Unit Ext. Error Code: 3, IC Data Array Parity Error. May 01 15:06:59 kernel: [Hardware Error]: cache level: L1, tx: INSN, mem-tx: IRD 에러에 대한 원인 추측/분석 # 특정 상황이 매우 드물게 발생하는데 (CPU가 3Ghz 이상이니 1초에 3000000000사이클 일것이며 사이클 관점에서 봤을때 30분에서 24시간중 한번 발생한다하면 매우 드물다는 입장이지, 사용자 입장에서 잦거나 드물다는 표현은 아닙니다.)\n어느 위에 언급한 C-State에서 힌트를 찾았는데요\nC-State가 켜져있다면 매우 짧은 시간에 CPU core에 인가되는 전력이 매우 작다가 매우 커질것이며 C-State가 꺼져있다면 매우 짧은 시간에 CPU core에 인가되는 전력이 약간 적었다가 매우 커질것입니다. 그럼 원인은 짧은 시간내에 CPU Core에 인가되는 전력차에 따라 CPU Instruction $1/$2 에 영향이 가므로\nCPU가 명령어를 수행하다가 $ (캐시)에서 읽어올 명령어 자체가 coruppted(잘못됨)되었으니 CPU는 명령어를 수행할 수 없습니다. 더이상 나아갈 수 도 없으며 사실 이경우 코어덤프 (메모리 덤프)를 남기는 것 조차 기적일 것 입니다. [대충 메모리 디버깅에는 두가지 방법이 있는데요 SW로 전체 메모리를 백업하는 것과 외제차 가격보다 비싼 하드웨어 장비로 메모리를 덤프뜨는 두가지 방법이 있으며 이때는 후자로만 제대로 분석 할 수있습니다.]\n$1/$2 의 내용은 DRAM(Main Memory)와 미러링, 즉 빨리 접근하기위해 담아두는 공간이라고는 하지만.\n실제 운영체제나 프로그램 설계에서는 linux의 per-cpu 변수 처럼 대체적으로 각 아키텍처의 $1(L1 캐시) 사이즈와 같거나 그보다 작은 크기를 블럭단위로 하며 SMP 시스템 (멀티 코어 시스템)에서 더 DRAM에 저장되지 않고 더 빠르게 읽고 쓰기위해 DRAM에 주소와 메모리 정보가 저장은 되어있지만 사실상 DRAM보다는 캐시에 정확한 정보가 적혀있다고 전제되는 값들이 있습니다. 만약 $1/$2를 믿을수 없는 상황이 되면 per-cpu와 같은 특성을 가진 변수(컴퓨터 프로그램이 사용하는 값)은 제대로 쓸수도 없게 될것이며 이는 Instruction에도 비슷하게 적용이 될수도있습니다.\n진짜 이문제가 CPU에 인가되는 전력의 급격한 변화에 따른 것인지는 어디까지나 추측이지만\n이렇게 많은 사람들이 $1/$2에 문제가 있다고 하는 것은 개인적인 소견으로서는 리콜 감입니다.\n뒤에 있는 per-cpu어쩌구 저쩌구는 학부에서 배우진 않지만 CPU $1/$2는 학부에서 배우는 수준의 지식이며, 기본적인 설계에서 미스가 있는 것 이니까요.\nper-cpu 에 대한 자세한 링크 : http://jake.dothome.co.kr/per-cpu/\n그래서 AMD와 유통사는 어떻게 대응하는가 # 그래서 AMD와 유통사는 어떻게 대응하는가. 유통사가 어떻게 불량점검을 하는지 보면 부팅을 하고 벤치마크 프로그램을 돌립니다. 이게 끝입니다. 사실상 이러한 문제는 전문적으로 Trace32같은 장비를 쓰지않는 이상 문제를 찾기 어렵습니다.\n[출처 : https://www2.lauterbach.com/pdf/general_ref_c.pdf 172페이지]\nTrace32 를 사용하면 실시간으로 CPU의 모든 값을 볼수가있습니다. 일반인 혹은 대다수의 개발자가 고작 할수 있는 방법은 그냥 메모리 주소에 접근하는것이 다이나 이건 DRAM의 값인지 Cache 의 값인지 알수가 없습니다. 이러한 고급 개발툴도 필요하지만 이런 도구를 써서 유통사가 AS를 한다는것은 사실상 불가능에 가깝습니다. 따라서 AS를 진행하시는 직원 분들도 해당 이슈에 대해서는 매우 곤란할 것입니다.\n소비자 입장에서도 이를 입증하고 교환받기가 매우 까다롭습니다.\n그럼 제 생각에 잘못은 AMD에 있습니다.\n처음에 QC에 문제가 있거나, 실리콘 설계를 할때 이러한 문제를 제대로 검증 및 수정하지 않고 판매한 것이 문제라고 생각합니다.\n그래서 AMD는 자기네 CPU의 결함에 대해서 공개를 하거나 공유하는가?\n아뇨 인텔보다는 훨씬 숨기고있습니다.\n일단 인텔은 Errata Sheet (설계결함, 이슈에 대해 정리한 페이퍼) 를 나온지 얼마 안된 13세대에 대해서 공유했습니다.\n[ Intel Raptor Lake S - Errata Details ] https://edc.intel.com/content/www/us/en/design/products/platforms/details/raptor-lake-s/13th-generation-core-processor-specification-update/errata-details/\n그런데 AMD는 소비자용 Zen2 : Family 17h Model 71h , Zen3 : Family 19h Model 21h에 대한 Errata Sheet를 공개하지 않았습니다.\n칩을 구매해서 직접 PCB 회로를 만드시거나 리눅스 커널 드라이버를 작성하는 업무를 하시는 분들은 ErrataSheet를 들어보시고 가끔 거기서 문제점을 찾아 다시 부품 선정을 하거나 고려해서 소프트웨어 상으로 실리콘 버그를 해결 하는 경우가 있을 겁니다만\n이렇게 심각한 문제에 대해서 아무런 고지를 하지않고 그냥 아름아름 인터넷상으로 C-State Disable하라는 글에 의존하면서 이러한 이슈를 숨기는것에 대해 매우 실망스럽습니다.\n앞으로는 이러한 메모리 계층 구조(memory hierarchy)에 심각한 문제가 있는 제품의 결함을 제대로 고시하지않는 AMD가 바뀌길 기대하며 memory 를 좋아하는 고양이 사진으로 이 글을 마칩니다. ","date":"2023년 4월 8일","externalUrl":null,"permalink":"/ko/posts/casts_double_amd_desktop_zen_2_and_3_halt_randomly_kr/","section":"Posts","summary":"이제 어느정도 ZEN4가 팔린지도 오래되었으며 ZEN3도 stepping? 내부적인 revision이 몇번 바뀌어 개선이 된 것 같아 적당한 시기다 싶어서 이 글을 작성합니다. 이 글은 다른 커뮤니티에도 올렸고 어떻게 보면 개발과 거리가 있으나 CPU 내부를 다루는 관계로 개발블로그에도 옮깁니다.\n","title":"ZEN 2/3 의 QC/설계결함으로 인한 간혈적 리셋/멈춤 의혹 제기","type":"posts"},{"content":"","date":"2022년 12월 20일","externalUrl":null,"permalink":"/ko/tags/dsp/","section":"Tags","summary":"","title":"DSP","type":"tags"},{"content":"","date":"20 12월 2022","externalUrl":null,"permalink":"/en/tags/english_article/","section":"Tags","summary":"","title":"English_Article","type":"tags"},{"content":"","date":"2022년 12월 20일","externalUrl":null,"permalink":"/ko/categories/math/","section":"Categories","summary":"","title":"Math","type":"categories"},{"content":"","date":"2022년 12월 20일","externalUrl":null,"permalink":"/ko/tags/mathmatics/","section":"Tags","summary":"","title":"Mathmatics","type":"tags"},{"content":"","date":"2022년 12월 20일","externalUrl":null,"permalink":"/ko/tags/signal-processing/","section":"Tags","summary":"","title":"Signal Processing","type":"tags"},{"content":" 1. 연속 신호의 푸리에 급수 계수 # 계수 유도 문제는 주기 신호와 함께 출제됩니다.: \\(x(t) \\rightarrow a_k\\)\n1.1 (CT FS) 연속 푸리에 계수의 기본 개념 # $$ \\begin{gathered} x(t): \\text { Periodic signal } \\ T: \\text { Fundamental Period } \\ \\end{gathered} $$\n$$ \\begin{gathered} \\omega_0=\\frac{2 \\pi}{T} \\quad \u0026amp; \\quad f_0=\\frac{1}{T}(\\text { freq }) \\ \\end{gathered} $$\n$$ \\begin{gathered} \\quad x(t)=\\sum_{k=-\\infty}^{+\\infty} a_k e^{j k \\omega_0 t}=\\sum_{k=-\\infty}^{+\\infty} a_k e^{j k(2 \\pi / T) t} \\end{gathered} $$\n1.2 (CT FS) 연속시간 푸리에 급수 # 주기 신호를 푸리에 계수로 변환 : \\(x(t) \\stackrel{F S}{\\rightarrow} a_k\\)\n$$ \\begin{gathered} a_k=\\frac{1}{T} \\int _T x(t) e^{-j k \\omega_0 t} d t \\ \\end{gathered} $$ $$ or $$\n$$ \\begin{gathered} a_k=\\frac{1}{T} \\int_T x(t) e^{-j k(2 \\pi / T) t} d t \\end{gathered} $$\n1.3 (CT IFS) 연속시간 역 푸리에 급수 # 푸리에 계수를 주기 신호로 변환 : \\(a_k \\stackrel{I F S}{\\longrightarrow} x(t)\\)\n$$ x(t)=\\sum_{k=-\\infty}^{+\\infty} a_k e^{j k \\omega_0 t}=\\sum_{k=-\\infty}^{+\\infty} a_k e^{j k(2 \\pi / T) t} $$\n1.4 연속시간 푸리에 급수의 성질 # 연속시간 신호 \\(x(t)\\)에 대한 푸리에 변환. 대부분의 경우 비주기 신호가 출제됩니다\u0026hellip;\n2. 이산 신호의 푸리에 계수 # $$ \\begin{gathered} x[n] \\rightarrow \\boldsymbol{a}_{\\boldsymbol{k}} \\end{gathered} $$ 계수 유도 문제는 주기 신호와 함께 출제됩니다.\n2.1 (DT FS) 이산 푸리에 계수의 기본 개념 \\(x[n]: Periodic\\) # $$ \\begin{gathered} x[n]: \\text { Periodic signal } \\end{gathered} $$\n$$ N \\text { : Fundamental Period (LCM of } 2 \\pi \\text { ) } $$\n$$ \\begin{gathered} \\omega_0=\\frac{2 \\pi}{N} \\quad \u0026amp; \\quad f_0=\\frac{1}{T}(\\text { freq }) \\end{gathered} $$\n$$ x[n]=\\sum_{k=\\langle N\\rangle} a_k e^{j k \\omega_0 n}=\\sum_{k=\\langle N\\rangle} a_k e^{j k(2 \\pi / N) n} $$\n2.3 (DT FS) 이산시간 푸리에 급수 # $$\\begin{gathered} a_{k}=\\frac{1}{N} \\sum_{n=\\langle N\\rangle} x[n] e^{-j k \\omega_{0} n} \\ a_{k}=\\frac{1}{N} \\sum_{n=\\langle N\\rangle} x[n] e^{-j k(2 \\pi / N) n} \\end{gathered}$$\n$$\\begin{aligned} \u0026amp; x[n] \\stackrel{F S}{\\rightarrow} a_{k} \\end{aligned}$$\n2.4 (DT IFS) 이산시간 역 푸리에 급수 # $$a_{k} \\stackrel{I F S}{\\rightarrow} x[n] \\quad x[n]=\\sum_{k=\\langle N\\rangle} a_{k} e^{j k \\omega_{0} n}=\\sum_{k=\\langle N\\rangle} a_{k} e^{j k(2 \\pi / N) n}$$\n2.5 연속시간 푸리에 급수의 성질 # 3 연속시간 신호 \\(x(t)\\)의 푸리에 변환 : # 3.1 (CT FT) 연속시간 푸리에 변환 (주기) # $$ x(t) \\stackrel{F T}{\\longrightarrow} X(j \\omega) $$\n$$ \\tilde{x}(t): \\text { single sliced periodic sig } \\ $$\n$$ a_k=\\frac{1}{T} \\int_{-\\frac{T}{2}}^{\\frac{T}{2}} \\tilde{x}(t) e^{-j k \\omega_0 t} d t $$ $$ X(j \\omega)=T a_k $$\n3.2 (CT FT) 연속시간 푸리에 변환 (비주기) # $$x(t) \\stackrel{F T}{\\rightarrow} X(j \\omega) \\quad X(j \\omega)=\\int_{-\\infty}^{+\\infty} x(t) e^{-j \\omega t} d t$$\n3.3 (CT IFT) 연속시간 역 푸리에 변환 # $$X(j w) \\stackrel{I F T}{\\rightarrow} x(t) \\quad x(t)=\\frac{1}{2 \\pi} \\int_{-\\infty}^{+\\infty} X(j \\omega) e^{j \\omega t} d \\omega$$\n3.4 연속 푸리에 변환의 성질 # 3.5 기본 연속 푸리에 변환 쌍 # 4 이산시간 신호 \\(x[n]\\)의 푸리에 변환 # 대부분의 경우 비주기 신호가 출제됩니다\u0026hellip;\n4.1 (DT FT) 이산시간 푸리에 변환 # $$x[n] \\stackrel{F T}{\\rightarrow} X\\left(e^{j \\omega}\\right) \\quad X\\left(e^{j \\omega}\\right)=\\sum_{n=-\\infty}^{+\\infty} x[n] e^{-j \\omega n}$$\n4.2 (DT IFT) 이산시간 역 푸리에 변환 # $$X\\left(e^{j \\omega}\\right) \\stackrel{I F T}{\\rightarrow} x[n] \\quad x[n]=\\frac{1}{2 \\pi} \\int_{2 \\pi} X\\left(e^{j \\omega}\\right) e^{j \\omega n} d \\omega$$\n4.3 이산 푸리에 변환의 성질 # 4.4 기본 이산 푸리에 변환 쌍 # PDF 버전 # Related files DSP_Fourier_CheatNote.pdf (275 KBytes) ","date":"2022년 12월 20일","externalUrl":null,"permalink":"/ko/posts/discrete_signal_processing_cheat_note/","section":"Posts","summary":"1. 연속 신호의 푸리에 급수 계수 # 계수 유도 문제는 주기 신호와 함께 출제됩니다.: \\(x(t) \\rightarrow a_k\\)\n","title":"이산 신호 처리 푸리에 변환 치트 노트","type":"posts"},{"content":"","date":"2022년 11월 27일","externalUrl":null,"permalink":"/ko/categories/etc/","section":"Categories","summary":"","title":"Etc","type":"categories"},{"content":"새로 이직한 회사에서 Rust를 쓰고 있습니다. 이직한지 5개월이 지나고 느낀 바를 서술 해보고자 합니다. 문법적인 세세한 장점은 제쳐두고 그냥 간단하게 느낀 바를 서술 합니다.\n장점 # 개발하려는 도메인에 잘아는 개발자가 있으며, 최소 2인에서 코드리뷰를 서로 잘해주면 안전하게 코딩할수 있습니다. C언어와 비교를 하면 매우 편리한점이 많습니다. C언어/펌웨어 만 하던 사람으로서는 다른 현대언어 대비 좀더 친숙하게 느껴지고 대부분의 행위/설계가 reasonable 하게 느껴집니다. 개인적인 의견으로는 프론트엔드 빼고는 많은 부분에 적용할 수 있습니다. [펌웨어, 운영체제 종속 유틸리티, 백엔드] 개발하는 비즈니스 로직에 대한것이 아닌 순수 CS에 대한 공부/도전 요소가 계속 생깁니다. 타겟 아키텍처 (CPU, Operating System)가 어떤 것이 오든, 대응하기 매우 편리합니다. 단점 # 우리는 FullStack을 넘어 EntireStack 개발자가 될 수 있을까?\n각각의 고난포인트 마다 기본적으로 요구하는 지식이 큽니다. 가끔은 개인시간을 넘어드는 공부/도전 요소가 계속 생깁니다. [저에겐 단점이 아니나, 사람에 따라 단점이라고 느낄 수 있다고 생각합니다.] 구인시 제한이 많습니다. 이 언어의 장점이 뭐야? 라는 질문을 받았을 때, 요구하는 지식 범위가 매우 커질 수 밖에 없습니다. 그리고 그 지식범위는 대다수의 관심사 저 멀리 일 수 있습니다. 임베디드에서 사용하고, 국내 개발자 풀을 본다면, 같이 러스트를 쓸 임베디드 개발자를 구하기가 어렵고, 임베디드 개발자에게 추가적으로 요구되는 능력의 풀이 꽤 기하급수적으로 늘어납니다. 임베디드 개발을 주(主)로 하진 않으나 rust를 고려하지않아도 임베디드 개발자 풀이 너무 적습니다. 꼭 제가 쓰려고하는 칩은 rust 임베디드 지원이 애매합니다. (여기에 대한 답은 제가 스스로 기여를 하는 것이긴합니다.) 아직까지는 커뮤니티가 chip-shortage인 상황에 알짜베기 단가/lead time 면에서 쓸만한 칩보다는 toy-project로 쓸만한 칩에 더 치중에 되어있습니다. 기타 # 이전회사에서 코드리뷰관련해서 매우 깐깐하게 했었고 지금 회사에서는 어떻게 되나 걱정했었는데. 제가 초반에 느낀바로는 C언어 대비 문법이 고도화 되어있기에 스타일이 지나치게 개인마다 달라서 리뷰할 때 이 문제가 병목사항이라 생각했습니다만. 많은것 들을 clippy가 어느정도 해주고 typo check와 어느정도 선에서 합의볼수 있는 수준의 test만 있으면 리뷰는 문제없네요. 서로가 자연스레 건전한 CS 주제로 토론을 할 수 있습니다 여러 아키텍처에 적절한 대응이 가능 # 이론이나 개념상으로는 순수히 인터프리터 언어 가 멀티플랫폼 대응에 유리합니다. 하지만 제가 실제로 Rust를 해본 경험 조금 다르게 느꼈습니다. 아무리 이론과 개념상으로 인터프리터 언어가 유리하다고는 하나, 진정으로 모든 아키텍처(CPU Arch와 여러 OS에 대응)를 적절하게 잘 대응 하기에는 Rust가 매우 편했습니다.\n우선 모든 아키텍처를 적절하게 대응한다라는 면은 시스템 프로그래밍 혹은 펌웨어 프로그래밍의 가치 중 하나입니다. 그럼 기존에 이러한 프로그래밍을 하기위해서 어떠한 언어를 썼을까요. 바로 C와 **C++**입니다. 하지만 해당 언어로 바로 빠르게 빠르게 시작(Getting Start) 하기위해서는 Makefile 이나 CMake 설정부터 해줘야 했으며, 아키텍처가 추가될 때 마다 이에 대응해줘야 했습니다. 여기에 해당 아키텍처를 위한 컴파일러, 개발환경, 라이브러리 세팅은 별도입니다.\n그럼 다른 언어와 비교를 해보겠습니다. 현재는 Go-Lang과 Rust를 비교하는 사람은 거의 없으나, 5년전에는 많이들 비교했던 것 같습니다. 시스템 프로그래밍의 영역을 OS위에서만 비교한다고 했을때에는 둘 다 훌륭한 언어입니다. 앞으로 말한 것은 매우 무리수인 발언이나, Rust개념상의 no-std, OS가 없거나 일반적인 OS와는 매우 형질이 다른경우에는 대응이 어렵습니다. [필자는 펌웨어 개발을 이전에 하였으며, 제품 출하가 가능한 펌웨어 개발이 가능한가를 추가로 따지고 있습니다.]\nRust는 당장에 빠르게 프로토타이핑 하기는 어렵다. # 앞에서는 Rust의 장점에 대해 칭찬하였지만 이번 문단에서는 살짝 아쉬운면을 서술합니다. Rust는 쓰기 어려운 언어입니다. 정확히 말하면 Rust의 장점을 최대한 살려서 Rust스럽게, Rust의 장점을 최대한 부각시키며 개발하기 매우 어렵습니다. 현실적으로 모든 언어가 장점을 살려서 개발하기에는 매우 어려울 것입니다. 하지만 영리활동(회사/개발조직에서 사용 언어? 프레임워크)으로서 Rust를 선택한다면, 개인적인 선호는 후순위로 미룬 채 회사의 입장에서 생각해봐야합니다.\n우리가 개발할 수 있는 것을 실현해줄 수 있는 매게체인가. 개발자를 적절히 구인할 수 있는가. 개발 시간 소요가 어떻게 되는가. 빠르고 정확하게 돌아가는가. 구성원들이 쓰고싶어하는가. (다른 의미로 취향) Rust는 (2), (3) 항목에서 낮은 점수를 받을 가능성이 크며, 특히나 (2) 항목에서는 절대적으로 그렇다고 생각합니다.\n위와 같은 단점을 극복하고라도 Rust를 선택해야만 한다면 특히나 (4), (5) 의 원인이 클 것입니다. 이렇게 된다면 개발조직, 개발자 입장에서는 최대한 Rust의 장점을 부각하는 사건이나 결과가 있어야지만 이를 자의적이든 타의적이든 유지하게 될 것 입니다.\n아무리 회사에서 정해주는 언어를 쓰면되지만, 그래도 선택할수 있고 Rust를 계속 쓰고싶다면 부각하고 싶을 겁니다. (좀 서술하기 어려운 부분입니다. 감정적인 영역이 겹쳐져 있어서요)\n그러면 Rust 의 장점을 최대한 살려서 개발하려면 많은 지식을 요구하게 되버립니다. 다른 문장으로 러닝 커브가 높아집니다. 어떻게 보면 스스로 무덤을 파는 행위가 될 수도, 기회가 될 수 도 있습니다.\n하지만 많은 지적 가치를 얻을 수 있는 기회 # 처음에 C언어가 나왔을 때는 멀티 프로세싱/프로세서(SMP) 개념이나 캐시의 개념, GPGPU이 없으며, 세세한 부분에 있어서 현대적인 메모리 모델과는 다르던 시절입니다. 그리고 지금까지는 C언어로 이러한 부분을 핸들링 하고 있습니다. 그리고 이러한 개념들을 고려하면서 개발해야하는 상황에 놓인다면 많은 어려움이 있습니다.\n하지만 Rust는 이를 어느정도 쉽게 극복할 수 있는 인프라가 마련되어 있거나, 앞으로도 더 마련될 여지가 있습니다. 그리고 애매한 문장이지만, Rust를 통해 간접으로 어려운 컴퓨터나 운영체제의 아키텍처 설계에 대해 좀더 면밀히 볼 수 있는 기회가 마련이 되는 것 같습니다. 이는 Rust 컴파일러의 안전을 위한 제약경고를 통해서도 얻을 수 있으며, 우연치 않게 많은 고수들로 이뤄진 시스템 프로그래밍 개발자들이 많은 커뮤니티의 영향이 원인으로 작용한다고 생각합니다. 멀티 플랫폼에 대한 얘기를 조금더 하자면, 커뮤니티의 강력함으로 인해 멀티플랫폼이 매우 잘 대응 된다고도 생각합니다.\n언제 쯤 충분한 Rust 개발자가 되었다고 할 수 있을까? # 나는 ____ 개발자야 라고 다들 가끔 식 말하곤 합니다. 그러면 언제 쯤 우리는 충분한 Rust 개발자가 되었다~ 라고 말할 수 있을까요.\n정답은 없습니다.\n하지만 개인적인 생각으로는 해당 프레임워크 혹은 언어가 가져다주는 장점을 남들이 이해할 수 있게끔 설명할 수 있다면 ____ 개발자라고 말 할 수 있지 않을까? 라고 생각합니다.\n하지만 아쉽게도 Rust 는 이를 서술 하기가 매우 어렵습니다. 당장에 소유권 부터 설명해야 합니다만. 일단 기본적으로 실행 중인 processs의 stack, heap 부터 이해를 해야합니다.\n참고 자료 : 4.1 소유권이 뭔가요 - The Rust Programming Language 한국어 번역\n이러한 문제로 설득시키려고 하는 대상에게 많은것을 설명해줄 능력이 되야하거나, 듣는 대상이 수준이 높기에 정확하고 매우 깊은 설명이 요구되는 상황입니다.\n처음부터 설명의 난이도가 HARD MODE 인 것은 아쉽지만, 혼자 개발하는 세상도 아닐 뿐더러, 우리가 개발을 할때에 Pull-Request를 진정으로 넣고 싶다면 Review를 해주는 사람에게 설명을 잘 하거나, 잘 할수 있도록 코드를 짜는 것은 어느정도 필요하다 생각합니다.\n그러한 과정 속에서 설명을 할 수 있는 지식의 바탕과 말 솜씨를 늘릴 수 있으며, 더 나아가서 서술 한대로 어떠한 기술에 대해 설명할 수 있는 능력이 갖춰지지 않을까 생각합니다.\n다음 혹은 다다음에 회고록을 작성 할 때에는 Rust 회사에서 써서 얻었던 실제의 이득, 손실에 대해서 다뤄보도록 하겠습니다.\n","date":"2022년 11월 27일","externalUrl":null,"permalink":"/ko/posts/five_mothes_ago_from_using_rust_as_work_kr/","section":"Posts","summary":"새로 이직한 회사에서 Rust를 쓰고 있습니다. 이직한지 5개월이 지나고 느낀 바를 서술 해보고자 합니다. 문법적인 세세한 장점은 제쳐두고 그냥 간단하게 느낀 바를 서술 합니다.\n","title":"Rust를 회사 업무로 쓰고난지 5개월 정도","type":"posts"},{"content":"","date":"2022년 10월 4일","externalUrl":null,"permalink":"/ko/tags/armv8a/","section":"Tags","summary":"","title":"ARMv8A","type":"tags"},{"content":"","date":"2022년 10월 4일","externalUrl":null,"permalink":"/ko/tags/cross-compile/","section":"Tags","summary":"","title":"Cross Compile","type":"tags"},{"content":"","date":"2022년 10월 4일","externalUrl":null,"permalink":"/ko/categories/linux/","section":"Categories","summary":"","title":"Linux","type":"categories"},{"content":"","date":"2022년 10월 4일","externalUrl":null,"permalink":"/ko/tags/linux/","section":"Tags","summary":"","title":"Linux","type":"tags"},{"content":"10월 6일 기준, Rust for Linux는 linux-next에 있으며 stable이 아닙니다.\n따라서 이 글은 Linux 6.1 stable이 나오기 전에 구식이 될 수 있습니다.\n현재 Linux 6.1 rc1에는 ARM64용 Rust for Linux가 포함되어 있지 않습니다. 따라서 이 글에서는 https://github.com/Rust-for-Linux/linux/tree/for-next/rust 를 사용합니다.\n소개 # 이 글에서는 x86_64 debian 환경에서 Rust for Linux를 크로스 컴파일하는 방법을 설명합니다. Apple Silicon을 제외하면 아직 arm64 네이티브 커널을 빌드할 만한 충분한 컴퓨팅 파워가 없습니다.\n참고로 이 글은 다음 링크를 참고하여 작성되었습니다.\nhttps://github.com/Rust-for-Linux/linux/blob/rust/Documentation/rust/quick-start.rst https://docs.kernel.org/kbuild/llvm.html#cross-compiling Debian / Ubuntu 패키지 요구사항 # # Install build-requirements for kernel compile with LLVM. # Biggest difference to native build is # crossbuild-essential-arm64 needed to build` for arm64 apt install clang git llvm-dev libclang-dev build-essential \\ bc kmod cpio flex libncurses5-dev libelf-dev libssl-dev \\ dwarves bison lld curl crossbuild-essential-arm64 커널 빌드 전에 필요한 패키지를 설치해야 합니다.\ncurl --proto \u0026#39;=https\u0026#39; --tlsv1.2 -sSf https://sh.rustup.rs | sh rustup default 1.62 rustup component add rust-src # rustfmt and clippy is need for later developing and debugging. rustup component add rustfmt rustup component add clippy curl로 Rust를 설치합니다. 기본 옵션을 선택하면 됩니다. 또한 현재 Rust for Linux는 1.62 버전에서 동작합니다. 최신 버전(1.64 테스트 완료)에서도 네이티브 컴파일은 잘 동작하지만, 크로스 컴파일은 동작하지 않습니다.\nArch 패키지 요구사항 # TBD Rust-For-Linux에서 Linux 클론하기 # 현재 Rust-for-Linux의 상태, 6.0 RC 단계\n# In my case use `Develop` as worksapce, you can replace this word. mkdir -p ~/Develop cd ~/Develop git clone https://github.com/Rust-for-Linux/linux.git -b rust 위와 같이 클론합니다.\nRust-For-Linux에 필요한 Rust 스크립트 # 클론한 Linux 디렉토리에서 실행합니다.\ngit clone --recurse-submodules \\ --branch $(scripts/min-tool-version.sh rustc) \\ https://github.com/rust-lang/rust \\ $(rustc --print sysroot)/lib/rustlib/src/rust 이 작업은 rustlib 저장소를 Rust 툴체인 디렉토리에 클론합니다.\ncargo install --locked --version $(scripts/min-tool-version.sh bindgen) bindgen 이 작업은 기존 C 코드를 Rust 코드에 바인딩하기 위해 필요합니다.\nRUST_AVAILABLE 확인 # cd ~/Develop/linux make LLVM=1 rustavailable $ make LLVM=1 rustavailable *** *** Rust compiler \u0026#39;rustc\u0026#39; is too new. This may or may not work. *** Your version: 1.62.1 *** Expected version: 1.62.0 *** Rust is available! 위와 같은 결과가 나오면 준비 완료입니다. (1.62.1에서도 크로스 컴파일이 잘 되었지만, 최적의 호환을 위해서는 rustup default 1.62.0을 실행하세요.)\nmenuconfig로 Linux 소스코드 설정하기 # make ARCH=arm64 CROSS_COMPILE=aarch64-linux-gnu- defconfig make ARCH=arm64 CROSS_COMPILE=aarch64-linux-gnu- menuconfig General setup -\u0026gt; Rust support # General setup -\u0026gt; Rust support에서 이 옵션을 활성화합니다. 만약 해당 플래그가 보이지 않으면 make LLVM=1 rustavailable 과정이 성공적으로 완료되었는지 다시 확인하세요. For a detailed mailing thread on CONFIG_RUST see here. See details \u0026rharu; Kernel hacking -\u0026gt; Sample kernel code # Rust 커널 코드를 쉽게 개발하기 위해 예제가 필요합니다. 다음 메뉴에서 예제를 활성화할 수 있습니다.\nKernel hacking -\u0026gt; Sample kernel code에서 관심 있는 항목을 활성화합니다 (전부 다 활성화할 필요는 없습니다). 직접 드라이버를 작성할 때는 활성화하지 않는 것을 권장합니다. 시스템이 느려지거나 dmesg에 불필요한 로그가 남을 수 있기 때문입니다. 특히 netfilter 예제는 너무 많은 dmesg를 출력하므로, netfilter 예제를 공부하는 경우가 아니라면 비활성화하는 것을 권장합니다. Kernel hacking -\u0026gt; Rust hacking # Rust 커널 코드나 드라이버를 디버깅하려면 일부 디버그 옵션을 활성화해야 합니다.\nKernel hacking -\u0026gt; Rust hacking에서 해당 메뉴와 하위 메뉴를 활성화합니다.\n크로스 컴파일 # # -j4 for 4 core virtual machine, -j2 for 2 core, -j1 for single core. make ARCH=arm64 CROSS_COMPILE=aarch64-linux-gnu- LLVM=1 -j32 위 명령어로 빌드합니다. 가상 머신에 할당된 코어 수를 고려하여 job 수를 설정해야 합니다. (-j#)\n빌드 중에 일부 플래그에 대해 질문이 나올 수 있습니다. 저는 기본값을 선택했습니다.\n간단한 컴파일 속도 비교 # 머신 / 환경 컴파일 시간 M1 Max 가상 머신 (4코어 8GB RAM, aarch64 debian11) 16분 M1 Asahi Linux (4P+4E 코어 16GB RAM MacMini, 6.1.0-rc6-asahi) 11분 AMD Ryzen 5950x 네이티브 (16코어 32스레드, 64GB, x86_64) 3분 AMD Threadripper Pro 5975wx 네이티브 (32코어 64스레드, 256GB, x86_64) 2분 크로스 컴파일된 커널을 arm64 가상 머신에 설치하기 # TBD, 곧 업데이트 예정입니다. 크로스 컴파일된 커널을 라즈베리 파이에 설치하기 # TBD, 곧 업데이트 예정입니다. ","date":"2022년 10월 4일","externalUrl":null,"permalink":"/ko/posts/cross_compiling_aarch64_rust_for_linux_from_x86_64_linux/","section":"Posts","summary":"10월 6일 기준, Rust for Linux는 linux-next에 있으며 stable이 아닙니다.\n따라서 이 글은 Linux 6.1 stable이 나오기 전에 구식이 될 수 있습니다.\n","title":"x86_64 머신에서 aarch64(arm64) Rust for Linux 크로스 컴파일하기","type":"posts"},{"content":"10월 기준, Rust for Linux는 linux-next에 있으며 stable이 아닙니다.\n따라서 이 글은 Linux 6.1 stable이 나오기 전에 구식이 될 수 있습니다.\nmodules, out-of-tree # 커널 모듈을 개발하는 방법은 크게 두 가지가 있습니다. In-Of-Tree와 Out-Of-Tree 방식입니다. 이 글에서는 Out-Of-Tree 방식으로 Rust 커널 모듈을 만들어 보겠습니다.\n시작하기 전에 # 커널이 CONFIG_RUST=y로 컴파일되었는지 확인하기 # 다음 명령어로 확인합니다.\nzcat /proc/config.gz | grep -i CONFIG_RUST=y 결과가 CONFIG_RUST=y로 나오면 됩니다.\n하지만 배포판 커널 이미지를 다운로드하거나 사전 설치된 경우에는 /proc/config.gz에서 확인할 수 없을 수도 있습니다.\nNeed some build \u0026 install rust support kernel see here. See details \u0026rharu; $KDIR 준비 # $KDIR은 커널 소스의 경로입니다.\n이 글에서는 CONFIG_RUST로 부팅에 사용된 커널 소스의 경로를 의미합니다.\nKDIR and other kernel module descriptions See details \u0026rharu; 제 경우에는 ~/Develop/linux입니다.\n# /home/pmnxis/Develop/linux export KDIR=$HOME/Develop/linux 코드 살펴보기 # 코드 rust_out_of_tree.rs 를 미리 살펴봅시다\u0026hellip;\n라이선스와 import # 1 2 3 4 5 6 7 8 9 10 11 12 13 // SPDX-License-Identifier: GPL-2.0 //! Rust out-of-tree sample use kernel::prelude::*; module! { type: RustOutOfTree, name: \u0026#34;rust_out_of_tree\u0026#34;, author: \u0026#34;Rust for Linux Contributors\u0026#34;, description: \u0026#34;Rust out-of-tree sample\u0026#34;, license: \u0026#34;GPL\u0026#34;, } 1~3번 줄은 파일의 라이선스 정보를 나타냅니다. 회사에서 코드를 작성하는 경우 GPL-2.0 대신 SomeCompanyName을 사용하거나 그대로 GPL-2.0을 유지합니다. 1 2 3 4 5 6 7 8 9 10 11 12 13 // SPDX-License-Identifier: GPL-2.0 //! Rust out-of-tree sample use kernel::prelude::*; module! { type: RustOutOfTree, name: \u0026#34;rust_out_of_tree\u0026#34;, author: \u0026#34;Rust for Linux Contributors\u0026#34;, description: \u0026#34;Rust out-of-tree sample\u0026#34;, license: \u0026#34;GPL\u0026#34;, } 5번 줄은 이 코드에서 사용할 Rust for Linux 라이브러리를 가져오는 것을 의미합니다.\n다음 예제에서 C로 작성된 모듈은 이렇게 include합니다.\n2 3 4 #include \u0026lt;linux/module.h\u0026gt; #include \u0026lt;linux/kthread.h\u0026gt; #include \u0026lt;linux/irq_work.h\u0026gt; 1 2 3 4 5 6 7 8 9 10 11 12 13 // SPDX-License-Identifier: GPL-2.0 //! Rust out-of-tree sample use kernel::prelude::*; module! { type: RustOutOfTree, name: \u0026#34;rust_out_of_tree\u0026#34;, author: \u0026#34;Rust for Linux Contributors\u0026#34;, description: \u0026#34;Rust out-of-tree sample\u0026#34;, license: \u0026#34;GPL\u0026#34;, } 8번 줄은 module trait의 구현체입니다. 9번 줄은 모듈의 이름으로, C로 작성했을 때 *.ko의 name 필드에 해당합니다. 10~12번 줄은 아래의 C로 작성된 예제와 동일한 목적의 필드입니다.\n56 57 58 MODULE_AUTHOR(\u0026#34;Steven Rostedt\u0026#34;); MODULE_DESCRIPTION(\u0026#34;trace-printk\u0026#34;); MODULE_LICENSE(\u0026#34;GPL\u0026#34;); macro_rule! module을 간단히 살펴보겠습니다. 자세한 내용은 여기를 참고하세요.\nDetails for module! See details \u0026rharu; 실제 구현 # 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 struct RustOutOfTree { numbers: Vec\u0026lt;i32\u0026gt;, } impl kernel::Module for RustOutOfTree { fn init(_name: \u0026amp;\u0026#39;static CStr, _module: \u0026amp;\u0026#39;static ThisModule) -\u0026gt; Result\u0026lt;Self\u0026gt; { pr_info!(\u0026#34;Rust out-of-tree sample (init)\\n\u0026#34;); let mut numbers = Vec::new(); numbers.try_push(72)?; numbers.try_push(108)?; numbers.try_push(200)?; Ok(RustOutOfTree { numbers }) } } impl Drop for RustOutOfTree { fn drop(\u0026amp;mut self) { pr_info!(\u0026#34;My numbers are {:?}\\n\u0026#34;, self.numbers); pr_info!(\u0026#34;Rust out-of-tree sample (exit)\\n\u0026#34;); } } 동작을 추측해보면\u0026hellip;\ninit (insmod?) 시, Rust out-of-tree sample (init) 텍스트를 어딘가에 출력 vec\u0026lt;i32\u0026gt;[72, 108, 200]이 RustOutOfTree 구조체와 함께 커널 메모리 공간에 저장됨 모듈을 drop (rmmod?) 할 때, [72, 108, 200] 텍스트를 출력 여기서 주의 깊게 봐야 할 부분이 있습니다.\n23 24 let mut numbers = Vec::new(); numbers.try_push(72)?; 24번 줄에서 try_push는 std::Vec에는 존재하지 않습니다. Rust 커널 프로그래밍에서는 std::Vec::push 대신 try_push를 사용해야 합니다.\nDetails for alloc::vec::Vec See details \u0026rharu; 또한 20번 줄과 33번 줄에 `init`과 `drop` 함수가 있습니다. 이 코드는 `impl for` 패턴으로 해당 함수들을 구현하고 있습니다. Details for Implementation in rust See details \u0026rharu; 구현체와 그 철학에 대해서는 이후 글에서 설명하겠습니다.\n코드 실행 # 빌드하기 # make LLVM=1 Rust를 지원하는 커널 빌드가 LLVM으로 이루어졌으므로,\n커널 모듈도 LLVM으로 컴파일합니다.\n모듈 설치 # sudo insmod ./rust_out_of_tree.ko 컴파일 후 프로젝트 디렉토리 안에 rust_out_of_tree.ko가 생성됩니다.\n기존에 사용하던 것처럼 insmod로 모듈을 설치할 수 있습니다.\n결과 확인 # # do `sudo rmmod rust_out_of_tree` if you already install the module` # clear all of dmesg log sudo dmesg -C # install the module sudo insmod ./rust_out_of_tree.ko # see log dmesg # uninstall the module sudo rmmod rust_out_of_tree # check log again. dmesg 위 명령어로 실제 결과를 확인할 수 있습니다.\n예상한 대로 [72, 108, 200]이 출력됩니다.\n결론 # 이 간단한 커널 모듈에서 다음과 같은 내용을 정리할 수 있습니다.\n요약 # 코드 상단에 use kernel::prelude::*;를 사용해야 합니다. module! 매크로로 설명을 정의하고 자신의 구조체를 커널 모듈에 등록합니다. kernel::Module 템플릿 함수 \u0026hellip;. -WIP- 커널 프로그래밍에서는 std::Vec 대신 alloc::vec::Vec를 사용합니다. pr_info는 C에서 사용하는 방식과 동일합니다. 참고 # https://github.com/Rust-for-Linux/rust-out-of-tree-module https://www.kernel.org/doc/html/latest/kbuild/modules.html https://github.com/Rust-for-Linux/linux https://rust-for-linux.github.io/docs/kernel/prelude/index.html https://rust-for-linux.github.io/docs/kernel/prelude/macro.module.html https://rust-for-linux.github.io/docs/kernel/prelude/struct.Vec.html ","date":"2022년 10월 2일","externalUrl":null,"permalink":"/ko/posts/look_into_simple_rust_out_of_tree/","section":"Posts","summary":"10월 기준, Rust for Linux는 linux-next에 있으며 stable이 아닙니다.\n따라서 이 글은 Linux 6.1 stable이 나오기 전에 구식이 될 수 있습니다.\n","title":"[Rust Driver] 예제 Rust Linux 드라이버를 빌드해보자","type":"posts"},{"content":"","date":"2022년 10월 2일","externalUrl":null,"permalink":"/ko/tags/rust-driver/","section":"Tags","summary":"","title":"Rust Driver","type":"tags"},{"content":"10월 1일 기준, Rust for Linux는 linux-next에 있으며 stable이 아닙니다.\n따라서 이 글은 Linux 6.1 stable이 나오기 전에 구식이 될 수 있습니다.\n이 글에서는 https://github.com/Rust-for-Linux/linux/tree/for-next/rust 를 사용합니다.\n소개 # 현재 Apple Silicon Mac 시리즈는 일반 데스크톱급 워크스테이션 성능을 갖추면서 어디서든 구매할 수 있는 유일한 ARM 워크스테이션입니다. 물론 32GB 이상의 메모리와 최소 8개의 빅 코어를 갖춘 Apple Silicon이어야 합니다.\n참고로 이 글은 https://github.com/Rust-for-Linux/linux/blob/rust/Documentation/rust/quick-start.rst 를 참고하여 작성되었습니다.\nVM 하이퍼바이저 소프트웨어 선택 # UTM : 무료 / 오픈소스, QEMU 기반. 가끔 까다로움. VM Fusion Tech Preview : 현재 무료 / 클로즈드소스, 무난함. Parallels : 유료 / 클로즈드소스, 취향이 아님 (죄송합니다). Asahi Linux로 작업하는 옵션도 있습니다. 하지만 이 글에서는 네이티브 Asahi Linux 환경은 고려하지 않습니다.\n제 경우에는 VM Fusion을 선택했습니다.\n가상 머신 구성 # Debian 11 : https://cdimage.debian.org/debian-cd/current/arm64/iso-dvd/ !! 정상 동작 확인 완료.\nUbuntu : aarch64 Ubuntu apt 저장소에서 clang과 다른 gcc 빌드 도구의 버전 불일치로 인해 apt가 깨지는 이슈가 있었습니다. 하지만 Ubuntu로 시도해볼 수는 있습니다.\nArch Linux : https://gitlab.archlinux.org/tpowa/archboot/-/wikis/Archboot-Homepage#aarch64-architecture 아직 테스트하지 않았습니다. 다만 M1 Mac Mini에서 Asahi Linux로는 테스트했습니다.\nDebian / Ubuntu 패키지 요구사항 # # Install build-requirements for kernel compile with LLVM. apt install clang git llvm-dev libclang-dev build-essential \\ bc kmod cpio flex libncurses5-dev libelf-dev libssl-dev \\ dwarves bison lld curl Asahi Linux 패키지 요구사항 # pacman -S base-devel cpio lld llvm llvm-libs bc libdwarf Rust 준비 # 커널 빌드 전에 필요한 패키지를 설치해야 합니다.\ncurl --proto \u0026#39;=https\u0026#39; --tlsv1.2 -sSf https://sh.rustup.rs | sh rustup default 1.62 rustup component add rust-src # rustfmt and clippy is need for later developing and debugging. rustup component add rustfmt rustup component add clippy curl로 Rust를 설치합니다. 기본 옵션을 선택하면 됩니다. 또한 현재 Rust for Linux는 1.62 버전에서 동작합니다. 최신 버전(1.64 테스트 완료)에서도 네이티브 컴파일은 잘 동작하지만, 크로스 컴파일은 동작하지 않습니다.\nRust-For-Linux에서 Linux 클론하기 # 현재 Rust-for-Linux의 상태, 6.0 RC 단계\n# In my case use `Develop` as worksapce, you can replace this word. mkdir -p ~/Develop cd ~/Develop git clone https://github.com/Rust-for-Linux/linux.git -b rust 위와 같이 클론합니다.\nRust-For-Linux에 필요한 Rust 스크립트 # 클론한 Linux 디렉토리에서 실행합니다.\ngit clone --recurse-submodules \\ --branch $(scripts/min-tool-version.sh rustc) \\ https://github.com/rust-lang/rust \\ $(rustc --print sysroot)/lib/rustlib/src/rust 이 작업은 rustlib 저장소를 Rust 툴체인 디렉토리에 클론합니다.\ncargo install --locked --version $(scripts/min-tool-version.sh bindgen) bindgen 이 작업은 기존 C 코드를 Rust 코드에 바인딩하기 위해 필요합니다.\nRUST_AVAILABLE 확인 # cd ~/Develop/linux make LLVM=1 rustavailable $ make LLVM=1 rustavailable *** *** Rust compiler \u0026#39;rustc\u0026#39; is too new. This may or may not work. *** Your version: 1.64.0 *** Expected version: 1.62.0 *** Rust is available! 위와 같은 결과가 나오면 준비 완료입니다.\nmenuconfig로 Linux 소스코드 설정하기 # make ARCH=arm64 defconfig make menuconfig GCC plugins 비활성화 # General architecture-dependent options -\u0026gt; GCC plugins 현재(6.1 rc*) 시점에서 RUST_CONFIG 설정을 위해 GCC_PLUGINS 설정을 비활성화해야 합니다. 반드시 비활성화하세요.\nGeneral setup -\u0026gt; Rust support # General setup -\u0026gt; Rust support에서 이 옵션을 활성화합니다. 만약 해당 플래그가 보이지 않으면 make LLVM=1 rustavailable 과정이 성공적으로 완료되었는지 다시 확인하세요. For a detailed mailing thread on CONFIG_RUST see here. See details \u0026rharu; Kernel hacking -\u0026gt; Sample kernel code # Rust 커널 코드를 쉽게 개발하기 위해 예제가 필요합니다. 다음 메뉴에서 예제를 활성화할 수 있습니다.\nKernel hacking -\u0026gt; Sample kernel code에서 관심 있는 항목을 활성화합니다 (전부 다 활성화할 필요는 없습니다). 직접 드라이버를 작성할 때는 활성화하지 않는 것을 권장합니다. 시스템이 느려지거나 dmesg에 불필요한 로그가 남을 수 있기 때문입니다. 특히 netfilter 예제는 너무 많은 dmesg를 출력하므로, netfilter 예제를 공부하는 경우가 아니라면 비활성화하는 것을 권장합니다. Kernel hacking -\u0026gt; Rust hacking # Rust 커널 코드나 드라이버를 디버깅하려면 일부 디버그 옵션을 활성화해야 합니다.\nKernel hacking -\u0026gt; Rust hacking에서 해당 메뉴와 하위 메뉴를 활성화합니다.\n가상 머신에서 컴파일 및 설치 # # -j4 for 4 core virtual machine, -j2 for 2 core, -j1 for single core. make LLVM=1 -j4 위 명령어로 빌드합니다. 가상 머신에 할당된 코어 수를 고려하여 job 수를 설정해야 합니다. (-j#)\n빌드 중에 일부 플래그에 대해 질문이 나올 수 있습니다. 저는 기본값을 선택했습니다.\n시간이 꽤 걸립니다 (라즈베리 파이 4보다는 훨씬 낫습니다만), 제 환경(VM 4코어, 8GB)에서 13~14분 정도 소요되었습니다.\n빌드 후 다음 명령어로 설치합니다.\n# should be under the root permision. make modules_install make install update-grub 완료되었습니다! 재부팅 후 커널이 정상적으로 동작하는지 확인합니다.\nLinux lambda-next 6.0.0-rc7-175589-g542379556669 #2 SMP PREEMPT Sun Oct 2 19:02:32 KST 2022 aarch64 The programs included with the Debian GNU/Linux system are free software; the exact distribution terms for each program are described in the individual files in /usr/share/doc/*/copyright. Debian GNU/Linux comes with ABSOLUTELY NO WARRANTY, to the extent permitted by applicable law. Last login: Sun Oct 2 18:20:21 2022 from 192.168.99.1 pmnxis@lambda-next:~$ uname -r 6.0.0-rc7-175589-g542379556669 간단한 컴파일 속도 비교 # 머신 / 환경 컴파일 시간 M1 Max 가상 머신 (4코어 8GB RAM, aarch64 debian11) 16분 M1 Asahi Linux (4P+4E 코어 16GB RAM MacMini, 6.1.0-rc6-asahi) 11분 AMD Ryzen 5950x 네이티브 (16코어 32스레드, 64GB, x86_64) 3분 AMD Threadripper Pro 5975wx 네이티브 (32코어 64스레드, 256GB, x86_64) 2분 ","date":"2022년 10월 1일","externalUrl":null,"permalink":"/ko/posts/rust_for_linux_with_m1/","section":"Posts","summary":"10월 1일 기준, Rust for Linux는 linux-next에 있으며 stable이 아닙니다.\n따라서 이 글은 Linux 6.1 stable이 나오기 전에 구식이 될 수 있습니다.\n","title":"Apple Silicon MacOS에서 Rust For Linux 개발 환경 구축하기","type":"posts"},{"content":" Introduction # ARMv8A는 흔히 aarch64로도 불리며 현재 ARMv7A를 뒤로한채 널리 사용하는 아키텍처중 하나입니다. 본 글에서는 ARMv8A의 메모리 시스템을 IP단위로 보려합니다.\n사용하는 메모리 (DDR4 , LPDDR4 , DDR3 , LPDDR3 , DDR2)나 사용하는 아키텍처(ARM v8.1 or 8.2)에 조금씩 다르나 대체적으로 위 사진과 같은 형태로 구성이 되어있습니다.\nComponents # CPU # Instruction을 처리합니다.\nGIC # Generic Interrupt Controller; GIC는 각종 Nested한 Interrupt를 관리하며, Interrupt발생시 CPU에서 동작중이던 PC/Register를 백업하고 해당하는 Inetrrupt Vector를 Execution하도록 합니다.\nCCI / CCN # Cache Coherent Interconnect / Netowrk\nDMC # DRAM을 관리합니다. DRAM은 휘발성 메모리로서 Read/Write 이외에 Refresh, Callibration 와 같은 작업이 필요합니다. 추가적으로 EEC, RAS에 대한 관리도 수행합니다. Linux드라이버에서는 edac 디렉터리에서 EEC, RAS에 대한 관리 드라이버 코드를 확인 할 수 있습니다.\nNIC # 각종 Peripheral 을 연결하는데 사용합니다.\nMMU # PA/VA (Physical/Virtual Address) 변환 DMA 컨트롤 Reference # CCI-400 ; https://developer.arm.com/Processors/CoreLink%20CCI-400 CCI-500 ; https://developer.arm.com/Processors/CoreLink%20CCI-500 DMC-400 ; DDR3/DDR2 DMC ; https://developer.arm.com/documentation/ddi0466/f/introduction/about-the-dmc-400 DMC-500 ; LPDDR4/LPDDR3 DMC ; https://developer.arm.com/documentation/100131/0000 ","date":"2021년 12월 14일","externalUrl":null,"permalink":"/ko/posts/arm_v8a_memory_ip_review/","section":"Posts","summary":"Introduction # ARMv8A는 흔히 aarch64로도 불리며 현재 ARMv7A를 뒤로한채 널리 사용하는 아키텍처중 하나입니다. 본 글에서는 ARMv8A의 메모리 시스템을 IP단위로 보려합니다.\n","title":"ARMv8A Memory IP Review","type":"posts"},{"content":"","date":"2021년 12월 14일","externalUrl":null,"permalink":"/ko/tags/electronics/","section":"Tags","summary":"","title":"Electronics","type":"tags"},{"content":"","externalUrl":null,"permalink":"/ko/authors/","section":"Authors","summary":"","title":"Authors","type":"authors"},{"content":"","externalUrl":null,"permalink":"/ko/g-vcbqvyzx51/","section":"G Vcbqvyzx51","summary":"","title":"G Vcbqvyzx51","type":"g-vcbqvyzx51"},{"content":"","externalUrl":null,"permalink":"/ko/series/","section":"Series","summary":"","title":"Series","type":"series"}]