[{"content":"","date":"2026년 2월 17일","externalUrl":null,"permalink":"/ko/categories/","section":"Categories","summary":"","title":"Categories","type":"categories"},{"content":"","date":"2026년 2월 17일","externalUrl":null,"permalink":"/ko/categories/chama-optics/","section":"Categories","summary":"","title":"Chama Optics","type":"categories"},{"content":" Chama Optics # 🌐 English Release Note | 日本語リリースノート\n행사장에서 찍은 사진, 그 자리에서 보정/프레임 입히고 모자이크까지.\nChama Optics는 사진을 좋아하는 여행하는 VTuber 아카이 하아토(赤井はあと)에게서 영감을 받아 만든, 미러리스·DSLR 카메라 사용자를 위한 사진 후처리 앱입니다. 촬영 정보 프레임, 얼굴 자동 모자이크, 색감 보정, 체키 (폴라로이드풍 프레임) 등의 기능을 제공합니다.\n행사·여행·스트릿 촬영 —\n결혼식, VTuber 오프라인 행사, 거리나 관광지 등 다른 사람 얼굴 모자이크가 필요할 때 팬 사진 해시태그 참가자 —\n#推し活はあとん日記, #Towavel 같은 태그로 사진을 올릴 때 DSLR/미러리스 카메라 사용자·장비 리뷰어 —\n촬영 정보(기종, 렌즈, 조리개 등)를 프레임에 넣어서 공유할 때 기술적인 개발 과정이 궁금하다면 개발기를 참고 부탁드립니다.\n⬇ 다운로드로 바로 가기\n주요 기능 # 촬영 정보(EXIF) 프레임 # EXIF 정보를 자동으로 읽어 다양한 테마의 프레임에 넣어줍니다. (자세히 보기) 카메라로 찍은 사진에는 카메라 기종, 렌즈, 셔터스피드, 조리개, ISO 같은 촬영 정보가 들어 있습니다. Chama Optics는 이 정보를 자동으로 읽어서 다양한 테마의 프레임에 넣어줍니다.\niPhone iPad Film Date Strap Monitor Lightroom One Line Shot On Two Line Nikon PhotoStyle Lumix Photo Style + LUT 카메라 제조사 로고(Canon, Nikon, Sony, Lumix 등)도 촬영 정보에서 자동으로 인식해서 프레임에 넣어줍니다. Lumix의 경우 적용된 Photo Style 이름이나 LUT 파일명까지 표시할 수 있습니다.\n얼굴 자동 인식 + 모자이크/스티커 # 사진 속 얼굴을 자동 감지하여 모자이크·스티커로 가려줍니다. (자세히 보기) 행사장이나 관광지에서 다른 사람의 얼굴이 찍혔을 때, 얼굴을 자동으로 감지하여 모자이크 또는 스티커로 가려줍니다.\n모자이크(Mosaic), 스트로크(Stroke), 스티커(Sticker), 모자이크+스트로크(Mosaic+Stroke) 등 다양한 방식으로 가릴 수 있습니다 감지된 얼굴을 개별적으로 선택하여 효과를 적용하거나 해제할 수 있습니다 설정에서 사용자 정의 스티커를 추가하면, 체키 탭의 주사위 굴리기에도 자동 포함됩니다 iPhone iPad 결과 (결혼식) 결과 (행사) 컬러 그레이딩 (LUT) # .cube LUT 파일로 영화 같은 색감을 입힐 수 있습니다. (자세히 보기) 영화나 사진에서 특정 색감을 입히는 데 사용하는 LUT(Look-Up Table) 파일을 적용할 수 있습니다. .cube 파일을 불러오면 사진에 영화 같은 색감을 입힐 수 있습니다.\niPhone iPad 컬러 그레이딩 UI (데스크탑) 적용 결과 (데스크탑) 적용 결과 (사진) 체키 (폴라로이드풍 프레임) # 폴라로이드풍 체키 프레임을 자동으로 생성합니다. (자세히 보기) 폴라로이드 체키풍의 프레임을 자동으로 생성합니다. 랜덤 캐릭터 스티커 배치, 날짜/서명 텍스트, 테두리 설정 등을 커스터마이즈할 수 있습니다.\n체키 활성화 시 폴라로이드풍 하단 여백이 자동 생성됩니다 주사위 굴리기로 랜덤 캐릭터 스티커를 이미지에 배치할 수 있습니다 텍스트/서명, 폰트, 색상, 위치(TL/TC/TR/BL/BC/BR) 등을 자유롭게 설정할 수 있습니다 출력 결과 체키 모드 (iPhone) 체키 모드 (iPad) 텍스트 설정 (iPhone) 텍스트 설정 (iPad) iOS / Android # 데스크탑과 동일한 기능을 모바일에서도 사용할 수 있습니다. (자세히 보기) 2026년 2월부터 iOS TestFlight을 통해 배포 중입니다. 데스크탑과 동일한 기능을 iPhone에서 사용할 수 있습니다.\niOS Android 다운로드 # macOS (Apple Silicon)\nLoading... Windows (x86_64)\nLoading... Linux\nDebian · Ubuntu · Fedora · Rocky · Arch\u0026#9654;curl -sSf https://raw.githubusercontent.com/pmnxis/chama-optics/master/quick-install-linux.sh | bash터미널에서 실행자세한 내용: README_LINUX.md💡 glibc \u0026lt; 2.38 시 ONNX Runtime 자동 다운그레이드 FreeBSD\nFreeBSD 13 · 14 · ⚠ 얼굴 인식 기능 미지원\u0026#9654;fetch -o - https://raw.githubusercontent.com/pmnxis/chama-optics/master/quick-install-freebsd.sh | sh터미널에서 실행자세한 내용: README_FREEBSD.md Web App (wasm32)\n⚠ 실험적 지원 · 일부 기능 제한 iOS (iPhone / iPad)\nTestFlight 배포 중, 2026년 2월 중 App Store 전환 예정 Android (비공개 테스트)\n2026년 3월 3일 이후 공개 테스트 전환 예정 🤖 Android 비공개 테스트 안내\n현재 Google Play 비공개 테스트 단계로, 참여하려면 이 폼에 Play Store 이메일을 등록해야 합니다. Google Play 테스트 정책(12인 이상 14일 테스트) 충족 후, 3월 3일 이후 공개 테스트로 전환되어 이메일 등록 없이 누구나 설치할 수 있습니다.\n🔒 개인정보처리방침\n개인정보 수집 없음 · 회원가입/로그인 없음 · 광고/추적 없음 · 모든 사진 처리는 기기 내에서만 수행 · 얼굴 인식 데이터 서버 전송 없음 · 오프라인 동작\n🌐 앱 내 인도네시아어(Bahasa Indonesia) 번역은 기계번역으로 제공되며, 별도의 검수가 이루어지지 않아 오역이 있을 수 있습니다.\n📜 라이선스 · 크레딧\nAkai Haato는 COVER 주식회사 소속 hololive JP 1기생 VTuber입니다.\n파생저작물 관련 가이드라인: hololive Derivative Works Guidelines\nChamaOptics (Desktop Core): MIT / NON-AI-MIT 혼용 라이선스 · GitHub\nChamaOptics Mobile: Closed Software License\n앱 아이콘: NON-AI / CC-BY-NC · 일러스트레이터 シエミカ (@shiemika324) 님의 팬아트이며, 사용 허가를 받은 원화입니다.\n체키 탭 아이콘: いらすとや (みふねたかし) 일러스트를 단색으로 변환하여 사용 · 이용약관\n※ NON-AI 라이선스는 본 소프트웨어 소스코드 일부에 적용되어 있으며, 관련 리소스(아이콘, 일러스트, 문서 포함)를 인공지능(AI)에 의한 학습, 데이터셋 구축, 검색, 분석, 파생 생성에 사용하는 것을 금지합니다.\n","date":"2026년 2월 17일","externalUrl":null,"permalink":"/ko/posts/chama-optics-public-release/","section":"Posts","summary":"Chama Optics를 릴리즈 합니다. 사진을 좋아하는 여행하는 VTuber 아카이 하아토(赤井はあと)에게서 영감을 받아 만든, 미러리스·DSLR 카메라 사용자를 위한 사진 후처리 앱","title":"Chama Optics 배포","type":"posts"},{"content":"","date":"2026년 2월 17일","externalUrl":null,"permalink":"/ko/tags/haachama/","section":"Tags","summary":"","title":"HAACHAMA","type":"tags"},{"content":"","date":"2026년 2월 17일","externalUrl":null,"permalink":"/ko/tags/hololive/","section":"Tags","summary":"","title":"Hololive","type":"tags"},{"content":"","date":"2026년 2월 17일","externalUrl":null,"permalink":"/ko/tags/photography/","section":"Tags","summary":"","title":"Photography","type":"tags"},{"content":"","date":"2026년 2월 17일","externalUrl":null,"permalink":"/ko/posts/","section":"Posts","summary":"","title":"Posts","type":"posts"},{"content":"","date":"2026년 2월 17일","externalUrl":null,"permalink":"/ko/tags/","section":"Tags","summary":"","title":"Tags","type":"tags"},{"content":" 전자기술 전문가인 내 고양이 Lambdaλ 소개합니다. 이 블로그는 주로 Linux, Rust, Embedded, 전자 회로를 다루며, 한국어와 영어 글이 섞여 있습니다. 때때로 내 고양이 Lambdaλ가 자주 등장하니 좋아해 주시면 감사하겠습니다. 냐 ","date":"2026년 2월 17일","externalUrl":null,"permalink":"/ko/","section":"박진우 블로그","summary":" 전자기술 전문가인 내 고양이 Lambdaλ 소개합니다. ","title":"박진우 블로그","type":"page"},{"content":"시행일: 2026년 2월 25일\n본 페이지는 GitHub Pages 자동 배포로 관리됩니다. 개인정보처리방침의 변경 이력은 GitHub 저장소의 커밋 내역을 통해 확인할 수 있습니다.\nChama Optics(이하 \u0026ldquo;앱\u0026rdquo;)는 Jinwoo Park(이하 \u0026ldquo;개발자\u0026rdquo;)이 개발·운영하는 사진 후처리 애플리케이션입니다. 본 개인정보처리방침은 앱 사용 시 이용자의 개인정보가 어떻게 처리되는지 설명합니다.\n1. 수집하는 개인정보 # Chama Optics는 어떠한 개인정보도 수집, 저장, 전송하지 않습니다.\n앱은 회원가입, 로그인, 계정 생성을 요구하지 않습니다. 이름, 이메일, 전화번호, 위치정보 등 개인을 식별할 수 있는 정보를 수집하지 않습니다. 앱 사용 분석(Analytics), 광고, 추적(Tracking)을 위한 정보를 수집하지 않습니다. 기기 식별자, IP 주소, 쿠키 등을 수집하지 않습니다. 2. 앱 권한 및 접근 목적 # Chama Optics는 사진 후처리 기능을 제공하기 위해 다음의 기기 권한을 요청할 수 있습니다.\n권한 목적 데이터 전송 여부 사진 라이브러리 접근 이용자가 선택한 사진을 불러와 프레임·모자이크 등의 후처리를 적용하기 위해 없음 (기기 내 처리) 저장소 접근 처리된 사진을 기기에 저장하기 위해 없음 (기기 내 저장) 요청된 권한은 오직 앱의 핵심 기능(사진 후처리)을 위해서만 사용됩니다. 카메라, 마이크, 연락처, 위치정보 등의 권한은 요청하지 않습니다. 3. 사진 및 이미지 데이터 # 이용자가 선택한 사진은 기기 내에서만 처리됩니다. 사진 데이터는 외부 서버로 전송되지 않습니다. EXIF 데이터(카메라 기종, 렌즈, 촬영 설정 등)는 촬영 정보 프레임 생성을 위해 기기 내에서만 읽히며, 외부로 전송되지 않습니다. 처리된 사진은 이용자의 기기 저장소에 저장되며, 이용자가 직접 관리(삭제 등)할 수 있습니다. 4. 얼굴 감지 처리 # Chama Optics는 사진 속 얼굴을 자동으로 감지하여 모자이크(픽셀화)·스티커·테두리 등의 프라이버시 보호 효과를 적용하는 기능을 제공합니다.\n4.1 수집하는 얼굴 데이터 # 앱은 얼굴 바운딩 박스 좌표(x 위치, y 위치, 너비, 높이)만을 수집합니다 — 이미지 내 얼굴 위치를 나타내는 사각형 영역입니다. 얼굴 랜드마크(눈, 코, 입 위치)는 수집하지 않습니다. 얼굴 특징 임베딩 또는 생체 인식 정보는 수집하지 않습니다. 신원 정보는 수집하지 않습니다 — 앱은 얼굴 감지(위치 파악)만 수행하며, 얼굴 인식(개인 식별)은 수행하지 않습니다. 4.2 얼굴 데이터 사용 목적 # 얼굴 바운딩 박스 좌표는 사용자가 선택한 프라이버시 보호 효과(모자이크/픽셀화, 테두리, 스티커 오버레이)를 적용하는 데에만 사용됩니다. 이 기능은 사용자가 SNS에 사진을 공유하기 전에 얼굴을 가리는 것을 돕습니다. 얼굴 감지 결과는 개인을 식별, 프로파일링, 추적하는 데 절대 사용되지 않습니다. 4.3 얼굴 데이터 저장 위치 # 모든 얼굴 감지 처리는 기기 내에서만(온디바이스) 수행됩니다. 얼굴 바운딩 박스 좌표는 사용자가 편집을 재개할 수 있도록 편집 세션 상태의 일부로 기기 내에 로컬 저장됩니다. 얼굴 데이터는 외부 서버, 클라우드 서비스, 또는 제3자에게 절대 전송되지 않습니다. 4.4 얼굴 데이터의 제3자 제공 # 얼굴 데이터는 어떠한 제3자에게도 공유되지 않습니다. 앱에는 광고 SDK, 분석 SDK 또는 얼굴 데이터를 전송할 수 있는 네트워크 코드가 포함되어 있지 않습니다. 4.5 얼굴 데이터 보존 기간 # 얼굴 바운딩 박스 좌표는 해당 이미지가 앱의 갤러리에 남아 있는 동안에만 기기 내에 로컬 보존됩니다. 얼굴 데이터는 다음의 경우 영구적으로 삭제됩니다: 사용자가 앱의 갤러리에서 이미지를 제거한 경우, 또는 사용자가 앱을 삭제(언인스톨)한 경우. 어떠한 시점에서도 서버에 얼굴 데이터가 보존되지 않습니다. 4.6 플랫폼별 사용 기술 # iOS: Apple Vision Framework (VNDetectFaceRectanglesRequest) — 기기 내 처리 Android: Google ML Kit Face Detection — 기기 내 처리, Google 서버로 데이터 전송 없음 데스크탑(macOS/Windows/Linux): ONNX Runtime + SCRFD 모델 — 기기 내 처리 Android 사용자 참고: Google ML Kit Face Detection은 온디바이스로 동작하며, 얼굴 이미지나 인식 결과가 Google 서버로 전송되지 않습니다. 자세한 내용은 Google ML Kit 이용약관을 참고하세요.\n5. 데이터 보안 # 앱은 개인정보를 수집하지 않으므로 외부 전송되는 사용자 데이터가 없습니다. 모든 사진 처리는 이용자의 기기 내에서 수행되며, 외부 서버와의 통신이 발생하지 않습니다. 앱의 소스 코드 중 핵심 라이브러리는 GitHub에서 공개되어 있어 투명성을 확보하고 있습니다. 6. 데이터 보존 및 삭제 # Chama Optics는 서버에 어떠한 이용자 데이터도 저장하지 않습니다. 얼굴 바운딩 박스 좌표는 편집 세션의 일부로 로컬 저장되며, 사용자가 앱에서 이미지를 제거하거나 앱을 삭제하면 삭제됩니다 (4.5항 참조). 처리된 결과 이미지는 이용자의 기기 저장소에 저장되며, 이용자가 기기의 파일 관리 기능을 통해 직접 삭제할 수 있습니다. 앱을 삭제하면 저장된 얼굴 좌표를 포함하여 앱과 관련된 모든 로컬 데이터가 제거됩니다. 7. 네트워크 사용 # Chama Optics는 사진 처리를 위해 인터넷 연결을 필요로 하지 않습니다. 앱은 기본적으로 오프라인에서 동작합니다. 앱 업데이트 확인 등 플랫폼(App Store, Google Play)이 제공하는 기능에 의한 네트워크 통신은 해당 플랫폼의 정책을 따릅니다. 8. 제3자 제공 # Chama Optics는 이용자의 데이터를 제3자에게 판매, 제공, 공유하지 않습니다. 앱 내에 광고 SDK, 분석 SDK, 소셜 로그인 SDK 등 제3자 서비스가 포함되어 있지 않습니다. Android 버전에서 사용하는 Google ML Kit은 온디바이스로만 동작하며, 이용자 데이터를 Google에 전송하지 않습니다. 9. 아동 개인정보 보호 # Chama Optics는 아동(만 13세 미만)을 대상으로 하지 않습니다. 앱은 어떠한 사용자로부터도 개인정보를 수집하지 않으므로, 아동에 대한 별도의 수집 절차가 존재하지 않습니다. 10. 개인정보처리방침의 변경 # 본 방침이 변경될 경우, 변경 사항은 이 페이지에 게시되며, 시행일이 업데이트됩니다. 중요한 변경이 있는 경우, 앱 업데이트 또는 GitHub 저장소를 통해 안내합니다. 11. 문의 # 본 개인정보처리방침에 관한 질문이나 요청이 있으시면 아래로 연락해 주세요.\n개발자: 박진우 (Park Jinwoo) GitHub: https://github.com/pmnxis/chama-optics 이메일: pmnxis@gmail.com ","date":"2026년 2월 16일","externalUrl":null,"permalink":"/ko/chama-optics-privacy/","section":"박진우 블로그","summary":"시행일: 2026년 2월 25일\n본 페이지는 GitHub Pages 자동 배포로 관리됩니다. 개인정보처리방침의 변경 이력은 GitHub 저장소의 커밋 내역을 통해 확인할 수 있습니다.\n","title":"Chama Optics 개인정보처리방침","type":"page"},{"content":"EXIF 기반 사진 프레임 + 얼굴 자동인식 프로그램, Rust 코어로 데스크탑부터 모바일까지\n이 블로그에 오타쿠스러운 글을 대놓고 쓰는 건 이번이 아마 처음일 것이다. 솔직히 이 글을 쓰기 시작한 지는 꽤 되었는데, 청자를 개발자에게 맞춰야 할지 VTuber 오타쿠에게 맞춰야 할지 감이 잡히지 않았다. 결국 그냥 의식의 흐름대로 개발하고 기여한 것들을 나열하기로 했다.\n이 블로그에서는 주로 Rust Embedded를 다루고 있었고, 이전에 billmock-app-rs라는 Rust Embedded 양산 프로젝트를 진행한 바 있다.\n이 글에서는 Chama Optics의 개발 과정을 소개한다.\n2026년 2월 마지막 주에 0.2.0에 iOS / Android / macOS / Linux / Windows 의 정식 배포를 할 예정이며 App Store, Google Play 승인 전 개발 과정을 서술하고 있습니다.\n🌐 English Article | 日本語アーティクル\n어플리케이션 소개 및 릴리즈 노트는 여기에서 볼 수 있습니다.\n프로젝트 소개 # Chama Optics는 DSLR/미러리스 카메라로 촬영한 사진의 EXIF 데이터를 분석하여 다양한 테마 프레임을 적용하고, 워터마크·모자이크·스티커 등의 효과를 추가할 수 있는 사진 후처리 프로그램이다. \u0026ldquo;Chama\u0026quot;라는 이름은 여행 VTuber Akai Haato(赤井はあと)의 별칭에서 유래했다.\n수많은 모바일 기기를 거쳤지만 내 관심은 항상 전자기기를 만드는 쪽이었고, 스마트폰 앱 개발과는 거리가 멀었다. 그런 내가 Hololive JP 1기생 아카이 하아토(HAACHAMA)의 팬으로서 오타쿠 생활을 하면서, 임베디드가 아닌 소프트웨어 개발 영역에서 첫 프로젝트를 시작하게 되었다.\n이 프로그램을 처음 구상한 것은 2025년 3월부터이다. 당시에는 웹앱으로 동작하길 원했으며, 라이브러리 테스트, WASM 환경 테스트, libheif 포팅 등을 진행하고 있었다. 2025년 8월, 일본 도쿄에서의 아마네 카나타 솔로라이브 LOCK-ON과 미국 뉴욕에서의 AnimeNYC World Tour + EN Concert(All for one)를 다녀온 뒤, 사진을 빠르게 정리하고 WEBP로 압축해서 게시할 필요성을 절감했다. 동시에 아카이 하아토도 최근 사진 찍는 것을 좋아하여, 멤버십 한정 글로 자기가 쓰는 카메라를 보여주거나 오시카츠하아톤일기(#推し活はあとん日記)에서 사진 게시를 유도하고 있었기에, 하아토(HAACHAMA) 이름으로 앱을 하나 개발해주고 싶었다.\n최근 3D Live Akai Haato X(twitter) /／ 📢 本日２１：００から‼️\n\\＼\n赤井はあと生誕3D LIVE開催!!🎊\n🎁テーマはホラー⁉️\n🎁ゲスト多数\u0026amp;告知あり◎\n🎁演出はこだわり満天🥳\nダンスや歌も精一杯がんばったので\nみんな是非！見に来てねっ❕👀✨#赤井はあと爆誕祭2025\n【開催場所】https://t.co/3IUA2stYWi… pic.twitter.com/A1OqUBCbsM\n\u0026mdash; 赤井はあと❤️‍🔥旅するアイドル (@akaihaato) August 9, 2025 四万温泉ステキな場所でした。\nぐんまー帝国、ありがとん❤️‍🔥 pic.twitter.com/Ov0CwFRF7V\n\u0026mdash; 赤井はあと❤️‍🔥旅するアイドル (@akaihaato) April 26, 2025 프로그램을 개발할 때에는 아래의 철칙을 따랐다.\n데스크탑상에서 어떠한 아키텍처 차별이 있어서는 안 된다. MS나 Apple의 개발 생태계에 최소한으로 얽매여야 한다. 리소스를 많이 사용하면 안 되며 빨라야 한다. 목표는 무슨 거창한 것처럼 보이지만 내가 그냥 Rust 매니아라서 저게 목표다.\n시작: EXIF 프레임을 좀 더 편하게 # 처음부터 거창한 크로스플랫폼 앱을 계획했던 건 아니었다.\n사진기 매니아들 사이에서는 사진을 올릴 때 EXIF 정보를 바탕으로 카메라 모델명, 렌즈, 셔터스피드 등을 프레임에 넣어 공유하는 문화가 있다. 나도 이 방식을 즐겨 사용하고 있었고, 기존에는 exif-frame이라는 웹 기반 도구를 참고하여 사용하고 있었다. 하지만 HEIF 포맷을 지원하지 않는 점과 고해상도 이미지 출력에 제한이 있는 점이 아쉬워서, 직접 만들자는 생각에서 Chama Optics가 시작되었다.\n처음에는 데스크탑만을 고려했다. 모바일에 대한 막연한 상상은 있었지만, 여행지에서도 어차피 언제나 맥북을 들고 다녔기에 모바일은 전혀 염두에 두지 않았다. 카메라에서 SD 카드를 빼고, 맥북에서 사진을 정리하고, 프레임을 입혀서 올리는 — 그 워크플로우가 당연했으니까.\n방향 전환: \u0026ldquo;행사장에서 맥북을 꺼낼 순 없잖아\u0026rdquo; # 방향이 바뀐 건 두 가지 계기가 있었다.\n행사 문화의 차이 — AnimeNYC에서 느낀 것 # 2025년 8월, AnimeNYC와 Hololive World Tour / EN Concert를 위해 미국을 방문했다. 그때 재밌는 차이를 느꼈다. 미국에서는 행사장에서 찍은 사진을 올릴 때 사람들의 얼굴을 모자이크하지 않는 경향이 강했다. 하지만 한국과 일본의 행사에서는 다른 사람의 얼굴을 반드시 모자이크 처리하는 것이 예의이자 암묵적인 규칙이었다.\n\u0026ldquo;다른 사람 얼굴 모자이크\u0026quot;는 매번 수작업으로 하기엔 너무 번거로운 작업이다. 특히 사진이 수십, 수백 장이 되면 더욱. 자동 얼굴 인식 + 모자이크/스티커 기능이 필요하다는 생각이 이때부터 강하게 들었다.\n곧 다가올 홀로라이브 엑스포 # 또 하나의 동기는 2026년 3월의 홀로라이브 엑스포/페스티벌이었다. 행사장에서 바로 사진을 찍고, 그 자리에서 프레임을 입히고, 모자이크까지 처리해서 SNS에 올릴 수 있다면? 그런데 행사장에서 맥북을 열 순 없다. 스마트폰에서 바로 처리할 수 있어야 했다.\n주변의 요청 # 여기에 주변에서 iOS 버전 개발에 대한 요청이 더해졌다. 그래서 iOS용을 개발하기 시작했더니, 이번에는 Android 버전에 대한 요청도 들어왔다.\n이렇게 해서 데스크탑 전용이었던 프로그램이 iOS, 나아가 Android까지 지원하는 방향으로 확장되었다. 모바일에서는 미러리스 카메라 사용자보다는 일반 사용자의 경험을 더 고려하는 쪽으로 설계 방향을 잡았다. EXIF 프레임이라는 출발점은 그대로지만, \u0026ldquo;행사 현장에서 빠르게 사진을 처리해서 공유한다\u0026quot;는 새로운 사용 시나리오가 추가된 셈이다.\n아키텍처: 데스크탑에서 시작해 모바일까지 # 처음에는 Rust + egui로 데스크탑 앱만 만들 생각이었다. 그래서 핵심 로직을 모두 Rust로 작성한 것이 결과적으로 좋은 선택이 되었다. iOS/Android로 확장할 때 이미지 처리, EXIF 파싱, 테마 렌더링, 인코딩/디코딩 같은 핵심 코드를 그대로 재사용할 수 있었기 때문이다.\n데스크탑에서는 Rust 코어를 직접 링킹하여 사용하고, iOS에서는 C FFI를 통해 Swift에서 호출, Android에서는 JNA(Java Native Access)를 통해 Kotlin에서 호출하는 구조다. Rust 코어는 git submodule로 관리되며, EXIF 해석, 이미지 오버레이(텍스트, EXIF, 여백, 스케일링, 인코딩/디코딩) 같은 핵심 기능을 모든 플랫폼에서 공유한다.\n단, 얼굴 인식만은 플랫폼마다 다른 전략을 사용한다.\n데스크탑(macOS/Windows/Linux): ONNX Runtime + InsightFace(SCRFD det_10g) 모델. Speed Mode에 따라 640×640 고정 입력 크기의 슬라이딩 윈도우를 다단계(2560/1280/640)로 적용하여 작은 얼굴까지 감지하고, NMS로 중복을 제거하는 파이프라인 iOS: Apple Vision Framework를 네이티브로 사용. ONNX 모델 없이도 빠르고 정확하며, 프라이버시 면에서도 유리 Android: Google ML Kit (com.google.mlkit:face-detection) 활용 — Google이 제공하는 온디바이스 얼굴 인식 라이브러리, Rust 코어의 speed_mode를 FAST/ACCURATE 퍼포먼스 모드로 매핑 Web 버전을 포기하게 된 이유 # 나는 Web App이나 Web과 브라우저의 동작 방식에 대해서 해박하지 않다. 그럼에도 Chama Optics는 초기에 Web(WASM)에서의 구동을 염두에 두고 있었다. egui가 WASM을 지원하니까 \u0026ldquo;데스크탑이랑 웹이랑 동시에 되겠지\u0026quot;라는 막연한 기대가 있었다. 하지만 다음 두 가지 기능을 구현하면서 포기하게 되었다.\nHEIF 디코딩 egui Web에서의 Drag \u0026amp; Drop HEIF: WASM 위에 WASM, 그 사이에 JS # libheif를 브라우저에서 돌리기 어려운 것 이전에, 근본적인 구조가 납득이 되지 않았다. libheif는 이미 WASM으로 컴파일된 상태이고, egui 앱 또한 WASM이다. 이 둘 사이의 통신을 JavaScript를 통한 FFI로 몇 번이나 거쳐야 한다는 것이 이해가 되지 않았다. 대부분의 언어 간 FFI는 C 기반으로 하는 것에 반해, 왜 JS 생태계에서는 이렇게 해야 하는지 이해할 수 없었다.\nDrag \u0026amp; Drop: 데스크탑 개발자의 기대와 현실 # Drag \u0026amp; Drop 이외에도, WASM이 브라우저로부터 이벤트를 받을 때 JS가 아닌 DOM을 바이너리 형태로 받는다거나, 좀 더 기존 데스크탑/임베디드 개발에서 쓰일 법한 방법이 제공될 줄 알았으나 아니었다.\n솔직히 C와 Rust밖에 쓸 줄 모른다 # 나는 C와 Rust밖에 쓸 줄 모른다. 즉, Web 개발 자체에 대해서 매우 무지하거나, 과거에 하더라도 이상한 방식으로 개발했다.\n예전에 수많은 데이터를 웹에 나열해야 할 일이 있었는데, 어떻게 할지 몰라서 넣을 데이터들을 CSV로 만들고 ,와 \\n을 \u0026lt;div\u0026gt; 등의 HTML 태그로 변경하는 것을 hex editor로 전체 치환해서 static web을 만들어 배포한 적이 있다. 21세기가 25%나 지나간 현대 프로그램 개발에 있어서 스스로도 \u0026ldquo;이게 뭐요\u0026rdquo; 싶었다.\n물론 WASM은 웹이기에 웹 생태계와 개발자들의 방식을 따르는 것이 보편적일 것이다. 하지만 나는 웹 개발자가 아니기 때문에 이해가 되지 않았다. 나는 JS/Web 생태계와 매우 거리가 멀었고, 이런 개발 환경 자체의 방향성 차이를 극복하는 것보다 네이티브 모바일 앱을 만드는 게 훨씬 자연스러웠다. v0.1.9-beta에서 공식적으로 WASM 지원을 제거했고, 그 에너지를 iOS/Android 네이티브에 쏟기로 했다.\n타임라인으로 보는 개발 여정 # v0.1.0~v0.1.1 (2025-10-19~21) — 첫 프리릴리즈 # macOS/Windows 바이너리 첫 배포. Film 테마 프레임, 일본어 번역, 일괄 저장, 파일명 접두어/접미어 설정. macOS 코드 사이닝 DMG 배포 및 한/영/일 설치 가이드 위키 작성.\nv0.1.2~v0.1.6 (2025-10-27~11-24) — 테마 확장과 워터마크 # Film Date 테마 Strap 테마 Monitor 테마 Lightroom 테마 Film Date/Film Glow/Just Frame/Strap/Monitor/Lightroom 테마 추가. 워터마크(위치 9곳, 투명도, 블렌드 모드), 폰트 선택(내장 + OS 폰트), 내장 카메라 제조사 로고 자동 적용, HEIF 방향 수정, 가변 폰트 초기 지원, Longside 스케일 옵션.\nv0.1.7 (2025-11-26~12-19) — CJK 렌더링 개선과 오픈소스 기여 # One Line 테마 Shot On Two Line 테마 Nikon PhotoStyle Lumix Photo Style + LUT One Line/Two Line/Shot On 테마. CJK 글리프 렌더링 대폭 개선 및 SourceHanSans fallback 내장. Lumix LUT·Nikon PhotoStyle 이름을 EXIF에서 추출하기 위해 exif-rs에 PR 제출 후 선반영.\nv0.1.8 (2025-12-25~27) — UI 리뉴얼과 성능 개선 # 이미지 리스트 탭 테마 설정 탭 탭 기반 인터페이스 전환(4개 탭), EXIF 변수 자동완성, 이미지 자동 그룹화, 2MP MPF 프리뷰 기반 테마 미리보기, Rayon 멀티코어 병렬 처리, 시스템 폰트 로딩 메모리 이슈 수정. egui에도 PR 제출.\nv0.1.9 (2026-01-18~02-04) — 얼굴 인식, LUT, iOS 첫 배포 # 얼굴 인식 (데스크탑) 모자이크 적용 컬러 그레이딩 UI LUT 적용 결과 iOS 갤러리 iOS 편집 데스크탑 단독 릴리즈 마지막이자 iOS 앱 첫 배포 버전. ONNX(InsightFace) 얼굴 감지 + 모자이크/스트로크/스티커 오버레이. 1D/3D LUT 컬러 그레이딩(wagahai-lut). iOS는 SwiftUI + Vision Framework 네이티브 얼굴 인식, Rust FFI 브리지(ffi_ios.rs + RustBridge.swift). 인도네시아어 번역 추가.\n기술적 도전과 해결 # 프로젝트 전반에 걸쳐 적용된 성능 전략들을 먼저 정리하면 다음과 같다.\nRayon 병렬 처리 — 대량 이미지 일괄 내보내기 시 멀티코어 활용. 단, 색상 보정 등 픽셀 단위 처리에서는 10만 픽셀 이상인 경우에만 par_chunks_exact_mut()으로 병렬화하고, 작은 이미지는 컨텍스트 스위칭 오버헤드를 피하기 위해 순차 처리한다. fast_image_resize 기반 리사이징 — image 크레이트의 기본 리사이즈 대신 SIMD 최적화된 fast_image_resize를 사용하여 썸네일 생성 및 프리뷰 리사이징 속도를 크게 개선 Lazy 로딩과 캐싱 — LUT 파일은 lut_cache: HashMap\u0026lt;Uuid, CubeLut\u0026gt;에 최초 사용 시 파싱하여 캐싱하고, EXIF 썸네일도 thumbnail_cache에 지연 로드한다. 백그라운드 스레드용 복제(clone_for_thread())시에는 캐시를 제외하여 불필요한 메모리 복제를 방지한다. 퍼셉추얼 해시 기반 이미지 그룹화 — 이미지 로드 시 8×8 그레이스케일 평균 해시(64-bit)를 미리 계산하여, 이후 유사 이미지 그룹화를 해밍 거리 O(1) 비교로 수행. 원본 이미지를 다시 로드하지 않고 메타데이터만으로 그룹화한다. 빌드 프로파일 최적화 — Release 빌드에서 opt-level = 3, lto = \u0026quot;fat\u0026quot;, codegen-units = 1을 적용하고, Dev 빌드에서도 fast_image_resize, mozjpeg, ab_glyph 등 성능에 민감한 의존성은 opt-level = 3으로 개별 설정하여 디버그 중에도 이미지 처리 성능을 유지한다. 1. 크로스플랫폼 FFI의 복잡성 # Rust 코어를 3개 플랫폼(데스크탑/iOS/Android)에서 사용하기 위해 각각 다른 FFI 전략을 택했다.\n플랫폼 FFI 방식 특징 데스크탑 (egui) 직접 링킹 Rust → Rust, FFI 불필요 iOS (SwiftUI) C FFI (@_silgen_name) Swift에서 C 함수 직접 호출 Android (Compose) JNA (Java Native Access) Kotlin에서 JNA를 통해 .so 호출 이 브리지 계층을 유지보수하면서도 안정적인 메모리 관리(문자열 할당/해제, 불투명 포인터 핸들 패턴)를 보장하는 것이 주요 과제였다.\n2. EXIF 파싱의 끝없는 변수 # 카메라마다 EXIF 기록 방식이 다르다.\n셔터스피드/F값의 부동소수점 문제 — 1/125초가 0.008000000 같은 지저분한 값으로 기록되는 경우 자동 보정 HEIF/HEIC 방향 정보 오류 — 일부 이미지에서 방향이 틀어지는 문제 렌즈 정보 없는 카메라 — Nikon Coolpix 같은 컴팩트 카메라 대응 MakerNote에 숨겨진 정보 — Lumix LUT명, Nikon PhotoStyle, Sony Creative Look 등 제조사별 비공개 EXIF 필드 파싱 이를 위해 exif-rs 라이브러리에 직접 PR을 보내 필요한 기능을 추가했다.\n3. MakerNote 파싱: 제조사별 촬영 설정 추출 # 최근 미러리스 카메라들은 자체적으로 색감을 맞춰주는 기능이 매우 뛰어나다. Lumix의 Photo Style, Nikon의 Picture Control, Sony의 Creative Look 등이 그것이다. 사진가들 사이에서는 \u0026ldquo;어떤 색감 설정으로 찍었는지\u0026quot;가 카메라 기종이나 렌즈만큼이나 중요한 정보인데, 이 정보를 프레임에 같이 넣어줄 수 있으면 좋겠다는 생각이 들었다.\nEXIF 표준의 MakerNote(Tag 0x927C)는 카메라 제조사가 자유롭게 사용할 수 있는 비표준 영역이다. 포맷이 제조사마다, 심지어 같은 제조사의 모델마다 다르고, 문서화도 빈약하다. 하지만 여기에는 \u0026ldquo;어떤 색감 설정으로 찍었는지\u0026rdquo; 같은, 사진가에게 중요한 정보가 숨어 있다.\nChama Optics에서는 exif.maker_note_vendor()로 제조사를 먼저 식별한 뒤, 각 제조사별 전용 파서로 분기한다.\nNikon — PictureControlData / PictureControlData2 태그에서 Picture Control 이름을 추출한다. \u0026quot;VitalityFilm_Pmango\u0026quot; 같은 사용자 정의 프로필명이나, \u0026quot;Flat\u0026quot;, \u0026quot;Vivid\u0026quot; 같은 프리셋 이름이 여기에 들어 있다.\nPanasonic (Lumix) — 가장 풍부한 데이터를 제공한다. PhotoStyleName에서 기본 Photo Style 이름(\u0026quot;NostalgicKintex\u0026quot;)을, LutPrimaryFile/LutSecondaryFile에서 적용된 LUT 파일명(\u0026quot;KintexYellow33.CUBE\u0026quot;)과 Gain 값까지 추출한다. 이 정보는 Chama Optics의 LUT 컬러 그레이딩 기능과 직접 연결된다.\nSony — Sony_0x9416 태그에서 Creative Style/Creative Look 정보(\u0026quot;Vivid\u0026quot;, \u0026quot;Standard\u0026quot;, \u0026quot;Portrait\u0026quot; 등)를 추출한다.\n이 MakerNote 파싱 기능은 기존 exif-rs에 없었기 때문에 직접 구현하여 PR #57로 제출했다.\nEXIF IFD 엔트리 구조와 MakerNote의 offset 문제 # MakerNote를 파싱하려면 먼저 EXIF의 IFD(Image File Directory) 구조를 이해해야 한다. EXIF 데이터는 TIFF 포맷을 기반으로 하며, 각 IFD 엔트리는 정확히 12바이트로 구성된다.\nTag (2바이트) — 필드 식별자 (예: 0x927C = MakerNote) Type (2바이트) — 데이터 타입 Count (4바이트) — 값의 개수 Value/Offset (4바이트) — 데이터가 4바이트 이하면 값 자체, 초과하면 데이터의 위치를 가리키는 offset 표준 EXIF에서 이 offset은 TIFF 헤더 시작점으로부터의 거리다. 단순명쾌하다. 그런데 MakerNote 내부의 IFD에서는 이 규칙이 무너진다.\n문제는 이것이다: MakerNote 내부에도 IFD와 동일한 구조의 엔트리들이 존재하는데, 여기서 offset이 \u0026ldquo;어디를 기준으로 한 거리인지\u0026quot;가 제조사마다 다르다.\nTIFF-Relative 방식 (Panasonic, Canon, Sony, Leica, Sigma) — MakerNote 안의 offset이 원본 TIFF 헤더 시작점 기준. MakerNote 자체에 TIFF 헤더가 없으며, offset에서 tiff_offset(TIFF 시작점부터 MakerNote까지의 거리)을 빼야 실제 데이터 위치를 찾을 수 있다. MakerNote-Relative 방식 (Nikon, Olympus, Fujifilm, Samsung, Apple, Pentax) — MakerNote 안의 offset이 MakerNote 시작점 기준. 자체적으로 완결된 구조(self-contained)이며, Nikon의 경우 MakerNote 안에 독자적인 TIFF 헤더까지 가지고 있다. 추가로 바이트 오더(엔디안)도 제조사별로 다르다. Nikon은 자체 TIFF 헤더에서, Olympus/Apple은 프로프라이어터리 헤더 내의 \u0026quot;II\u0026quot;/\u0026quot;MM\u0026quot; 바이트에서, Samsung은 IFD 태그 번호의 패턴으로 자동 판별한다.\n결국 10개 제조사(Panasonic, Nikon, Sony, Canon, Olympus, Fujifilm, Samsung, Apple, Sigma, Pentax)에 대해 각각의 헤더 포맷, offset 보정 공식, 바이트 오더 판별 로직을 구현하여, 총 23개 파일 약 5,900줄의 PR이 되었다.\n4. 카메라 제조사 로고 시스템: CSV → build.rs → 바이너리 임베딩 # Strap 테마, Film 테마 등에서 사진 프레임에 카메라 제조사 로고를 자동으로 삽입하려면 두 가지가 필요하다. (1) EXIF에서 제조사를 인식하는 것, (2) 해당 제조사의 SVG 로고를 렌더링하는 것.\n컴파일 타임: CSV에서 SVG 다운로드 \u0026amp; 임베딩 # 이전에 Rust Embedded 양산 프로젝트에서 const fn/const impl으로 컴파일 타임에 최대한 맡기는 접근과 build.rs를 활용한 빌드 스크립트 기법을 다룬 적이 있다. Chama Optics의 로고 시스템은 이 경험의 연장선에서 build.rs + include_bytes!()를 적극 활용한다.\nassets/logo_mnf.csv에 35개 제조사의 로고 정보가 정의되어 있다. cargo build가 실행되면 build.rs가 이 CSV를 읽어 다음을 수행한다.\nSVG 다운로드 — 각 행의 url 컬럼에서 SVG를 가져온다. Wikimedia Commons URL이면 HTTP로 다운로드하고, 로컬 경로(assets/logo_mnf/contax.svg)이면 직접 읽는다. 네트워크 실패 시 최대 3회, 5초 간격으로 재시도한다. MD5 해시 검증 — 다운로드된 파일의 MD5 해시를 CSV의 expected_md5 값과 비교한다. 파일이 이미 존재하고 해시가 일치하면 재다운로드를 건너뛴다. 해시가 불일치하면 panic!으로 빌드를 중단한다 — Wikimedia 측에서 SVG가 변경되었다면 의도적으로 확인해야 하기 때문이다. Rust 코드 생성 — assets/auto_generated/logo_assets.rs를 생성하며, 각 SVG를 include_bytes!()로 바이너리에 임베딩한다. 런타임에 파일 로딩이 필요 없다. // 자동 생성되는 코드 예시 pub const LOGO_ASSETS: \u0026amp;[ArtAsset] = \u0026amp;[ ArtAsset { key: \u0026#34;canon.svg\u0026#34;, data: include_bytes!(\u0026#34;.../assets/download/canon.svg\u0026#34;), color_type: ColorType::Color, mnf: \u0026#34;canon\u0026#34;, model: \u0026#34;\u0026#34;, mnf_model_rel: MnfRelation::Any, }, // ... 35개 제조사 ]; 런타임: EXIF → 로고 매칭 → SVG 래스터라이즈 # 사진이 로드되면 EXIF의 Tag::Make(제조사)와 Tag::Model(모델명)을 추출하고, LOGO_ASSETS 배열을 순회하며 매칭한다.\n매칭 규칙은 두 가지다.\nMnfRelation::Any — 제조사명 또는 모델명 중 하나만 일치하면 됨 (대부분의 경우) MnfRelation::Both — 제조사명 그리고 모델명 둘 다 일치해야 함 (특수한 경우) Both가 필요한 실제 사례: Sigma는 2025년에 로고를 변경했다. 새 로고를 사용하는 카메라는 SIGMA BF 모델뿐이므로, CSV에 mnf=\u0026quot;sigma\u0026quot;, model=\u0026quot;sigma bf\u0026quot;, mnf_model_rel=Both로 sigma2025.svg(신로고)를 등록하고, 나머지 Sigma 카메라는 mnf=\u0026quot;sigma\u0026quot;, mnf_model_rel=Any로 sigma.svg(구 로고)를 사용하도록 분리했다.\n매칭된 SVG는 usvg로 파싱 후 resvg+tiny-skia로 래스터라이즈하여, 프레임 내 적절한 위치와 크기로 합성된다. color_type(Black/Color)과 fill_ops(Default/Monochrome)에 따라 렌더링 방식이 달라져, 배경색에 맞는 로고 표현이 가능하다.\n5. CJK 폰트 렌더링과 가변 폰트(Variable Font) 최적화 # 일본어·한국어·중국어 텍스트를 이미지에 렌더링할 때 수많은 문제가 발생했다.\n일부 CJK 한자(ideograph)가 렌더링되지 않는 문제 가변 폰트에서 글리프 폭이 맞지 않는 문제 해결책으로 SourceHanSans를 빌트인 fallback 폰트로 내장하여, 선택한 폰트에서 지원하지 않는 글리프를 자동으로 대체 렌더링하도록 했다. 구체적으로는 텍스트를 문자 단위로 순회하면서, 주 폰트에서 GlyphId(0) (글리프 없음)이 반환되면 SourceHanSans fallback 폰트로 전환하여 렌더링한다.\n가변 폰트 weight 재매핑 # Chama Optics에서 사용하는 주 폰트인 BarlowGX.ttf는 가변 폰트(Variable Font)이지만, 내부 weight 축 값이 22~188이라는 비표준 범위를 사용하고 있었다. CSS 표준이나 FreeType 등에서 사용하는 100~900 범위와 맞지 않아, ab_glyph에서 set_variation(b\u0026quot;wght\u0026quot;, 400.0)으로 Regular weight를 지정해도 의도한 결과가 나오지 않았다. 추가로 기본 width가 wdth=300(Condensed)으로 설정되어 있어 글리프 폭도 맞지 않았다.\n단순히 fvar(Font Variations 메타데이터)만 수정하면 될 줄 알았지만, 실제 글리프 폭을 담고 있는 hmtx 테이블은 여전히 Condensed 기준이었다. 메타데이터만 바꾸면 렌더링 결과는 변하지 않는다. 결국 BarlowGX.ttf에서 9개 weight 인스턴스를 wdth=500(Regular width)으로 추출하고, 이를 마스터 소스로 사용하여 fontTools.varLib.build()로 가변 폰트를 통째로 재빌드하여 해결했다. 결과물이 Barlow-Variable-Remapped.ttf와 Barlow-Variable-Remapped-Narrow.ttf이다.\n여러 폰트 파일을 하나로 합치기 — 절대적인 파일 사이즈 축소 # 가변 폰트의 또 다른 장점은 여러 weight 파일을 하나로 합칠 수 있다는 점이다. 기존에 Barlow-Thin.ttf, Barlow-Light.ttf, Barlow-Regular.ttf, Barlow-Bold.ttf, Barlow-Black.ttf 등 9개 이상의 정적 폰트 파일이 필요했던 것을, 가변 폰트 하나로 대체할 수 있다.\nCJK 폰트도 마찬가지다. SourceHanSans(한일중 문자를 위한 최적의 선택)는 원래 weight별로 별도 파일이 제공되지만, 가변 폰트 버전(SourceHanSansVF)을 사용하면 하나의 파일로 200~800 범위의 weight를 모두 커버한다. 다만 이 폰트도 BarlowGX와 동일한 문제가 있어 weight 축을 표준 범위로 재매핑하여 SourceHanSansVF-remapped.otf를 생성했다.\n더 나아가 fontTools를 활용하여 서로 다른 문자 집합을 가진 폰트들을 하나로 병합하는 작업도 진행했다. 라틴 문자 폰트 + 일본어 폰트 + 한국어 폰트를 합쳐 하나의 파일로 만들 수 있으며, WOFF2 압축 해제, TTC(Font Collection) 처리, 특정 weight로 인스턴스 추출, UTF-8 기반 문자 서브셋팅 등을 조합하여 최종 파일 크기를 최소화했다.\n최종적으로 Chama Optics에 내장되는 폰트 파일은:\n폰트 정적 폰트 시 용량 가변 폰트 용량 절감 Barlow-Variable-Remapped.ttf (100~900) ~1.35 MB (9 weight) 385 KB ~3.5x Barlow-Variable-Remapped-Narrow.ttf (100~900) ~1.45 MB (9 weight) 207 KB ~7x SourceHanSansVF-remapped.otf (200~800) ~105 MB (7 weight) 30 MB ~3.5x DejaVuSansMono.ttf (정적) — 327 KB — digital-7.ttf (정적) — 34 KB — 합계 ~108 MB ~31 MB ~3.5x Barlow의 경우가 특히 극적이다. 원본 Barlow 프로젝트에는 9 weight × 3 width × 2 (upright+italic) = 54개 정적 TTF 파일이 있고 합계 8.5 MB인데, Chama Optics에서 필요한 normal + narrow 두 가변 폰트는 합쳐서 592 KB에 불과하다. 모바일 앱 번들 크기에 민감한 환경에서 이 차이는 결정적이다.\negui에서 가변 폰트 weight 선택 로딩 # 데스크탑 버전(egui)에서는 가변 폰트의 weight를 사용자가 자유롭게 조절할 수 있다. 핵심은 ab_glyph 크레이트의 set_variation API다.\npub struct VariableFontPack { pub label: \u0026amp;\u0026#39;static str, pub font: ab_glyph::FontRef\u0026lt;\u0026#39;static\u0026gt;, pub default: u16, // 기본 weight (예: 300) pub start: u16, // 최소 weight (예: 100) pub end_include: u16, // 최대 weight (예: 900) } impl VariableFontPack { pub fn get_font_by_weight(\u0026amp;self, weight: u16) -\u0026gt; ab_glyph::FontArc { let clamped = weight.clamp(self.start, self.end_include); let mut font = self.font.clone(); font.set_variation(b\u0026#34;wght\u0026#34;, clamped as f32); font.into() } } 사용자가 테마 설정에서 weight 슬라이더를 조절하면, 해당 weight 값으로 set_variation(b\u0026quot;wght\u0026quot;, weight)를 호출하여 런타임에 폰트의 굵기가 변경된다. 100(Thin)부터 900(Black)까지 연속적인 값을 지정할 수 있으며, 350이나 450 같은 중간값도 보간(interpolation)되어 부드러운 weight 전환이 가능하다.\n이 로직은 데스크탑뿐 아니라 iOS/Android에서도 동일하게 동작한다. iOS에서는 FontSelectionView에서 가변 폰트인 경우에만 weight 슬라이더를 표시하고, 선택된 weight 값을 FFI를 통해 Rust 코어에 전달한다. Android에서도 Kotlin에서 fontWeight 파라미터로 Rust FFI에 전달하는 동일한 구조다.\nCJK fallback도 weight를 반영한다. 주 폰트가 Barlow weight 700(Bold)이고 CJK 문자가 나오면, SourceHanSans도 700에 가까운 weight로 렌더링하여 라틴 문자와 CJK 문자의 굵기가 일관되게 보이도록 했다.\n빌트인 폰트와 시스템 폰트 # Chama Optics에서 사용하는 폰트는 두 종류로 나뉜다. 빌트인(builtin) 폰트와 시스템(OS) 폰트.\n빌트인 폰트는 앱에 기본 내장되는 폰트로, Barlow(라틴), SourceHanSans(CJK fallback), D2Coding(모노스페이스), Digital-7(Segment Display 스타일) 등이 있다. 시스템 폰트는 사용자의 OS에 설치된 폰트를 가져와서 테마에 적용할 수 있도록 하는 기능이다. EXIF 프레임에 표시되는 텍스트의 폰트를 사용자가 자유롭게 선택할 수 있어야 하기 때문에, 빌트인 폰트만으로는 부족하다.\n데스크탑에서는 include_bytes!로 폰트를 바이너리에 내장한다.\npub(crate) const FONT_BARLOW: BuiltInFonts = BuiltInFonts { name: \u0026#34;Barlow\u0026#34;, data: include_bytes!(\u0026#34;../../assets/fonts/Barlow-Variable-Remapped.ttf\u0026#34;), }; 데스크탑은 실행 파일 하나로 배포하는 것이 편리하기 때문에, 폰트 파일을 컴파일 시점에 바이너리에 포함시킨다. 별도의 폰트 디렉토리 없이 실행 파일만 있으면 바로 동작한다.\n반면 iOS/Android에서는 폰트를 파일 경로로 동적 로딩한다. 모바일 앱은 바이너리 크기에 민감하고, 앱 번들 내에 리소스 파일로 분리하는 것이 플랫폼 관례이기도 하다. Swift/Kotlin에서 FFI를 통해 폰트 디렉토리 경로를 Rust 코어에 전달하면, Rust 쪽에서 std::fs::read()로 필요한 시점에 파일을 읽어 로딩한다.\n시스템 폰트는 데스크탑에서만 지원한다. font-kit 크레이트의 SystemSource를 사용하여 OS에 설치된 폰트 목록을 열거하고, 사용자가 선택한 폰트를 로드한다. 이 작업은 UI를 블로킹하지 않도록 백그라운드 스레드에서 수행되며, Arc\u0026lt;RwLock\u0026lt;Vec\u0026lt;SystemFont\u0026gt;\u0026gt;\u0026gt;로 스레드 안전하게 공유한다.\nfont-kit macOS 메모리 폭주 디버깅 # 시스템 폰트 열거를 구현한 뒤 macOS에서 심각한 문제가 발생했다. 앱 실행 직후 메모리 사용량이 1.0GB, 피크 1.5GB까지 치솟는 현상이었다. (#5)\nMallocStackLogging과 malloc_history로 추적한 결과, 원인은 font-kit의 macOS 백엔드(core_text)에 있었다. font_kit::SystemSource::all_fonts()가 시스템 폰트 목록을 열거하면서, 각 폰트의 전체 파일 데이터를 메모리에 읽어들이고 있었다:\n435 calls for 2045941700 bytes: ← 약 2GB font_kit::sources::core_text::create_handles_from_core_text_collection font_kit::utils::slurp_file ← 폰트 파일 전체를 메모리로 읽음 alloc::raw_vec::RawVecInner::try_allocate_in macOS에는 수백 개의 시스템 폰트가 설치되어 있고, CJK 폰트(예: Apple SD Gothic Neo, Hiragino 등)는 개별 파일이 수십 MB에 달한다. slurp_file이 이 파일들을 전부 메모리에 올리면서 435개 폰트에 대해 약 2GB를 할당한 것이다. (Windows에서는 동일 코드에서 약 90MB 수준이었다.)\n해결 방법은 font-kit를 포크하여 all_fonts() 호출 시 폰트 데이터를 읽지 않고 메타데이터(이름, 경로)만 수집하도록 수정하는 것이었다. 수정 후 메모리 사용량은 144.9MB(피크 389.4MB)로 대폭 감소했다.\n6. LUT 컬러 그레이딩: wagahai-lut의 최적화 철학 # 라이브러리 이름의 유래는 wagahaida_L(라플라스 다크니스)의 트윗에서 따왔다.\nLaplusDarknesss wagahaida_L pic.twitter.com/dKCBGYJobj\n\u0026mdash; ラプラス・ダークネス🛸💜 (@LaplusDarknesss) July 1, 2025 https://t.co/WjplefTDWX pic.twitter.com/8L19fSqYBg\n\u0026mdash; ラプ様 (@wagahaida_L) November 24, 2025 여담으로 v0.2.0에서 준비 중인 체키풍(폴라로이드) 이미지 자동 생성 기능 또한 라플라스 다크니스에게서 아이디어를 얻었다. 요망하게 머리가 좋다고 생각한다.\nv0.1.9에서 추가된 LUT 컬러 그레이딩 기능은 직접 개발한 wagahai-lut (crates.io) 라이브러리를 사용한다.\nCUBE LUT이란? # CUBE LUT(Look-Up Table)은 Adobe가 정의한 .cube 파일 포맷으로, 색상 변환 정보를 담고 있다. 1D LUT과 3D LUT 두 종류가 있다.\n1D LUT은 R, G, B 각 채널을 독립적으로 변환한다. 입력값을 테이블에서 찾아 출력값으로 바꾸는 단순한 구조다. 밝기/대비 조정에 적합하지만, 채널 간 상호작용(예: 빨간색을 파란색으로 바꾸는 것)은 불가능하다. 테이블 크기는 보통 1,024(10-bit)에서 65,536(16-bit)개 엔트리이며, 인접한 두 엔트리 사이의 값은 선형 보간(linear interpolation)으로 계산한다.\n3D LUT은 RGB 3차원 색상 공간 전체를 매핑한다. 입력 (R, G, B)가 완전히 다른 (R\u0026rsquo;, G\u0026rsquo;, B\u0026rsquo;)로 변환될 수 있어, 영화/사진의 크리에이티브 색감 보정(film look, color grading)에 사용된다. 큐브 내부의 격자점(lattice point)이 알려진 매핑을 정의하고, 격자점 사이의 값은 주변 8개 꼭짓점으로부터 삼선형 보간(trilinear interpolation)으로 계산한다. 일반적인 크기는 17³(4,913점), 33³(35,937점), 65³(274,625점)이다.\nwagahai-lut의 최적화 전략 # 기존 Rust LUT 라이브러리들은 범용성에 초점이 맞춰져 있었다. wagahai-lut은 \u0026ldquo;24MP 사진 수십 장을 일괄 처리해도 빨라야 한다\u0026quot;는 Chama Optics의 요구사항에 맞춰, 메모리 레이아웃부터 SIMD 수준까지 최적화했다. 다만 x86_64와 ARM64 양쪽을 모두 지원해야 하므로 직접 어셈블리를 작성하는 대신 wide 크레이트를 사용하여 아키텍처에 구애받지 않는 보편적인 벡터 최적화를 택했다.\n1) Structure of Arrays (SoA) 메모리 레이아웃\n일반적인 3D LUT 구현은 [Rgb, Rgb, Rgb, ...] 형태의 AoS(Array of Structures) 레이아웃을 사용한다. 하지만 삼선형 보간은 한 번에 한 채널씩 8개 꼭짓점 값을 읽어야 하므로, AoS에서는 캐시 라인에 불필요한 채널 데이터가 함께 로드된다.\nwagahai-lut은 3D LUT을 r: Vec\u0026lt;f32\u0026gt;, g: Vec\u0026lt;f32\u0026gt;, b: Vec\u0026lt;f32\u0026gt; 세 개의 분리된 배열로 저장한다. 이 SoA 레이아웃 덕분에 한 채널의 보간에 필요한 8개 값이 메모리상 가까이 위치하여 CPU 캐시 적중률이 높아진다.\n2) SIMD 병렬 처리 (wide::f32x4)\n1D LUT 처리에서는 wide 크레이트의 f32x4 SIMD 벡터를 사용하여 R, G, B 세 채널의 선형 보간을 단일 벡터 연산으로 수행한다. 4개 레인 중 3개를 R, G, B에 할당하고, 곱셈·덧셈이 한 번의 명령어로 처리된다.\n3) 고정 크기 특수화 (Fixed-Size Specialization)\n1D LUT은 Bit10(1024), Bit12(4096), Bit14(16384), Bit16(65536) 등 일반적인 크기에 대해 Box\u0026lt;[Rgb; SIZE]\u0026gt; 고정 크기 배열을 사용한다. 컴파일 타임에 크기가 결정되므로 경계 검사(bounds checking)를 건너뛰고 get_unchecked()로 직접 접근이 가능하다. 3D LUT도 17³, 33³, 65³ 같은 일반적인 크기를 별도 타입으로 제공한다.\n4) In-Place 처리와 루프 최적화\napply_rgb_mut() / apply_rgba_mut() 함수는 이미지 버퍼를 제자리에서(in-place) 수정하여 추가 메모리 할당이 전혀 없다. 핫 루프에서는 도메인 범위의 역수(inv_domain_range)를 루프 밖에서 미리 계산하고, 원시 포인터(raw pointer) 연산으로 get_pixel()/put_pixel() 호출 오버헤드를 제거하며, 바이트 슬라이스를 선형으로 순회하여 CPU 캐시 프리페치를 극대화한다.\n벤치마크 결과 # M4 Max(Stable Rust) 기준 처리 시간 (JPEG 디코딩/인코딩 시간 포함):\n해상도 1D LUT 3D LUT 1920×1080 (FHD) 14.39 ms 19.40 ms 6000×4000 (24MP) 159.91 ms 223.15 ms 8144×5424 (44MP) 294.34 ms 417.09 ms 24MP 사진 기준 3D LUT 적용이 약 0.22초로, Chama Optics에서 수십 장의 사진을 일괄 처리할 때 Rayon 병렬화와 결합하면 실용적인 속도를 달성할 수 있다.\n7. 데스크탑 얼굴 인식: Speed Mode와 슬라이딩 윈도우 알고리즘 # 데스크탑에서는 ONNX Runtime + InsightFace(det_10g) 모델을 사용한다. 이 모델의 입력 크기는 고정 640×640 픽셀이다. 하지만 실제 사진은 24MP(6000×4000) 이상인 경우가 대부분이고, 640×640으로 전체 이미지를 축소하면 인물이 작게 촬영된 단체 사진에서는 얼굴을 놓치게 된다.\n이 문제를 해결하기 위해 Speed Mode에 따른 다단계 슬라이딩 윈도우 알고리즘을 구현했다.\n먼저, 이미지의 짧은 변을 기준으로 피라미드 최대 깊이 m_max 를 동적 계산한다.\nm_max = floor(log2(min_side × 0.9 / 640)) 각 depth에서의 윈도우 크기는 다음과 같다.\ndepth 0 → window = 640 × 2^(m_max) ← 가장 큰 윈도우 depth 1 → window = 640 × 2^(m_max - 1) ... depth m_max → window = 640 ← 가장 작은 윈도우 Speed Mode는 이 피라미드에서 실제 탐색하는 깊이 수(num_levels) 를 제한한다.\n모드 num_levels 전체 동작 Fastest 0 전체 이미지 → 640×640 리사이즈 → 단일 추론 Fast 0 + 짧은변(min(W,H)) 크기 정사각 슬라이딩 윈도우 Normal min(1, m_max+1) + 피라미드 depth 0 (가장 큰 윈도우) Slow min(2, m_max+1) + 피라미드 depth 0..1 Slowest min(3, m_max+1) + 피라미드 depth 0..2 Slowest + ILC m_max+1 + 피라미드 전체 (640px 베이스까지) ILC 카메라 확장: Slowest 모드에서 EXIF Make가 전문 ILC 브랜드(Panasonic, Sony, Canon, Sigma, Fuji, Hasselblad, Nikon, Leica)와 일치하면 num_levels = m_max + 1로 확장하여 640px 베이스 윈도우까지 탐색한다. 고해상도 ILC 사진에서 먼 거리의 작은 얼굴까지 빠짐없이 검출하기 위한 확장이다.\n아래 표는 카메라별 실제 예시다.\n카메라 min_side m_max Normal Slow Slowest Slowest+ILC S5M2 4000 2 2560 2560, 1280 2560, 1280, 640 (동일) S1R 5424 2 2560 2560, 1280 2560, 1280, 640 (동일) A7R5 6336 3 5120 5120, 2560 5120, 2560, 1280 +640 알고리즘의 흐름은 다음과 같다.\n1단계 (공통): 전체 이미지를 640×640으로 리사이즈하여 단일 추론. 큰 얼굴은 이 단계에서 잡힌다. 2단계 (Fast 이상): 이미지의 짧은 변(min(width, height)) 크기의 정사각 슬라이딩 윈도우를 10% 겹침으로 이동시키며 각 윈도우를 640×640으로 축소하여 추론. 비정상적인 종횡비(파노라마 등)에서의 누락을 방지. 3단계 (Normal 이상): 640 × 2^(m_max - depth) 크기의 윈도우를 depth별로 순회. 큰 윈도우부터 작은 윈도우 순으로 점진적 세밀화. 최종: NMS(Non-Maximum Suppression, IoU 임계값 0.4)로 중복 감지 제거. 각 Speed Mode의 동작을 시각화한 다이어그램 (6000×4000 원본 이미지 기준):\nFastest # Fast # Normal # Slow # Slowest # 아래는 Slowest 모드로 처리한 실제 행사 사진 예시다. 대규모 단체 사진에서 뒷줄 구석의 작은 얼굴까지 빠짐없이 검출하여 모자이크 처리한 결과물이다.\n2025년 AGF 아마네 카나타 팬 단체 사진회\n각 모드의 사용 시나리오:\n모드 평균 소요 시간 적합한 상황 Fastest ~0.5초 1~2명 인물 사진 Fast ~0.6초 파노라마 등 비정상 종횡비의 1~2명 사진 Normal ~7초 약 10명 정도의 단체 사진 Slow ~13초 40~50명 규모의 단체 사진 Slowest ~28초 50명 이상의 대규모 단체 사진 Fastest가 전체를 640×640 하나로 축소하여 ~0.5초만에 끝나는 반면, Slowest는 2560/1280/640 세 단계의 윈도우를 겹치며 탐색하기 때문에 ~28초가 걸린다. 하지만 행사장 단체 사진에서 뒷줄 구석의 작은 얼굴까지 잡아내려면 이 정도의 탐색이 필요하다.\n실행 환경(Execution Provider)도 플랫폼별로 최적화되어 있다.\nmacOS: CoreML Execution Provider 자동 선택 — Apple의 Neural Engine/GPU 가속 활용 Windows/Linux: CPU 또는 OnnxAuto (자동 감지) macOS에서는 사용자가 CPU를 선택하더라도 내부적으로 CoreML로 자동 전환되어 Apple Silicon의 Neural Engine을 활용한다. 이는 CPU 대비 수 배의 성능 향상을 가져온다.\niOS에서는 슬라이딩 윈도우 알고리즘 구조(Fastest/Fast/피라미드 깊이)는 데스크탑과 동일하지만, 추론 엔진으로 InsightFace ONNX 대신 **Apple Vision Framework(VNDetectFaceRectanglesRequest)**를 사용한다. Vision이 내부적으로 스케일링을 처리하므로 640×640 리사이즈 단계가 불필요하며, ONNX 모델 없이도 정확한 얼굴 인식이 가능하다.\n한편 Android에서는 Google ML Kit (com.google.mlkit:face-detection)를 사용하며, 다단계 누적 구조로 동작한다.\nPass 1 (모든 속도): 전체 이미지를 최대 1024px로 디코드, PERFORMANCE_MODE_FAST, minFaceSize=0.2 Pass 2 (Fast 이상): Pass 1의 1024px 비트맵에서 min(w,h) 크기 정사각 윈도우를 10% 겹침으로 슬라이딩 Pass 3+ (Normal 이상): 피라미드 멀티레벨 디코드 — base = floor(min(minSide/2, maxSide/3) × 1.1) 기준으로 Normal은 L0, Slow는 L0–L1, Slowest는 L0–L2까지 PERFORMANCE_MODE_ACCURATE, minFaceSize=0.1로 탐색 모든 Pass 결과를 NMS(IoU 0.4)로 병합하여 중복 제거 8. iOS 네이티브 통합 # iOS 앱은 단순히 Rust 코어를 감싸는 것이 아니라, 플랫폼의 장점을 최대한 활용했다.\nApple Vision Framework (VisionKit) — VNDetectFaceRectanglesRequest 기반 슬라이딩 윈도우 얼굴 인식. 데스크탑과 동일한 Fastest/Fast/피라미드 depth 구조를 사용하되, ONNX 모델 없이 Vision이 스케일링과 추론을 직접 처리 PhotosUI — iOS 사진 라이브러리에서 직접 이미지 선택 Metal 렌더링 — GPU 가속 이미지 처리 iPad 지원 — 넓은 화면에 최적화된 레이아웃 9. MPF 및 내장 프리뷰 이미지 추출 # JPEG 파일 안에 숨어 있는 서브 이미지를 추출하는 기능은 Chama Optics의 성능에 결정적인 역할을 한다. 이 기능은 exif-rs PR #58 (+1,364줄, PR #57 기반)로 구현했다.\nJPEG 안에 숨어 있는 이미지들 # JPEG 파일 하나 안에는 실제로 여러 개의 이미지가 들어 있을 수 있다.\nJPEG 안에 내장된 이미지는 크게 세 가지 소스에서 추출할 수 있다.\nEXIF IFD(1) 썸네일 — 표준 EXIF 썸네일 (보통 160×120) APP2 세그먼트 (MPF) — CIPA DC-007 표준에 정의된 Multi-Picture Format. 메인 EOI 이후에 별도의 완전한 JPEG 스트림으로 저장된다. MakerNote 내부 프리뷰 — 제조사별 비표준 프리뷰 이미지 왜 MPF 프리뷰가 중요한가: 메모리와 성능 # 사진 목록에서 썸네일을 보여줄 때, 가장 단순한 방법은 원본 이미지를 로드한 뒤 리사이즈하는 것이다. 하지만 이건 끔찍하게 비효율적이다.\n방식 메모리 사용 처리 시간 원본(24MP) 로드 → 리사이즈 ~72MB (24M × 3bytes) 느림 IFD(1) 썸네일 사용 ~76KB (160×120) 빠름, 하지만 너무 작아서 흐림 MPF 프리뷰(~2MP) 사용 ~8MB 빠르고, 시각적으로 충분 IFD(1)의 썸네일은 너무 작아서 목록용으로는 괜찮지만 미리보기용으로는 흐릿하다. 원본을 로드하면 24MP 이미지가 메모리에 72MB를 차지하고 디코딩 시간도 오래 걸린다. **MPF에 포함된 12MP 프리뷰 이미지**는 이 둘 사이의 달콤한 지점이다 — 시각적으로 충분히 선명하면서도 메모리와 CPU 오버헤드가 원본의 1/10 이하다.\n특히 Chama Optics처럼 수십 장의 사진을 동시에 리스트로 보여주고, 테마 미리보기까지 제공해야 하는 프로그램에서는 이 차이가 결정적이다. 50장의 24MP 사진을 원본으로 로드하면 ~3.6GB, MPF 프리뷰로 로드하면 ~400MB — 약 9배의 차이다.\n기존 exif-rs 사용자에게 영향을 주지 않기 위해 mpf feature flag로 제공하도록 하였다.\n10. HEIF/HEIC 디코더: 플랫폼별 전략 # 최근 JPEG 외에 HEIF(High Efficiency Image Format)로 사진을 저장하는 기기가 늘고 있다. 특히 iOS는 촬영 시 HEIF를 기본으로 사용하며, 사진을 외부로 전달할 때 JPEG로 변환할지 HEIF 그대로 줄지를 OS가 자체적으로 판단한다 — 앱에서 이를 통제하기가 쉽지 않다. 일부 미러리스 카메라(Sony, Canon 등)도 HEIF 촬영을 지원하기 시작했다. 호환성 때문에 JPEG만 쓰는 사용자도 있지만, HEIF로 들어오는 파일을 처리하지 못하면 사진 앱으로서 치명적이다. 문제는 HEIF 디코딩 지원이 플랫폼마다 크게 다르다는 점이다.\nChama Optics는 가능한 한 OS 네이티브 디코더를 사용하고, 네이티브 지원이 없는 플랫폼에서만 libheif를 사용하는 전략을 택했다.\niOS/macOS — Apple의 ImageIO 프레임워크가 HEIF를 네이티브로 지원한다. 별도의 외부 라이브러리 없이 OS API만으로 디코딩이 가능하다. iOS에서는 Swift 앱 레이어에서 디코딩한 픽셀 버퍼를 C FFI로 Rust에 전달하고, macOS에서는 Rust가 직접 macOS API 바인딩을 통해 호출한다.\nAndroid — API 26(Android 8.0) 이상에서 BitmapFactory와 MediaCodec이 HEIF를 네이티브로 지원한다. Kotlin 앱에서 디코딩한 뒤 JNA를 통해 Rust에 전달한다.\nWindows/Linux — 네이티브 HEIF 디코더가 없거나 제한적이다. 이 경우 libheif_rs(libheif의 Rust 바인딩)를 사용한다. C FFI는 libheif_rs가 내부적으로 처리하므로 Rust 코드에서는 안전한 API만 호출하면 된다. libheif는 내부적으로 libde265(HEVC 디코더)와 libaom(AV1/AVIF)을 사용한다.\n이 전략의 핵심은 #[cfg(target_os)] 조건부 컴파일이다. 네이티브 디코더가 있는 플랫폼에서는 외부 의존성 없이 최적의 성능을 얻고, libheif_rs가 필요한 플랫폼에서만 링킹한다. 결과적으로 macOS 빌드에서는 libheif 관련 코드가 아예 컴파일되지 않는다.\n11. 테마 파라미터 시스템: Rust → JSON → 플랫폼별 UI # Chama Optics의 테마에는 40개 이상의 설정 파라미터가 있다 — 폰트 weight, 워터마크 위치·투명도, 프레임 스타일, 로고 표시 여부, 색상, 여백 등. 이 파라미터들이 데스크탑과 모바일에서 동일한 결과를 보장해야 한다는 것이 핵심 요구사항이었다.\n데스크탑(egui)에서는 Rust 구조체를 직접 참조하여 UI 위젯을 그린다. Slider::new(\u0026amp;mut config.font_weight, 100..=900) 같은 코드로 구조체 필드가 곧 UI 상태가 된다 — JSON 직렬화도, 중간 변환도 없다.\n문제는 모바일이다. iOS(SwiftUI)와 Android(Jetpack Compose)는 Rust 구조체에 직접 접근할 수 없다. 40개 이상의 파라미터 각각에 대해 Swift/Kotlin 쪽에서 수동으로 UI를 만들고, FFI로 값을 주고받는 코드를 일일이 작성한다면? 파라미터가 하나 추가될 때마다 Rust, Swift, Kotlin 세 곳을 동시에 수정해야 한다.\n이 문제를 proc_macro로 해결했다. Rust 구조체 정의에 #[derive(ThemeParam)]을 붙이면, 컴파일 타임에 다음이 자동 생성된다.\nJSON 스키마: 각 필드의 UI 타입(슬라이더, 토글, enum 선택, 색상 피커 등), 범위, 기본값을 포함하는 JSON FFI 함수: get_param_json(), set_param() 등 모바일에서 호출할 수 있는 C ABI 함수 역직렬화 로직: JSON으로 받은 값을 Rust 구조체에 반영하는 코드 모바일 앱은 이 JSON을 파싱하여 네이티브 UI 요소를 동적으로 생성한다. \u0026quot;type\u0026quot;: \u0026quot;slider\u0026quot; → SwiftUI의 Slider, Jetpack Compose의 Slider(). \u0026quot;type\u0026quot;: \u0026quot;toggle\u0026quot; → Toggle / Switch. 사용자가 값을 변경하면 FFI를 통해 Rust 코어에 전달되고, Rust 코어는 동일한 렌더링 파이프라인으로 결과를 반환한다.\n결과적으로 Rust 구조체 하나가 UI 명세이자 데이터 모델이자 직렬화 포맷의 역할을 동시에 한다. 새 파라미터를 추가할 때 Rust에 필드 하나를 추가하고 어트리뷰트로 UI 힌트를 달면, proc_macro가 JSON 스키마를 갱신하고, 모바일 앱은 다음 빌드에서 자동으로 해당 UI를 표시한다. Swift/Kotlin 코드를 수정할 필요가 없다.\n임베디드에서의 build.rs 남발과 const fn 집착이 이런 식으로 응용되었다. 솔직히 proc_macro로 하는 것이 깔끔한지는 모르겠다 — 본인도 \u0026ldquo;괴랄하다\u0026quot;고 생각하는 부분이다. 하지만 40개 이상의 파라미터를 3개 플랫폼에서 수동 동기화하는 것보다는 확실히 낫다. Rust의 절차형 매크로(procedural macro)에 대해 더 알고 싶다면 이 글이 좋은 참고가 된다.\n12. 다국어 번역 시스템: YAML 하나로 3개 플랫폼 번역 자동 생성 # 4개 언어(영어, 한국어, 일본어, 인도네시아어)를 지원하면서 번역 문자열이 3개 플랫폼에서 동기화되어야 한다. 번역 키 하나를 추가하거나 문구를 수정할 때마다 iOS의 .strings, Android의 strings.xml, 데스크탑의 Rust 코드를 각각 손으로 고쳐야 한다면? 결국 빠뜨리거나 어긋나게 된다.\n해결 방식은 단순하다. rust-core의 YAML 파일을 유일한 원본으로 두고, 빌드 시점에 각 플랫폼 포맷으로 자동 변환하는 것이다.\nYAML: 번역의 원본 # rust-core/locales/ 디렉토리에 23개의 YAML 파일이 있다. common.yml, gallery.yml, theme.yml, face_detection.yml 등 기능 단위로 분리되어 있으며, 총 약 3,900줄이다.\n# rust-core/locales/gallery.yml gallery: empty_state_title: en: \u0026#34;No Images Yet\u0026#34; ko: \u0026#34;이미지 없음\u0026#34; ja: \u0026#34;画像がありません\u0026#34; id: \u0026#34;Belum Ada Gambar\u0026#34; 이 구조는 rust_i18n 크레이트가 요구하는 형식 그대로다. 데스크탑에서는 rust_i18n::i18n!(\u0026quot;locales\u0026quot;)로 컴파일 타임에 YAML을 임베딩하고, t!(\u0026quot;gallery.empty_state_title\u0026quot;)로 호출한다. 별도의 변환이 필요 없다. build.rs에서 cargo:rerun-if-changed=locales를 선언해두었으므로, YAML이 수정되면 자동으로 재컴파일된다.\n문제는 iOS와 Android다.\niOS: generate_ios_strings.sh # iOS는 NSLocalizedString과 .strings 파일을 사용한다. generate_ios_strings.sh는 Python3 + PyYAML로 YAML을 파싱하여, 각 로케일별 Localizable.strings를 생성한다.\n# build_ios.sh 에서 자동 호출 ./generate_ios_strings.sh YAML의 계층 구조를 점(.) 표기법으로 평탄화하여 .strings 포맷으로 변환한다.\n/* Auto-generated from rust-core/locales - DO NOT EDIT */ \u0026#34;gallery.empty_state_title\u0026#34; = \u0026#34;이미지 없음\u0026#34;; \u0026#34;common.actions.save\u0026#34; = \u0026#34;저장\u0026#34;; iOS 고유의 요구사항도 있었다. 같은 키라도 iOS에서는 다른 문구를 사용해야 하는 경우가 있다 — 예를 들어 데스크탑에서 \u0026ldquo;파일 불러오기\u0026quot;라고 쓰는 곳을 iOS에서는 \u0026ldquo;사진 선택\u0026quot;이라고 써야 자연스럽다. 이를 위해 _ios 접미어 오버라이드를 구현했다. YAML에서 import.label_ios가 정의되어 있으면 iOS 빌드에서는 import.label 대신 이 값을 사용한다. 데스크탑과 Android에는 영향을 주지 않는다.\n이 스크립트는 build_ios.sh에서 Rust 크로스 컴파일 전에 자동으로 호출되므로, YAML을 수정하고 Xcode 빌드를 돌리면 번역이 자동 반영된다.\nAndroid: generate_android_strings.sh # Android는 strings.xml과 R.string.* 리소스 시스템을 사용한다. 핵심적인 차이가 두 가지 있다.\n첫째, 키 포맷이 다르다. Android 리소스 이름에는 점(.)을 사용할 수 없다. YAML의 gallery.empty_state_title을 Android에서는 gallery_empty_state_title로 변환해야 한다.\ndef yml_key_to_android_key(yml_key): return yml_key.replace(\u0026#39;.\u0026#39;, \u0026#39;_\u0026#39;) 둘째, 로케일 디렉토리 규칙이 다르다. Android는 인도네시아어를 id가 아닌 in으로 표기한다 — values-in/strings.xml. 이 매핑을 스크립트에서 처리한다.\nANDROID_LOCALE_MAP[\u0026#34;en\u0026#34;]=\u0026#34;values\u0026#34; ANDROID_LOCALE_MAP[\u0026#34;ko\u0026#34;]=\u0026#34;values-ko\u0026#34; ANDROID_LOCALE_MAP[\u0026#34;ja\u0026#34;]=\u0026#34;values-ja\u0026#34; ANDROID_LOCALE_MAP[\u0026#34;id\u0026#34;]=\u0026#34;values-in\u0026#34; # Android uses \u0026#34;in\u0026#34; for Indonesian iOS 스크립트와 또 다른 점은 diff 기반 동기화라는 것이다. iOS는 매번 파일을 통째로 덮어쓰지만, Android 스크립트는 기존 strings.xml에 이미 있는 키는 건드리지 않고 누락된 키만 추가한다. Android 쪽에서 수동으로 관리하는 엔트리(앱 이름 등)를 보존하기 위해서다. --check 모드로 실행하면 파일을 수정하지 않고 누락된 번역만 보고한다.\nAndroid에서 이 키들을 실제로 사용할 때는 ThemeI18n.kt에서 YAML 점 표기법 키를 R.string.* 리소스 ID로 매핑한다.\nobject ThemeI18n { fun translate(context: Context, key: String): String { val resourceId = keyToResourceId(key) return if (resourceId != 0) context.getString(resourceId) else key } } 세 플랫폼의 키 변환 비교 # 요소Desktop (Rust)iOS (Swift)Android (Kotlin) 원본t!(\"gallery.empty_state_title\")NSLocalizedString(\"gallery.empty_state_title\")R.string.gallery_empty_state_title 키 구분자. (점). (점)_ (밑줄) 생성 방식컴파일 타임 임베딩빌드 스크립트 자동 생성빌드 스크립트 diff 동기화 플랫폼 오버라이드—_ios 접미어— 인도네시아어 코드ididin 이 구조 덕분에 번역을 추가하거나 수정할 때 YAML 파일 하나만 고치면 세 플랫폼 모두에 반영된다. 23개 YAML 파일, 4개 언어, 3개 플랫폼을 수동으로 동기화하는 것은 현실적으로 불가능하다 — 내가 생각한 방법은 자동화뿐이었다.\n오픈소스 기여 활동 # Chama Optics 개발 과정에서 의존하는 오픈소스 프로젝트들에도 적극적으로 기여했다.\n프로젝트 기여 내용 exif-rs MakerNote 파싱 — 10개 제조사 지원 (PR #57, +5,946 lines) exif-rs MPF 및 내장 프리뷰 이미지 추출 (PR #58, +1,364 lines) exif-rs TIFF field 접근 개선 (PR #51, approved) font-kit macOS 시스템 폰트 열거 시 메모리 폭주 수정 (PR #271) egui variable font 로드 시 main weight 설정 기능 개선 (PR #7790, approved) wagahai-lut 1D/3D LUT 컬러 그레이딩 라이브러리 (crates.io) 릴리즈 요약 # 버전 날짜 주요 변경사항 v0.1.0 2025-10-19 첫 프리릴리즈, macOS/Windows, Film 테마 v0.1.1 2025-10-19 일본어 번역, 일괄 저장, 접두어/접미어 v0.1.2 2025-10-27 Glow 효과, Film Date/Glow 테마 v0.1.3 2025-11-03 워터마크(9곳 위치), 폰트 선택 v0.1.4~5 2025-11-05~12 Just Frame, Strap 테마, 카메라 로고 v0.1.6 2025-11-24 Monitor, Lightroom 테마, Longside 스케일 v0.1.7 2025-12-19 One/Two Line, Shot On 테마, CJK 수정, PhotoStyle v0.1.8 2025-12-27 탭 UI, 그룹화, 테마 미리보기, 멀티코어 v0.1.9 2026-02-04 얼굴 인식, LUT 컬러 그레이딩, iOS TestFlight 첫 배포 AI와 함께하는 프로그래밍 (바이브 코딩?) # 처음에는 AI 코딩에 대해서 회의적이었다.\n그래서 데스크탑 버전의 대다수는 아직도 내 손코딩 + cargo fmt/clippy/check에 의존하고 있다. Rust Embedded에서의 습관인 const 남발을 데스크탑에서도 적용하려는 내 의도를 AI(Claude)는 여전히 제대로 파악하지 못하고 있다.\n하지만 모바일용을 개발하면서 혼자서 이걸 다 하는 건 미친 짓이라고 생각했다. 기존 데스크탑 버전과 동일한 결과를 모바일에서 제공하는 것이 우선 사항이었고, 네이티브 API와 Rust FFI를 직접 호출하는 형태가 많을 것으로 예상되었다.\n그러던 참에 친구 결혼식 청첩장 모임을 가면서, 같이 차를 타고 있던 친구가 \u0026ldquo;Flutter에서 iOS 26에서 현재 Liquid UI가 제대로 안 돼\u0026ldquo;라는 말을 했다. 개발하더라도 네이티브로만 개발해야겠다는 생각이 굳어졌고, 동시에 AI에게 모바일용 코드를 맡기기로 결정했다.\n결과적으로 Rust 코어는 내가 직접, 모바일 UI(SwiftUI/Jetpack Compose)와 FFI 브리지는 AI와 함께 작성하는 분업 체제가 만들어졌다. Rust 쪽은 내가 의도한 패턴과 스타일이 있어서 AI가 잘 맞추지 못하지만, Swift/Kotlin처럼 내가 잘 모르는 언어로 플랫폼 네이티브 코드를 작성하는 데에는 AI가 큰 도움이 되었다.\n이 경험을 하고 나니, Flutter 같은 크로스플랫폼 프레임워크의 위치에 대해 생각하게 되었다. 물론 Flutter나 React Native가 해결하는 문제 — 하나의 코드베이스로 여러 플랫폼을 커버하는 것 — 는 여전히 유효하다. 하지만 AI가 각 플랫폼의 네이티브 코드를 충분히 잘 작성해줄 수 있는 시대가 되면, \u0026ldquo;네이티브를 몰라서 크로스플랫폼을 선택한다\u0026quot;는 동기는 점점 약해질 수 있다. 모바일 개발을 전혀 몰랐던 내가 AI의 도움만으로 SwiftUI와 Jetpack Compose를 각각 네이티브로 작성할 수 있었다는 사실이, 그 가능성을 보여주는 하나의 사례가 아닐까 싶다.\n앞으로의 계획 # v0.1.9를 기점으로 데스크탑 단독 릴리즈는 종료하고, v0.2.0부터는 iOS, Android 모바일 앱과 함께 릴리즈할 예정이다. 추가적인 기능보다는 간간이 안정화와 테마 추가에 집중할 생각이다.\n당장의 목표는 2026년 3월 홀로라이브 엑스포/페스티벌에서 실전 투입하는 것이다. 행사장에서 미러리스로 사진을 찍고, iPhone에서 바로 프레임을 입히고, 얼굴을 자동으로 모자이크 처리해서 SNS에 올리는 — 카메라 사용자든 일반 스마트폰 사용자든, 각자의 환경에서 편하게 쓸 수 있는 워크플로우를 제공하는 것이 방향이다.\n사이드 프로젝트로서 Chama Optics는 \u0026ldquo;사진을 찍는 사람이 사진을 더 잘 보여줄 수 있게 돕는 도구\u0026quot;를 목표로, 좀 더 편한 워크플로우를 제공해 나갈 것이다. 그리고 이번 개발에서 쌓은 절차형 매크로와 최적화 경험을 바탕으로, 다시 Rust Embedded 쪽에도 좀 더 신경 써볼 예정이다.\n참고 문헌 및 인용 # 표준 문서 # CIPA DC-008 — Exchangeable image file format (Exif) Version 3.0 CIPA DC-007 — Multi-Picture Format (MPF) Adobe — Adobe Cube LUT Spec 1.0 라이브러리 및 프레임워크 # exif-rs — Rust EXIF 파싱 라이브러리 egui — Rust 즉시 모드 GUI 프레임워크 font-kit — 크로스플랫폼 폰트 로딩 라이브러리 wagahai-lut (crates.io) — 1D/3D LUT 컬러 그레이딩 라이브러리 libheif-rs — libheif Rust 바인딩 wide — 크로스플랫폼 SIMD 벡터 크레이트 ONNX Runtime — 크로스플랫폼 ML 추론 엔진 InsightFace SCRFD — 얼굴 감지 모델 (det_10g) exif-frame — EXIF 프레임 웹 도구 (Chama Optics의 초기 참고) 참고 자료 # Rust Procedural Macros — 절차형 매크로 참고 ExifTool TagNames — 제조사별 MakerNote 태그 참고 Exiv2 MakerNote Documentation — MakerNote 구조 및 제조사별 포맷 참고 Special Thanks # SkuldNorniern — 디버깅 및 얼굴 인식 관련 도움 miniex — 폰트 시스템 디버깅 및 얼굴 인식 관련 도움 jcm7612 — 디버깅 및 피드백 shiemika324 — 일러스트 및 아이콘 일러스트 제공 ","date":"2026년 2월 14일","externalUrl":null,"permalink":"/ko/posts/chama-optics-dev-story/","section":"Posts","summary":"EXIF 기반 사진 프레임 + 얼굴 자동인식 프로그램, Rust 코어로 데스크탑부터 모바일까지\n","title":"Chama Optics 개발기","type":"posts"},{"content":"","date":"2026년 2월 14일","externalUrl":null,"permalink":"/ko/tags/cross-platform/","section":"Tags","summary":"","title":"Cross-Platform","type":"tags"},{"content":"","date":"2026년 2월 14일","externalUrl":null,"permalink":"/ko/tags/exif/","section":"Tags","summary":"","title":"EXIF","type":"tags"},{"content":"","date":"2026년 2월 14일","externalUrl":null,"permalink":"/ko/tags/ios/","section":"Tags","summary":"","title":"IOS","type":"tags"},{"content":"","date":"2026년 2월 14일","externalUrl":null,"permalink":"/ko/tags/rust/","section":"Tags","summary":"","title":"Rust","type":"tags"},{"content":"","date":"2023년 11월 13일","externalUrl":null,"permalink":"/ko/tags/embedded/","section":"Tags","summary":"","title":"Embedded","type":"tags"},{"content":"","date":"2023년 11월 13일","externalUrl":null,"permalink":"/ko/tags/korean_article/","section":"Tags","summary":"","title":"Korean_Article","type":"tags"},{"content":"","date":"2023년 11월 13일","externalUrl":null,"permalink":"/ko/categories/my-frist-mass-production-with-rust-embedded/","section":"Categories","summary":"","title":"My Frist Mass Production With Rust Embedded","type":"categories"},{"content":" WARN! 아직 작성 중인 글입니다. 중도에 내용이 변경될 수 있습니다. 읽기 앞서서 # 이 글은 이전 글 3 컴파일 타임에 맡기세요 의 연장선이나 const fn/trait/impl 보다는 build.rs 에 초점을 맞추어 설명합니다.\nrust 문법에 대한 이해가 부족하다면 이전 글 2탄 기초 공부 방법 및 특징 에 적힌 #러스트-공부 문단을 읽고 올 것을 권합니다. 이 외에도 김기오 님이 남겨주신 좋은 글평범한 C개발자의 Rust입문기: Rust에 입문하는 C개발자를 위한 안내서또한 추천드립니다.\n빌드 스크립트 (build.rs) # C, C++에는 Makefile이 있듯, rust에는 Cargo가 있다. Cargo는 컴파일 시작 전에 실행할 수 있는 build.rs를 간단하게 쓸 수 있도록 제공하고 있다.\n자세한 build.rs에 대한 설명은 여기서 확인할 수 있다. The Cargo Book - Build Scripts\nbuild.rs는 src 디렉터리에 있는 소스코드 혹은 외부 라이브러리를 컴파일하기 전에 실행이 된다. 그리고 중요한 점은 no_std를 위해 코드를 개발 중이라 하더라도, build.rs는 no_std뿐만 아니라 alloc crate를 비롯한 OS 위에서 사용 가능한 라이브러리를 사용할 수 있다.\n별도의 main.rs에 있는 프로그램은 const 상수 데이터를 컴파일 타임에 만들어야 하지만, 사용해야 하는 함수 및 메서드가 const 형태로 제공하지 않는 경우가 있다.\nbuild.rs 와 env!()로 문자열 가져오기 # build.rs와 env!() 매크로를 사용해 문자열(\u0026amp;str)을 컴파일 타임에 가져오는 실습을 해보고자 한다.\n프로젝트 구조는 이렇게 구성된다. main.rs(혹은 lib.rs)는 src 디렉터리에 없으며, 프로젝트 파일의 루트 디렉터리에 들어간다.\nCargo.toml 예시 # # End of Cargo.toml [build-dependencies] chrono = \u0026#34;0.4.31\u0026#34; 위에서 언급한 것과 같이 build.rs는 기존에 OS 타겟에서 쓸 수 있는 라이브러리를 사용할 수 있다. 쓰고 싶은 crate가 있다면 dependencies 아래에 build-dependencies 리스트에 넣어주자. 아래는 예시를 위한 chrono crate를 넣어주었다.\nbuild.rs 예시 # // build.rs fn main() { let now = chrono::Utc::now().to_rfc3339(); println!(\u0026#34;cargo:rustc-env=GIVEN_BUILD_TIME={}\u0026#34;, now); } build.rs를 Cargo가 컴파일한 뒤 실행하면 chrono 라이브러리를 통해 현재 시간을 UTC로 가져온 다음 String으로 만든다.\n그다음 \u0026ldquo;GIVEN_BUILD_TIME\u0026rdquo; 환경 변수로 prinln! 을 통해서 rustc(컴파일러)에 넘긴다.\nsrc/main.rs 예시 # // src/main.rs const BUILD_TIME: \u0026amp;str = env!(\u0026#34;GIVEN_BUILD_TIME\u0026#34;); fn main() { // if you working with firmware environment, // use defmt::info!(..) instead of println!(..) println!(\u0026#34;passed build time is {}\u0026#34;, BUILD_TIME); // \u0026#34;passed build time is 2023-11-14T06:14:02.366899222+00:00\u0026#34; } src/main.rs에는 const \u0026amp;str로 환경 변수로 존재하는 \u0026ldquo;GIVEN_BUILD_TIME\u0026quot;을 env!(..)라는 내장 매크로를 통해 가져온다.\nenv!(..)의 정확한 모듈 위치는 core::env!(..)이며 core::env!(..)는 컴파일 타임에 환경 변수를 가져온다. 컴파일 타임이 아닌 OS 위에서 돌아가는 타겟 개발에 있어서 런타임 중의 환경 변수나 실행 인자를 알고 싶다면 std::env 모듈에 있는 것들을 사용해야 한다. build.rs를 사용하면서 둘 다 사용하게 될 가능성이 있으니 혼동하지 않도록 주의하자.\nenv!() 매크로에 대한 자세한 설명은 https://doc.rust-lang.org/core/macro.env.html에서 확인할 수 있다.\n고정길이 바이너리 데이터 만들어서 받아오기 # include_bytes를 통해서 받아오기 # core::include_bytes는 컴파일 타임에 프로젝트 디렉터리에 있는 파일을 바이너리 데이터로 가져올 수 있다. https://doc.rust-lang.org/core/macro.include_bytes.html\n더미 바이너리 생성 # echo -n \u0026#34;\\x00\\x01\\x02\\x03\u0026#34; \u0026gt;\u0026gt; ./src/stuff0123.bin 실습에서 사용할 더미 바이너리를 생성해 준다. [0x00, 0x01, 0x02, 0x03]으로 총 4바이트이며 위치는 main.rs가 있는 곳에 넣어준다.\n이 글에서는 터미널상에서 더미 바이너리를 만들어주지만 build.rs에서도 할 수 있다.\nsrc/main.rs 예시 # const DATA0123: \u0026amp;[u8; 4] = include_bytes!(\u0026#34;stuff0123.bin\u0026#34;); fn main() { println!(\u0026#34;binary data is {:?}\u0026#34;, DATA0123); } src/main.rs에는 const \u0026amp;[u8; 4]로 아까 생성한 바이너리를 컴파일 타임에 가져온다. 여기서 주의할 점은 위에서 \u0026amp;str을 가져온 것과는 다르게 [u8; N]과 같이 원자의 개수를 정해줘야 한다.\n원자의 개수를 신경 쓰지 않고 가져오기 위해서는 매크로를 사용해서 써야 한다. 이에 대한 내용은 뒤에서 후술한다\n가변 길이 바이너리 가져오기 # build.rs src/**.rs String const \u0026amp;str Vec\u0026lt;u8\u0026gt; const [u8; N] build.rs에서는 가변 길이 속성을 가지고 있으나 src/**.rs안에서 타겟을 위해서 컴파일 할 때는 proc_macro의 힘을 빌려야 한다. 다만 가변적으로 컴파일할 때마다 데이터의 사이즈가 바뀌는 상황이 철저히 통제되지 않는다면 위험하니 이점은 유의하면서 활용해야 한다.\nproc-macro 사용하여 가변길이 바이너리 받아오기 # 데이터를 tmp에 저장한뒤 include_bytes!와 proc_macro 하는 방법도 있으나 여기서 소개할 방법은 env! 에다가 proc_macro를 같이 사용하는 방법이다.\nproc_macro을 서술하기위해서는 과거에 C언어에서 ##을 사용해 문장을 붙여서 코드를 만들거나 컴파일러 종속 기능을 통해서 흑마법을 부리던것을 토큰과 파서의 개념을 가져와 어느정도 안정적으로 메타프로그래밍할 수 있는 매크로 시스템이다.\n한국어로는 절차형 매크로라고 부르며 proc_macro, 절차형 매크로를 잘 활용한다면 뛰어난 메타프로그래밍을 할 수 있다. 여기에 대해서는 차후 다른 글에서 서술하도록 하겠다.\nproc_macro의 자세한 공식 설명은 Procedural Macros 에서 확인할 수 있습니다.\n전반적인 흐름 # stateDiagram-v2 state \"Total flow\" as total_flow state \"data prepare\" as data_prepare state \"hex::encode(..)\" as hex_encode state \"hex encoded\" as hex_encoded state \"passing to env\" as passing_to state \"passing from env\" as passing_from state \"proc_macro\" as proc_macro state \"decoding at build time\" as decoding state \"decoded data\" as decoded_data state \"code generation\" as code_generation state \"src/**.rs\" as src_rs state \"const NAME: [u8; N] = [...]\" as const_u8_n state total_flow { [*] --\u003e build.rs state build.rs { [*] --\u003e data_prepare data_prepare --\u003e hex_encode hex_encode --\u003e hex_encoded hex_encoded --\u003e passing_to } -- state src_rs { passing_from --\u003e proc_macro state proc_macro { [*] --\u003e decoding decoding --\u003e decoded_data decoded_data --\u003e code_generation } proc_macro --\u003e const_u8_n } } 전반적인 흐름은 아래와 같다.\nbuild.rs 에서 넣어줄 데이터를 만든다. hex로 encoding한 뒤 환경변수로 만들어서 rustc에게 건네준다. src/**.rs 에서 환경변수를 받은뒤 proc_macro로 만든 함수로 보낸다. 매크로 함수에서 컴파일 타임에 디코딩을 하여 원본 데이터를 어레이로 만든다. 만든 배열로 지시된 이름으로 const 상수 데이터를 배열의 길이와 함께 코드생성 해준다. 컴파일 타임에 디코딩을 하기위한 proc_macro 코드 # 위에서 설명한 절차 4, 5번을 행하기 위해서 아래와 같은 코드가 필요하다.\nfn slice_to_auto_sized ( arr_name: String, input: \u0026amp;[u8], ) -\u0026gt; TokenStream { format!( \u0026#34;const {}: [u8; {}] = [{}];\u0026#34;, arr_name, input.len(), input.iter().join(\u0026#34;, \u0026#34;) ) .parse::\u0026lt;proc_macro2::TokenStream\u0026gt;() .expect(\u0026#34;Failed to parse array\u0026#34;) .into() } struct NameAndEnvInput { arr_name: syn::LitStr, _comma0: Token![,], env_var: syn::LitStr, } impl Parse for NameAndEnvInput { fn parse(input: syn::parse::ParseStream) -\u0026gt; syn::Result\u0026lt;Self\u0026gt; { Ok(Self { arr_name: input.parse()?, _comma0: input.parse()?, env_var: input.parse()?, }) } } #[proc_macro] pub fn c(inputs: TokenStream) -\u0026gt; TokenStream { let inputs = parse_macro_input!(inputs as NameAndEnvInput); slice_to_auto_sized( inputs.link_section_name.value(), inputs.arr_name.value(), hex::decode(std::env::var(inputs.env_var.value()).expect(\u0026#34;This env not found\u0026#34;)) .expect(\u0026#34;Can\u0026#39;t decode hex\u0026#34;) .as_slice(), ) } 예시로 main.rs에 slice_to_auto_sized!(SOME_DATA, GIVEN_ENV); 와 같은 코드가 선언되어있다고 가정하자\nconst_from_hex_env에서는 NameAndEnvInput의 구조체 구조에 맞게 \u0026ldquo;SOME_DATA\u0026quot;와 콤마(,) 그리고 \u0026ldquo;GIVEN_ENV\u0026rdquo; 총 3개의 토큰을 가져온다. 이 토큰을 가장 위에있는 slice_to_auto_sized에서 가져온뒤, 만들 코드를 생성해주는 방식이다.\n위 코드는 fork된 env-to-array 커밋 에서 확인할 수 있습니다. 해당 코드에서는 linker쪽에 더미 섹션을 만들기위해서 개조되어 있어 살짝 다릅니다. 해당 코드는 env-to-array crate코드를 살짝 수정한 포크입니다. hex encode를 위한 데이터 생성 예시 # fn main { // https://github.com/pmnxis/billmock-mptool/blob/master/otp-proof-of-concept/build.rs // 중략 let fingerprint = MpFingerprint { firmware_fingerprint: FirmwareFingerprint { model_name: main_package.name.clone(), // reference package name temporary model_ver: feature_based_model_ver, firmware_ver: main_package.version.to_string(), firmware_git_hash: format!(\u0026#34;{}\u0026#34;, commit_hash), }, }; // cargo objdump --release -- -s --section .mp_fingerprint println!( \u0026#34;cargo:rustc-env=MP_FINGERPRINT_TOML_HEX={}\u0026#34;, fingerprint.to_hex_string(), ); } hex스타일로 encoding할때는 hex를 사용해 \u0026ldquo;hex::encode()\u0026rdquo; 로 인코딩할 수 있습니다.\n위 코드에서는 toml로 현재 패키지의 정보와 git hash를 만든뒤 hex로 인코딩해주고 있습니다.\n실제 응용 # 응용 - EUC-KR 문자열을 컴파일 시간 내에 가져오기 # use encoding_rs::EUC_KR; fn main() { // encoding_rs::Encoding::encode(..) is not const fn let ret: \u0026amp;[u8] = EUC_KR.encode(\u0026#34;안녕하세요\u0026#34;).0.to_vec().as_slice(); } billmock-app-rs를 개발하면서 NDA 쪽 금융사 전문 통신 라이브러리를 만들 때, 몇 가지 문제점이 있었다. EUC-KR의 문자열들을 const로 갖고 있어야 했다. 하지만 EUC-KR 문자열 인코딩 라이브러리 encoding-rs는 const 한 함수를 제공해 주지 않는다.\nEUC-KR도 결국 문자열 인코딩이기에, 문장만 사전에 정해진다는 가정하에 컴파일 타임 안에 만들 수 있는 바이너리 데이터이다.\n위에서 소개한 기법들을 조합하여 금융사 전문 통신 라이브러리에서 EUC-KR을 컴파일 타임에 const [u8; N]으로 변환해 주는 코드를 작성하였다.\n응용 - dummy ELF header # 펌웨어 개발을 하면서 MP Tool (Mass Production Tool)을 만들어 펌웨어를 대량으로 넣을 때에 실수 방지 및 하드웨어에 대한 버전 기록을 위해 ELF에 더미 헤더를 넣었다. 이때 ELF 더미 헤더는 실제로 flash에 적재되지 않는 데이터로서 가변 길이를 사용해도 아무런 문제가 없었다.\n전반적인 구조는 위에서 서술한 \u0026ldquo;proc-macro 사용하여 가변 길이 바이너리 받아오기\u0026rdquo; 내용과 비슷하다.\n관련된 커밋은 아래와 같다.\nhttps://github.com/pmnxis/billmock-app-rs/pull/42/files https://github.com/pmnxis/env-to-array/commit/782c2b265d8a23653321d163ac5cea96c04bc85d 마치며 # 이 글은 이전 글 3 컴파일 타임에 맡기세요 의 연장선이나 const fn/trait/impl 보다는 build.rs 에 초점을 맞추어 설명을 하였다. build.rs를 통해 고정길이, 가변길이를 다루는 법과 실제 사용 예시를 나열했다.\n도중에 proc_macro (절차형 매크로) 에 대해서 설명하기에는 내용이 너무 길어지기에 다음 기회에 서술할 예정이다.\n","date":"2023년 11월 13일","externalUrl":null,"permalink":"/ko/posts/my_first_commerical_rust_embedded_product_4/","section":"Posts","summary":" WARN! 아직 작성 중인 글입니다. 중도에 내용이 변경될 수 있습니다. ","title":"러스트 임베디드 양산 제품 개발기 - 4 빌드 스크립트 활용","type":"posts"},{"content":"","date":"2023년 11월 13일","externalUrl":null,"permalink":"/ko/tags/%ED%9A%8C%EA%B3%A0%EB%A1%9D/","section":"Tags","summary":"","title":"회고록","type":"tags"},{"content":" WARN! 아직 작성 중인 글입니다. 중도에 내용이 변경될 수 있습니다. 서론 # 이 글을 읽기 전에 rust 문법에 대한 이해가 부족하다면 이전 글 2탄 기초 공부 방법 및 특징 에 적힌 #러스트-공부 문단을 읽고 올 것을 권합니다. 이 외에도 김기오 님이 남겨주신 좋은 글평범한 C개발자의 Rust입문기: Rust에 입문하는 C개발자를 위한 안내서또한 추천드립니다.\n컴파일 타임에 맡기세요 # 일반적인 함수는 컴파일 내에 결과가 예측이 되면 상수 (불변의 값)을 그대로 사용한다.\n하지만 불변의 값으로 저장하는 것이 비효율적이라고 판단될 시 함수 형태로 instruction 상에 남아있다.\n임베디드, 특히 저가의 MCU위에서 동작하는 펌웨어의 경우 램의 용량은 매우 작다. (필자가 사용한 MCU STM32G030C8 은 8KiB이다.).\n최대한 컴파일 시간에 복잡한 연산도 상수의 성격을 띠는 데이터로 남긴 뒤 Flash 영역 (.text 혹은 .rodata) 에 적재시키기 위해서 일반적인 러스트 프로그래밍을 가끔씩 벗어나 이를 고려하여 코드를 작성했다.\nconst fn # const fn은 일반 fn과는 다르게 컴파일 타임에 상수 성격을 띠는 데이터를 가져오는 것을 보장한다.\nconst fn const_add(a: i32, b: i32) -\u0026gt; i32 { a + b } const fn const_add_round_up(a: i32, b: i32) -\u0026gt; i32 { let added = const_add(a, b); // 안에 있는 함수는 무조건 const 형태여야 한다. (added / 10) * 10 } 하지만 그만큼 제약도 많다. const fn 스코프 안에 있는 함수는 const fn로 구성되어 있어야 하며, 다른 연산자들 또한 컴파일 타임 내에 연산이 가능한 형태여야만 한다.\n반대로 일반적인 fn 혹은 async fn 스코프 안에서는 const fn을 사용할 수 있다.\nconst impl # 일반적인 함수를 const 형태로 만드는 것은 간단하지만 구조체 struct를 위한 함수로 만드는 순간 어려운 문제들에 봉착하게 된다. 이 부분은 후술하게 될 const trait 에서 다루게 된다.\n우선은 가장 간단한 특정 구조체 struct의 default에 대해서 다뤄보도록 하겠습니다.\npub enum Player { Undefined = 0, Player1 = 1, Player2 = 2, } impl Player { pub const fn default() -\u0026gt; Self { Self::Undefined } } 결과적으로 코드는 매우 간단하지만 이와 같이 사용함으로서 default() 를 호출하는 쪽에서는 컴파일 타임 내에 상수를 얻을 수 있다. 더 복잡한 것을 원하는 경우에는 복잡한 값을 넣어주면된다. 위에서도 언급한것과 인자가 유동적이지 않는 한 함수 형태로 남지않기에 분기문, 스택에서 왔다 갔다 하는 과정, 그 와중에 레지스터를 백업하고 롤백 하는 과정의 생략을 보장받을 수 있다.\nconst trait # 이제 대망의 const trait 이며 글을 작성한 시점(2023년 11월)에선 nightly feature이다. 여기서 부터는 왜 러스트가 const fn / impl / trait 이 아직까지 논의중인 RFC인지 동시에 서술한다.\n이미 존재하는 trait과의 충돌 # 위에서 언급한 pub const fn default()에서 이상한 점을 찾았는가?\n그것은 바로 Default trait이 이미 따로 있다는 것이다.\n하지만 Default trait 의 정의는 const 형태가 아니다.\n불특정 다수의 구조체 struct가 core::default::Default trait의 impl가 딱 봐도 너무 간단한 경우가 많다. 하지만 눈대중으로 판단하기에 아무리 간단하더라도 이 경우엔 const fn 안에서는 사용할 수 없다.\nInto/From의 경우 # 아직까지는 const 특성을 이용해 Default trait을 통한 추상화를 할 일은 거의 없었지만 외외로 into, from 가 문제였다.\n현재로서는 core::default::From 의 Trait정의를 const trait에 맞게 ConstInto, ConstFrom으로 수정하여 사용하면 아래와 같이 사용할 수 있다.\nProduct에 사용한 ConstConvert 정의 const 형태를 띄는 Into/From 의 사용 예시\npub struct UnpackedQuad4Bits { pub b0: u8, pub b1: u8, pub b2: u8, pub b3: u8, } #[derive(PartialEq)] pub struct PackedQuad4Bits { inner: u16, } impl const ConstFrom\u0026lt;UnpackedQuad4Bits\u0026gt; for PackedQuad4Bits { fn const_from(value: UnpackedQuad4Bits) -\u0026gt; Self { PackedQuad4Bits { inner: ((value.b0 as u16 \u0026amp; 0xF) \u0026lt;\u0026lt; 12) | ((value.b1 as u16 \u0026amp; 0xF) \u0026lt;\u0026lt; 8) | ((value.b2 as u16 \u0026amp; 0xF) \u0026lt;\u0026lt; 4) | (value.b3 as u16 \u0026amp; 0xF), } } } #[test] fn test() { assert_eq!( PackedQuad4Bits::const_from(UnpackedQuad4Bits { b0: 0x0, b1: 0x1, b2: 0x2, b3: 0x3 }), PackedQuad4Bits { inner: 0x0123 } ); } ConstInto / ConstFrom과 const 형태로 만들어서 사용하면 기존의 Into/From으로 .into() 형태로 곧바로 사용할 수 없으며 또다시 Into/From trait 정의에서 앞의 const 메서드를 호출해야 하지만 컴파일 타임 안에 into를 정의할 수 있다.\nnightly feature인 const trait # 아직까지 const trait은 nigtly feature이다. 개인적인 감상으로는 niglty compiler의 버전을 조금씩 바꿀 때마다 플래그 변경을 해줘야만 그대로 쓸 수 있었다. 하지만 그럼에도 불구하고 경우에 따라서는 매우 필요한 기능이다.(물론 안 쓰고 const fn 만 써서 할 수 있다.)\nconst trait을 정의하는 경우에는 #[const_trait]을 trait 정의 앞에 붙여줘야하며 lib.rs 혹은 main.rs에 #![feature(const_trait_impl)] 를 선언해줘야한다.\ntodo! const trait 에 대한 논의 역사 서술 Tracking issue for RFC 2632, impl const Trait for Ty and ~const (tilde const) syntax 이 시리즈의 다른 글도 같이 봐주세요 : 러스트 임베디드 양산 제품 개발기 ","date":"2023년 11월 12일","externalUrl":null,"permalink":"/ko/posts/my_first_commerical_rust_embedded_product_3/","section":"Posts","summary":" WARN! 아직 작성 중인 글입니다. 중도에 내용이 변경될 수 있습니다. ","title":"러스트 임베디드 양산 제품 개발기 - 3 컴파일 타임에 맡기세요","type":"posts"},{"content":" WARN! 아직 작성 중인 글입니다. 중도에 내용이 변경될 수 있습니다. RIIR BEAM\n서론 # 저번 글에 이어서 러스트를 임베디드에 적용했을 때 얻었던 장단점과 러스트 임베디드의 공부 방법 대해서 간단히 다루려고 한다.\n러스트를 임베디드에 쓰고 나서 느낀 점 # C언어와 러스트 사이에는 38년의 간격이 존재한다. # 이미지 출처 : History Of Programming Languages\nC언어는 1972년 발표됐으며, 러스트는 2010년에 발표되었다. 이 사이에는 최소 38년의 간격이 있으며 그 사이에 많은 언어들과 개념들, 변화들이 있었다.\nC언어는 구조체 struct가 있긴 하나 절차 지향이며 일단은 강타입 언어입니다. 러스트는 C++ 하고는 다른 상속 없는 객체지향을 갖고 있는 강타입 언어임과 동시에 C와 C++를 이어서 시스템 프로그래밍을 고려한 언어입니다.\n개인적인 해석에 있어서 C언어가 강타입이긴 하지만 CPU 레지스터에 강하게 바인드 되는 언어라고 생각합니다. 그에 비해 러스트는 C언어보다는 덜 CPU 레지스터에 종속되지만 그래도 경우에 따라 CPU 레지스터를 의식하고 프로그래밍할 수 있으며 \u0026ldquo;객체\u0026quot;의 개념에 있어서 강타입 속성을 갖고 있다고 생각합니다.\nC언어는 오래동안 유지되어 왔으며, 임베디드만 한다고 하면 C언어는 매우 유창하게 구사할 수 있으나 현대 언어인 러스트를 적응할 때에 많은 문제가 있을 수 있습니다. 가장 큰 문제가 \u0026ldquo;객체\u0026rdquo; 와 \u0026ldquo;메서드\u0026quot;설계하는 것일 겁니다. 절차 지향만 여태 해왔다 한다면 최소 몇 개월은 이 문제로 많은 어려움이 있을 수 있습니다.\n이 외에도 nullable 을 명확하게 구분하려는 철학, 소유권 등의 생각보다 기존의 생각의 틀에서 깨야 할 것들이 많습니다. 이걸 이해하고 특히 로우 레벨 제어에서 가끔 이것들을 깨고 프로그래밍하거나 (unsafe) 프로그램 용량을 고려해서 튜닝을 하는 과정에 있어서 CS 지식? 과 철학을 많이 얻을 수 있다고 생각하며 이것이 가장 값지다고 생각합니다.\n임베디드(펌웨어) 프로젝트에 적용 시 장점 # 언어 스펙상으로 내장된 Test 덕에, 부분적으로 Unit Test를 짜기 용이하다. 로직 생으로 문제없고 Unit Test가 거들어준다면 Integration Test를 매우 적게 하고 버그를 잡을 수 있었다. 썼던 코드 어느 정도 그대로 백엔드 서버에 적용할 수 있었다. clippy, fomatter가 기본으로 내장되어 불필요한 코드나 코드 컨벤션을 통일하기 좋다. (상속 없는) 객체지향 덕에 코드 재활용이 유용하다. Cargo 생태계 덕에 라이브러리를 추가하기 정말 편하다. 툴체인 설정도 매우 간단하다. 펌웨어에서 epoll 이 아닌 async / await를 사용할 수 있다. 절차형 매크로를 사용할 수 있다. C로 짠 것보다는 안전하며 개발 과정 중에 실수를 많이 줄일 수 있다. 임베디드(펌웨어) 프로젝트에 적용 시 단점 # 아직 참고할 프로젝트가 많이 없다. 8비트 프로세서는 아무래도 적용하기 힘들다. Queue나 array에 데이터를 넣을 때는 아무래도 사이즈를 최대한 줄이기 위해 enum, option, struct 등을 더 작게 만든 별도의 타입을 지정하게 된다. 이때 Into/From을 만드는 것이 조금 번거롭다. nightly feature을 어느 정도는 고려를 해야 한다. Ghidra/objdump로 컴파일 된 바이너리를 볼 때 기존의 C 코드와 결이 은근히 많이 다르다. (어셈블리 단위 정적 분석하기 아직까진 힘들다. 이건 단점이기보다는 특징이다.) 객체지향에 대한 경험이 없다면, 절차 지향적인 러스트 코드를 만들 수 있다. 이렇게 단점이 많은데 써야 하나요? # 결국에는 각 개인, 조직의 선택이긴 하나, 저는 썼으면 좋겠습니다.\n그 이유는 백날 C언어만 고집할 수는 없다고 생각하며 아무리 제조업/로우 레벨의 특수성이 존재한다고는 하나, 임베디드 개발 자라고서 개발자의 범주에서 벗어나는 것은 아닙니다. 현재 전체적인 범주에서의 개발자들이 사용하는 언어는 많이 발전해 왔고 계속 변경되고 있습니다. 제조업/로우 레벨 쪽이라고 해서 이 현대의 흐름을 벗어날 수 없으며, 계속 피한다면 이쪽 업계로 사람이 언젠가는 끊길 것이라고 생각합니다.\n물론 C언어를 완전히 버릴 수는 없습니다. 하지만 많은 C언어 개발자들이 리눅스 커널 코어 코드처럼 매우 견고하고 매우 빠른 코드를 짤 수 있는 것은 아니니까요.\n러스트 공부 # 글 선택 # 가능하면 러스트를 처음 접하는 사람들을 위하여 C언어 개발자 입장에서 알아두면 좋은 러스트 문법을 소개하고 싶으나 이미 김기오 님께서 좋은 글평범한 C 개발자의 Rust 입문기: Rust에 입문하는 C 개발자를 위한 안내서을 남겨주셔서 인용을 남겨두고자 한다.\n이 외에도 아래에 있는 설명들이 러스트의 문법들을 잘 설명하고 있다.\nThe Rust Programming Language 한국어 번역 Comprehensive Rust 한국어 평범한 C 개발자의 Rust 입문기: Rust에 입문하는 C 개발자를 위한 안내서 공부 방식 # 러스트 임베디드를 목표로 공부를 한다고 하면, 곧바로 MCU나 리눅스 드라이버를 개발을 하는 것은 별로 좋은 선택지는 아니다. 우선 임베디드라고 하면 대략적으로 3가지 방향성이 있다.\n\u0026ldquo;MCU에서 돌아가는 펌웨어 개발\u0026rdquo; \u0026ldquo;커널 개발 혹은 커널 드라이버 개발\u0026rdquo; \u0026ldquo;FPGA 개발\u0026rdquo; 여기서 다루는 것은 1번 \u0026ldquo;MCU에서 돌아가는 펌웨어 개발\u0026quot;이며, 2번에 대해서는 차후 개인 공부와 실무에서 해본 다음에 따로 서술할 예정이다. 하지만 엄밀히 말하면 서로의 지식이 도움이 되는 도메인이긴 하나 전혀 다른 도메인이다. 특히 3번은 더더욱 다른 도메인이다.\n(러스트로 FPGA에 적용하는 사례가 있어서 넣긴 했으나 HDL 류를 잘 몰라서 앞으로 언급은 하지 않는다.)\n1번과 2번의 목표를 잡고 했을 때 도메인 외에 러스트 언어만 한정 지어서 공부해야 할 것이라고 하면 언어 자체를 일단 공부해야 한다.\n우선은 위에 언급한 좋은 자료들을 보고 OS 위에서 돌아가는 토이 프로젝트를 먼저 잰 행 해보기를 권장한다.\n언어는 도구에 불구하기에 곧바로 알고 있던 도메인에 적용하려는 시도가 있으나 장기적으로 본다면 별로 좋은 선택지는 아니라고 생각한다. 이렇게 생각하는 이유에 대해서는 다른 섹션에서 다루도록 하겠습니다.\nno_std를 의식할 것 # no_std는 땜쟁이에게 러프하게 비유하자면 non-eabi 같은 것이다. 풀어서 설명하자면 OS에서 제공하는 표준 API 없이 돌아가는 환경을 말한다. 이 경우에 heap 혹은 dynamic allocation과 같은 부분에 있어서 많은 제약을 가지며 표준 입출력이 없기에 OS 위에서 개발하던 때와 달리 하드웨어적인 부분을 고려하여 개발을 할 수밖에 없다.\nno_std는 rustc (컴파일러)한테는 예약어이며, cargo (패키지 매니저)에서는 암묵적인 예약어이다. 라이브러리의 lib.rs 초입부에 #![no_std]라고 표기가 되어있다면 이 라이브러리는 no_std환경에서 사용할 수 있다.\n이 외에도 crates.io에 올려서 no_std라는 것을 홍보하기 위해서 Cargo.toml에 no_std를 표기해두는 경우도 있다.\nA no_std Rust Environment 앞으로 러스트 임베디드 위에서 개발하게 된다면 1번 2번의 경우 둘 다 no_std 라이브러리를 작성하거나 가져와서 쓰는 경우가 많아진다. 왜냐면 우리가 삼는 타깃은 운영체제의 지원에 대해서 매우 제약적이기 때문이다.\n코어 라이브러리를 사용할 때 std대신 core사용 # use core::borrow::BorrowMut; use core::cell::UnsafeCell; use core::marker::PhantomData; 우선 당장 신경 쓸 수 있는 부분은 코드를 작성할 때 std에서 가져오지 말고 최대한 core에서 가져오도록 한다. std에는 core에 있는 것들을 re-export 하고 있기에 core에 있는 것들로 구성해도 된다.\nhttps://doc.rust-lang.org/src/std/lib.rs.html#431-459 처음에는 최대한 unsafe를 쓰지 말자 # 러스트로 임베디드를 작성하면서 결국에는 최적화를 위해 unsafe를 사용했지만 unsafe는 사용이 힘들고 C로서 이해하고 있던 프로그래밍 모델, 컴퓨터 구조를 러스트의 철학? 을 답습하며 이해해야 하는 과정이 들어간다. 그리고 가장 큰 문제는 물어볼 수 있는 사람이 줄어든다.\n우선은 러스트라는 언어에 대해서 어느 정도 익숙해진 다음 다루는 것을 권장한다.\n혹시라도 써야 한다면 아래의 문서가 매우 상세하게 서술되어 있다.\nThe Rustonomicon 이 시리즈의 다른 글도 같이 봐주세요 : 러스트 임베디드 양산 제품 개발기 ","date":"2023년 11월 4일","externalUrl":null,"permalink":"/ko/posts/my_first_commerical_rust_embedded_product_2/","section":"Posts","summary":" WARN! 아직 작성 중인 글입니다. 중도에 내용이 변경될 수 있습니다. RIIR BEAM\n","title":"러스트 임베디드 양산 제품 개발기 - 2 기초 공부 방법 및 특징","type":"posts"},{"content":"아직 작성 중인 글입니다. 중도에 내용이 변경 될 수 있습니다.\n최근에 현장에 내보낸 테스트용 기기\n서론 # C를 대체할 언어로서, 러스트는 주목을 받는 언어이며, 현재는 백엔드 개발을 하고있지만 과거 펌웨어에 빠져살던 나의 기준으로서, 예나 지금이나 프로그래밍 언어는 HDL언어가 아니라면 \u0026ldquo;500원 짜리 MCU에서 돌아가야한다\u0026rdquo; 라는 생각을 갖고있다.\n이런 관점에서는 현재 뜨고 있는 zig 외에는 러스트만이 C를 대체할 언어라고 생각한다. 하지만 이 주장에는 내가 러스트로 펌웨어를 양산레벨로 개발해본적이 없다 라는 결점이 존재한다. 이러한 문제점을 인지하고 몇번이나 시도를 2-3년 정도 하다가, 드디어 2023년 7월 부터 시작한 상용 러스트 임베디드 프로젝트가 제품 초기 양산 페이즈를 밟게되었다.\n내가 경험한 러스트 임베디드 그리고 장점과 기법등을 여러 글에 나눠서 다루고자 한다. 이 글에서는 사용한 개발 프레임워크, 프로젝트를 위해 개발 한 것들, 간단히 느낀 것에 대해 소개하고자 한다.\n개인적인 욕심으로 이번 경험을 통해 러스트 임베디드 에 관한 책을 싶으나 독자층을 3가지 분류에서 정하지를 못해, 책을 위해 독자층을 마음속에서 정하기전까지는 생각 나는대로 정리하는 형태로 예상하고 있다.\n\u0026ldquo;이미 러스트를 경험한 개발자\u0026rdquo; \u0026ldquo;취미로 아두이노를 하는 임베디드가 주업무가 아닌 개발자\u0026rdquo; \u0026ldquo;이미 임베디드 개발자\u0026rdquo; 번거럽게 이걸 설명하는 이유는, 러스트를 쓰는 임베디드 개발자가 너무 적기 때문에 대다수는 러스트에 관심이 있는 개발자의 범주에서 당장은 쓸 것이며 미지의 러스트 와 임베디드 둘 다 동시에 설명하기에는 너무나도 불친절하기 때문에 글의 서술이 느리더라도 임베디드 의 개발과정의 면을 조금 바라볼 수 있도록 서술 하는 과정을 걸치려고한다.\n제품 기획 # 2023년이 되서야 카드단말기를 달게 됬는가 라는 질문에는 오락실 산업 자체의 역사를 봐야한다. 2007년 경 바다이야기 이슈로 2020년까지 카드단말기와 같은 것을 달수 없다가 2020년부터 달 수 있게됬으나 이 경우에는 카드단말기를 다는 경우 게임 자체의 심의를 다시 받아야만 했다 하지만 이에 관해서 법이 최근에 와 허들이 낮아지게 되었고 최근에 와 나에게 카드단말기를 달수 있게 해주는 모듈의 개발 의뢰가 들어왔다.\n게임위, 내달 1일부터 아케이드 게임 결제 방식 다양화하기로 결정 - 2019-06-28 전체이용가 아케이드 게임물 결제방식 변경 관련 - 2022-03-21 지폐입력기의 예시\n카드 단말기는 RS232 시리얼 통신을 사용하고 있으며, 기존 게임기는 molex 2.00mm 간격의 10핀 커넥터를 지폐입력기 용으로 사용하며 혹은 2~4핀의 커넥터를 동전입력기 용으로 사용한다. 특수한 기능을 쓰지않으면 10핀을 쓰는 지폐입력기와 동전입력기의 신호체계는 호환이 되며 과거와 달리 물가가 많이 오른 시점에서 500원, 100원 주화보다는 1000원 지폐를 지불방식으로 많이 사용하고 있기에 지폐입력기의 배선을 좀 더 우선하기로 했다.\n기존 게임기에 카드단말기를 추가하기 위해서는 기존 화폐 지불 신호선을 공유하여 사용하여 지폐입력기 (혹은 동전입력기) 대신 신호를 만들어 주는 수 밖에 없다. 이 때 단순히 기존 배선에 그대로 신호를 주게되면 지폐입력기의 신호와 카드단말기에서 나온 신호가 중첩되게 된다. 따라서 각 신호의 출력쪽에 대해 FIFO Queue를 적용하여 지폐입력과 카드단말기 입력이 중첩되도 순차처리 할 수 있도록 구성하고 하드웨어도 이를 고려하여 구성하였다.\n하드웨어 개발 # STM32G030C8Tx 칩선정 # STM32G030C8Tx 은 ST 사의 Cortex-M0 (ARM cortex-Mv6) MCU이다. MCU는 32비트 CPU를 내장하고 임베디드를 위한 주변장치를 탑재하는 물건을 말한다. 이 제품은 64KBytes의 프로그램을 담을 수 있는 Flash와 8KB SRAM(컴퓨터의 RAM과 비슷) 이 있으며 16Mhz로 동작한다. 절반의 용량인 32KBytes 을 갖고있는 제품도 있지만 회사에서 간단한 제품을 개발할때 32Kbyte는 rust에서 debug build를 올리기엔 무리가 있었다라는 경험과 비교적 기능이나 비즈니스 로직이 커질 것 같다라는 예상이 있어 확 늘리진 않고 64Kbyte로 정했다. 그리고 전반적으로 최소한의 컴퓨팅 리소스를 갖고있는 저렴한 MCU에서 러스트 임베디드 제품을 만들수 있어야 러스트로 임베디드를 양산, 업무용으로 쓸수 있다라는것을 증명 할 수 있다 라는 생각도 기반했다. (Go, Python, Javascript로도 임베디드에 돌아가는 코드를 만들수는 있다고한다 하지만 양산용으로 쓸수있는 단가가 매우 낮은 환경에선 많이 힘들다고 생각하고 비싼 칩에서만 돌아가면 의미 없다고 생각한다.)\nPCB (회로) 개발 # 왼쪽의 Gerber 데이터는 공개를 하지않지만 schematic (회로도) 는 공개를 하고있다. BillMock-HW-RELEASE\n회로 개발에는 KiCad 를 사용하였다. KiCad 는 CERN이 공개한 오픈소스 EDA 캐드 프로그램이다. 보편적으로 사용하는 OS, Linux, macOS, Windows 를 전부 지원하며 5.x 버젼부터 써왔으며 현재 6.x를 거쳐 7.x에서는 꽤 쓸만하져 이번 프로젝트에도 적용했다.\nPCB (회로) 개발은 대략적으로 schematic개발과 gerber artwork으로 나뉜다. schematic은 오른쪽 이미지와 같이 회로를 어떻게 구성할지에 대한 도식표로 나타낸 형태이다. gerber artwork은 왼쪽 이미지와 같이, 실제로 어떻게 구리배선과 부품들을 인쇄/실장 할 것인지 나타내는 형태이다. 회로상에서 요구되는 커넥터의 위치, 배선에 흐르는 통신의 속도나 전기적인 신호의 크기, 전원 요구사항 등에 따라 가까이 배치하거나 멀리배치, 그리고 두껍거나 비교적 얇게 배선을 라우팅한다.\n프로그램도 최적화를 하듯이 회로도 최적화가 필요하며 적거나 적은 종류의 부품, 적당히 값싼 부품, 전체적인 사이즈 감소나 사양 을 낮추면서 단가를 줄이되 기획상 하드웨어의 기능과 안정성은 어느정도 들고가는 것이 중요하다.\n프로토 타입 생산 # 프로토 타입은 JLCPCB를 이용하였다. 회사에서 진행하는 프로젝트라고 한다면 국내 턴키 업체에 맞기는 게 정석적인 선택이나, 이미 JLCPCB의 SMT(부품 조립) 서비스를 여러 번 써본 입장에서는 오히려 적응을 따로 할 필요도 없고 JLCPCB에서 소량에 대해 매우 저렴하게 결과물이 잘 나온다면, 나중에 다른 업체에서 양산을 한다고 해도 웬만해서 될 거라는 믿음이 있었다. (소량 샘플은 JLCPCB가 이례적으로 저렴하다.)\n백엔드 서버 개발자의 입장에서 비유를 한다면, \u0026ldquo;10년된 학교 동아리 서버에서 돌아가니, 최종 릴리즈때 IDC에서 잘 돌아가지 않을까\u0026rdquo; 라는 생각과 비슷하지 않을까 생각한다.\n최종 양산 # BOM정리 및 부품 구매 # 소프트웨어와 다르게 하드웨어에 가까워지면, BOM이라는 단어를 많이 듣게 된다. Bill Of Matterial 은 말 그대로 부품 리스트이며 가격이나 이것저것 정보를 필연적으로 포함하게 된다. 여기서 가격이 너무 비싸면 설계단으로 되돌아와 크게 설계를 바꾸거나 설계 변경 없이 변경 가능한 부품이 있으면 대체 부품으로 채워 넣기도 한다. 이 과정에서 한번 자체적으로 너무 비싸다는 판단을 내려 커넥터 개수를 줄이고 어느 정도의 수요 예측을 통해 \u0026ldquo;Reel\u0026rdquo; 단위로 부품을 미리 당겨서 구매하도록 했다.\n양산을 위해 조립 공장에 보낸 부품들, Reel은 원통형으로 부품이 필름테이프 처럼 감겨있는것을 Reel이라고 한다.\nBOM 정리 / 최적화는 매우 중요하나 일반적인 소프트웨어 개발자에게는 감흥이 없는 주제이므로 유튜버 승우아빠의 레스토랑 BOM을 보면 재미를 느낄 수 있다고 생각한다. 전자 회로에 대한 이야기가 아닌 레스토랑 운영에서의 BOM(음식재료) 관리이긴 하나 매우 유익하다고 생각한다.\n왜 이렇게 되는지 알려드리겠습니다. - 승우아빠 일상채널\n생산 위탁 / 조립 위탁 # PCB를 만드는것과 부품을 그위에 올려서 납땜하는 것(조립, PCB Assembly)은 별개의 일이다. 턴키 업체에 부품 구매까지 맡기는 경우가 있으나 나의 경우엔 사급(이쪽에서 구매해서 제공함)으로 진행하였다.\n그리고 업체는 이미 양산 경험이 있는 회사 선배의 추천을 받은 턴키업체를 이용하였다. (신뢰 기반으로 발품 파는 시간을 줄였다.)\n국내에서 양산을 한 이유 (JLCPCB 혹은 다른 중국에서 하지 않은 이유) # 현재의 중국이 있기 전까지 한국은 전 세계로부터 PCB 제조부터 조립 (+개발)과 함께 제품의 케이스 사출, 판금을 모두 빠르게 해낼 수 있었고, 그 서플라이 체인이 아직 남아있기 때문에 아직은 전자제품의 제조, 생산의 대부분의 공정을 해낼 수 있는 나라다. 하지만 저렴한 가격과 홍보로 해외에서 샘플링 및 소규모 양산을 중국 업체에 주로 맡기는 경우가 유튜브와 커뮤니티를 중심으로 많이 퍼져있는 상황이다. 한국에서는 실무자들만 알고 있는 루트(업체)를 잘 찾고, (업체들이 일을 받아 준다면) 어느 정도 수량의 양산까지 국내에서 진행하는 것이 유리하다. 수량이 매달 수십만 개 이상 만든다고 하면 해외 가공 업체에 의뢰하는 것이 가격적으로 유리할 수 있겠지만 수 천 또는 수 만개 정도의 소량이라면 해외 공장이 매번 잘하는지 검사할 능력과 인력, 그리고 잘못되었을 때 책임질 방법 없다.\n내가 만든 PCB기준으로 1000대를 양산한다고 가정했을 때, JLCPCB가 압도적으로 저렴하긴 하나, 어느 시점에서는 20~30%정도 밖에 차이가 나지않는 지점이 존재했다. 거기에 운송비, 관부가세, 기타 행정 비용을 고려하면 JLCPCB쪽이 별로 이득을 가져다 주지도 않았고 다른 것 보다 문제가 발생했을때에 대해 책임을 제대로 지지않는 다는 것이다. 이 외에 JLCPCB 말고 다른 해외 업체들은 퀄리티는 좋으나 결국에는 문제가 발생했을때 직접 찾아가서 논의를 하기 힘들다라는 문제점은 여전히 존재한다.\n초창기 PCB 10대를 주문했는데 5대가 불량이였다, 하지만 내가 먼저 클레임을 걸어야한다.\n프로그램 다운로드 # MP Tool\nPCB를 만들었다고 해도, 그냥 돌아가는게 아니라 프로그램을 넣어줘야한다. 조립 위탁 단계에서 요청하면 프로그램 바이너리를 넣어주는 경우도 있으나 이번에는 커스텀 프로그램이 필요하여 이쪽에서 직접 넣는 방향으로 했다.\n왜 그런 과정을 거치고 어떻게 개발했는지에 다루면 너무 길어지기에 차후 다른 글에서 다루도록 하고\n대략적인 과정은 이러하다\ngraph LR; A[Power Up] --\u003e|Flash \\nLock Check| B(Unlock Flash\\nTemporary) B --\u003e C[Program\\nDownload] C --\u003e |OTP section\\n check|D{S/N Exist?} D --\u003e|Yes| E[Update to DB] D --\u003e|No| F[Write New OTP\\n\u0026 Insert to DB] 여기서 OTP섹션에 있는 시리얼 넘버를 확인하고 유무에 따라 정보를 추가하거나 갱신하는 과정이 추가로 들어간다. OTP에 시리얼 넘버가 없으면 OTP섹션에 시리얼 넘버를 기입한다.\n글을 마치며 # 최종 양산한 기판\n다음에는 rust로 개발한 펌웨어 소프트웨어 개발 측면에서 다루고 그 뒤에는 러스트 임베디드 생태계, 터득한 테크닉? 같은것을 다루지 않을까 싶다.\n처음으로 개인 양산을 경험한 것이 러스트로 개발한 펌웨어 위에서 돌아가는 것 과 성공적으로 양산을 마칠 수 있어서 매우 기쁘게 생각한다.\n다음에도 개인에서 양산을 하라고 하면 못할 것 같다. 개발을 하는데 있어서의 도움되는 귀중한 경험으로 삼고 이걸 주업으로 혼자서 다 소화하기에는 큰 무리가 있다. 그래도 한번쯤은 혼자서 양산을 태워볼 기회가 있으면 해보는 것을 추천한다.\n이 시리즈의 다른 글도 같이 봐주세요 : 러스트 임베디드 양산 제품 개발기 ","date":"2023년 11월 2일","externalUrl":null,"permalink":"/ko/posts/my_first_commerical_rust_embedded_product_1/","section":"Posts","summary":"아직 작성 중인 글입니다. 중도에 내용이 변경 될 수 있습니다.\n최근에 현장에 내보낸 테스트용 기기\n","title":"러스트 임베디드 양산 제품 개발기 - 1 개발/양산 과정부터 설명","type":"posts"},{"content":"","date":"2023년 4월 8일","externalUrl":null,"permalink":"/ko/tags/amd/","section":"Tags","summary":"","title":"AMD","type":"tags"},{"content":"","date":"2023년 4월 8일","externalUrl":null,"permalink":"/ko/tags/cache/","section":"Tags","summary":"","title":"Cache","type":"tags"},{"content":"","date":"2023년 4월 8일","externalUrl":null,"permalink":"/ko/categories/cpu/","section":"Categories","summary":"","title":"CPU","type":"categories"},{"content":"","date":"2023년 4월 8일","externalUrl":null,"permalink":"/ko/tags/ryzen/","section":"Tags","summary":"","title":"Ryzen","type":"tags"},{"content":"","date":"2023년 4월 8일","externalUrl":null,"permalink":"/ko/tags/silicon-bug/","section":"Tags","summary":"","title":"Silicon Bug","type":"tags"},{"content":"이제 어느정도 ZEN4가 팔린지도 오래되었으며 ZEN3도 stepping? 내부적인 revision이 몇번 바뀌어 개선이 된 것 같아 적당한 시기다 싶어서 이 글을 작성합니다. 이 글은 다른 커뮤니티에도 올렸고 어떻게 보면 개발과 거리가 있으나 CPU 내부를 다루는 관계로 개발블로그에도 옮깁니다.\n전력사용량이 크게 달라지는 경우 Instruction L1, L2 cache 가 장애가 발생함 # 퀘이사존에 WHEA 만 검색해도 수많은 글을 볼 수 가 있습니다.\n과거에 수많은 사람들이 AMD Zen2/ Zen3를 쓰면서 이러한 문제점들은 보고했습니다.\n갑자기 WHEA 18에러가 Windows상의 Event Logger에 뜬다. 갑자기 꺼진다. [Halt] (로그 찾을 수 없음) 갑자기 리셋된다. [Reset] (로그 찾을 수 없음) 아무것도 안하고있는데 위와 같은 현상이 일어난다. C-State를 Disable하니 이러한 이슈가 덜 생긴다. C-State를 끄세요 저 또한 3950x를 과거에 쓰면서 이러한 이슈를 겪었으며 이로 인해서 매우 많은 시간을 허비했으며 결국에는 3950x를 5950x(최근의 Stepping Revision) 그리고 그 중간에 임시로 쓰게되는 5900x를 구매하면서\n컴퓨터가 2대가 되는 자가증식까지 하는 상황까지 겪었습니다. 그리고 이과정에 메인보드는 3번 구매했습니다.\n여기 까지 글을 읽으시면 몇가지 키워드가 보이실겁니다.\n키워드1 키워드2 키워드3 Instruction L1, L2 cache C-State Reset/Halt C-State란 # C-State부터 먼저 설명하겠습니다. 출처 : https://www.dell.com/support/kbdoc/ko-kr/000060621/c-state%EB%8A%94-%EB%AC%B4%EC%97%87%EC%9D%B8%EA%B0%80\nC-State 는 CPU소모전력을 줄일 수 있는 기능으로, 사용을 덜하는 경우 최대한으로 줄입니다.\n실제로 AMD은 Intel이든 C-State를 켠상태에서 PC가 Idle시 사용되는 전력사용량은 UPS로 확인시 매우 큽니다. 10W정도에서 20W정도 차이가 납니다. 이정도 차이면 이번에 새로나온 Intel Alderlake-N100 MiniPC를 충분히 구동할 수 있는 전력이죠. 또한 이 기능은 1990년대에 나온 기능으로 사실상 그냥 지원을 온전히 보장 해주는게 맞는 좋은 기능입니다.\nInstruction L1, L2 cache 란 # 컴퓨터공학과 학부에서 배우는 \u0026ldquo;컴퓨터 구조론\u0026rdquo; 과목에서 배우는 메모리 모델부터 설명을 해보겠습니다.\n[출처 : https://diveintosystems.org/book/C11-MemHierarchy/mem_hierarchy.html ]\n근대의 메모리 시스템은 이와같이 피라미드 형태로 되어있습니다.\n가장 꼭대기에 있는 register부터 cache을 거쳐 Flash Disk 그리고 그아래까지 접근시간과 대신 담고 있는 양 (용량)의 차이가 비례해서 올라갑니다.\nCPU입장에서 register에 접근하는데는 가장 짧은 시간이 걸리는 대신 register의 면적당 가격은 매우 비싸며\n뒤로 갈수록 시간은 좀 걸리는 대신 가격은 싸집니다.\n이 그림에서는 register/cache/Main Memory 사이의 용량이 나와있지는 않지만 사용하는 시스템/목적에 따라 사용될 용량의 분배는 매우 중요할것이며, \u0026ldquo;어떻게 나뉘냐\u0026rdquo; 를 잘 배분 하는 것이 중요합니다. 여기서 사용자가 마음대로 할 수 있는것이라면 디램을 많이 때려박아주는게 될 수 있겠습니다.\n그러면 Instruction L1, L2 cache 은 무엇인가 하면\nCPU는 데이터를 처리를 빨리 접근/읽기 위해서도 cache가 필요하지만\ncache는 CPU가 명령어 소화를 빨리 하기위해서도 cache가 필요합니다.\n데이터를 읽는 목적이나 명령어를 처리하는 과정에서 cache에 데이터가 없다면 DRAM(main memory)에서 가져오는 동안 사실상 일을 멈추고 있는 상태가 됩니다. (파이프라이닝 개념은 여기서 고려안하겠습니다.)\n그리고 뒤에있는 1/2는 1은 CPU각 코어에 가장 빨리 접근할수 있는 공간이며 2는 1보다는 약간 멀리떨어진 계층입니다. (그래도 DRAM보다는 가깝습니다.)\n다시 Zen2/3로 돌아와서 설명하자면 Zen2/3에서 나온 CPU는 16코어 짜리 제품으로서 가장 코어가 많습니다. 그리고 멀티다이 구조를 채택하여 8코어를 두개씩 패키징한 제품입니다.\n그래서 실제로는 메모리 모델이 위에잇는 세모 피라미드 모양이 되지않고 피라미드위에 피라미드 2개가 있고 그 2개의 피라미드 위에 피라미드가 8개씩 추가로 있는 구조가 나옵니다.\n위에서 제기한 증상에 대한 자세한 보고 # 조립 PC를 사용하는 대다수의 사용자들은 Windows를 사용하고 있으시며, 이 글에서 언급한 문제를 겪으셨다면\nWindows Event Logger에서 WHEA18?이란 에러가 뜨거나 아예 에러가 뜨지 않은채 꺼지시(reset)거나 멈추셨(Halt)겁니다. Reset이냐 Halt냐는 아마 메인보드에 다를겁니다. 이는 제가 Asrock/Gigabyte/Asus, B550/X570을 3개다 써보면서 각기 다른식으로 에러가 나오는 것을 확인했습니다.\n이 문제를 정확히 분석하려면 우리는 Windows를 들여다볼게 아니라 Linux 커뮤니티에서 해답을 찾을 수 잇습니다.\n[Correctable MCE errors logged for CPU0/CPU12 L1 instruction cache with AMD Ryzen 9 3900X 12-Core Processor] https://bugzilla.redhat.com/show_bug.cgi?id=1830404 [Random freezes and reboots AMD Ryzen] https://bugzilla.kernel.org/show_bug.cgi?id=210261 (두개의 링크 말고도 수많은 보고가 있으나 일단 2개만 게시합니다.)\n글자체가 매우 기니 요약만 한다면\n랜덤한 시간에 아래와 같은 에러가 뜨며 멈춘다. 그리고 CPU를 바꾸니 그냥 해결됬다\nC-State를 키면 문제가 발생하지않거나 덜 발생한다.\nMay 01 15:06:59 kernel: mce: [Hardware Error]: Machine check events logged May 01 15:06:59 kernel: [Hardware Error]: Corrected error, no action required. May 01 15:06:59 kernel: [Hardware Error]: CPU:12 (17:71:0) MC1_STATUS[Over|CE|MiscV|AddrV|-|-|SyndV|-|-|-]: 0xdc20000000030151 May 01 15:06:59 kernel: [Hardware Error]: Error Addr: 0x000000076da32ae0 May 01 15:06:59 kernel: [Hardware Error]: IPID: 0x000100b000000000, Syndrome: 0x000000001a030507 May 01 15:06:59 kernel: [Hardware Error]: Instruction Fetch Unit Ext. Error Code: 3, IC Data Array Parity Error. May 01 15:06:59 kernel: [Hardware Error]: cache level: L1, tx: INSN, mem-tx: IRD May 01 15:06:59 kernel: mce: [Hardware Error]: Machine check events logged May 01 15:06:59 kernel: [Hardware Error]: Corrected error, no action required. May 01 15:06:59 kernel: [Hardware Error]: CPU:0 (17:71:0) MC1_STATUS[Over|CE|MiscV|AddrV|-|-|SyndV|-|-|-]: 0xdc20000000030151 May 01 15:06:59 kernel: [Hardware Error]: Error Addr: 0x0000000fbedc2ae0 May 01 15:06:59 kernel: [Hardware Error]: IPID: 0x000100b000000000, Syndrome: 0x000000001a030507 May 01 15:06:59 kernel: [Hardware Error]: Instruction Fetch Unit Ext. Error Code: 3, IC Data Array Parity Error. May 01 15:06:59 kernel: [Hardware Error]: cache level: L1, tx: INSN, mem-tx: IRD 에러에 대한 원인 추측/분석 # 특정 상황이 매우 드물게 발생하는데 (CPU가 3Ghz 이상이니 1초에 3000000000사이클 일것이며 사이클 관점에서 봤을때 30분에서 24시간중 한번 발생한다하면 매우 드물다는 입장이지, 사용자 입장에서 잦거나 드물다는 표현은 아닙니다.)\n어느 위에 언급한 C-State에서 힌트를 찾았는데요\nC-State가 켜져있다면 매우 짧은 시간에 CPU core에 인가되는 전력이 매우 작다가 매우 커질것이며 C-State가 꺼져있다면 매우 짧은 시간에 CPU core에 인가되는 전력이 약간 적었다가 매우 커질것입니다. 그럼 원인은 짧은 시간내에 CPU Core에 인가되는 전력차에 따라 CPU Instruction $1/$2 에 영향이 가므로\nCPU가 명령어를 수행하다가 $ (캐시)에서 읽어올 명령어 자체가 coruppted(잘못됨)되었으니 CPU는 명령어를 수행할 수 없습니다. 더이상 나아갈 수 도 없으며 사실 이경우 코어덤프 (메모리 덤프)를 남기는 것 조차 기적일 것 입니다. [대충 메모리 디버깅에는 두가지 방법이 있는데요 SW로 전체 메모리를 백업하는 것과 외제차 가격보다 비싼 하드웨어 장비로 메모리를 덤프뜨는 두가지 방법이 있으며 이때는 후자로만 제대로 분석 할 수있습니다.]\n$1/$2 의 내용은 DRAM(Main Memory)와 미러링, 즉 빨리 접근하기위해 담아두는 공간이라고는 하지만.\n실제 운영체제나 프로그램 설계에서는 linux의 per-cpu 변수 처럼 대체적으로 각 아키텍처의 $1(L1 캐시) 사이즈와 같거나 그보다 작은 크기를 블럭단위로 하며 SMP 시스템 (멀티 코어 시스템)에서 더 DRAM에 저장되지 않고 더 빠르게 읽고 쓰기위해 DRAM에 주소와 메모리 정보가 저장은 되어있지만 사실상 DRAM보다는 캐시에 정확한 정보가 적혀있다고 전제되는 값들이 있습니다. 만약 $1/$2를 믿을수 없는 상황이 되면 per-cpu와 같은 특성을 가진 변수(컴퓨터 프로그램이 사용하는 값)은 제대로 쓸수도 없게 될것이며 이는 Instruction에도 비슷하게 적용이 될수도있습니다.\n진짜 이문제가 CPU에 인가되는 전력의 급격한 변화에 따른 것인지는 어디까지나 추측이지만\n이렇게 많은 사람들이 $1/$2에 문제가 있다고 하는 것은 개인적인 소견으로서는 리콜 감입니다.\n뒤에 있는 per-cpu어쩌구 저쩌구는 학부에서 배우진 않지만 CPU $1/$2는 학부에서 배우는 수준의 지식이며, 기본적인 설계에서 미스가 있는 것 이니까요.\nper-cpu 에 대한 자세한 링크 : http://jake.dothome.co.kr/per-cpu/\n그래서 AMD와 유통사는 어떻게 대응하는가 # 그래서 AMD와 유통사는 어떻게 대응하는가. 유통사가 어떻게 불량점검을 하는지 보면 부팅을 하고 벤치마크 프로그램을 돌립니다. 이게 끝입니다. 사실상 이러한 문제는 전문적으로 Trace32같은 장비를 쓰지않는 이상 문제를 찾기 어렵습니다.\n[출처 : https://www2.lauterbach.com/pdf/general_ref_c.pdf 172페이지]\nTrace32 를 사용하면 실시간으로 CPU의 모든 값을 볼수가있습니다. 일반인 혹은 대다수의 개발자가 고작 할수 있는 방법은 그냥 메모리 주소에 접근하는것이 다이나 이건 DRAM의 값인지 Cache 의 값인지 알수가 없습니다. 이러한 고급 개발툴도 필요하지만 이런 도구를 써서 유통사가 AS를 한다는것은 사실상 불가능에 가깝습니다. 따라서 AS를 진행하시는 직원 분들도 해당 이슈에 대해서는 매우 곤란할 것입니다.\n소비자 입장에서도 이를 입증하고 교환받기가 매우 까다롭습니다.\n그럼 제 생각에 잘못은 AMD에 있습니다.\n처음에 QC에 문제가 있거나, 실리콘 설계를 할때 이러한 문제를 제대로 검증 및 수정하지 않고 판매한 것이 문제라고 생각합니다.\n그래서 AMD는 자기네 CPU의 결함에 대해서 공개를 하거나 공유하는가?\n아뇨 인텔보다는 훨씬 숨기고있습니다.\n일단 인텔은 Errata Sheet (설계결함, 이슈에 대해 정리한 페이퍼) 를 나온지 얼마 안된 13세대에 대해서 공유했습니다.\n[ Intel Raptor Lake S - Errata Details ] https://edc.intel.com/content/www/us/en/design/products/platforms/details/raptor-lake-s/13th-generation-core-processor-specification-update/errata-details/\n그런데 AMD는 소비자용 Zen2 : Family 17h Model 71h , Zen3 : Family 19h Model 21h에 대한 Errata Sheet를 공개하지 않았습니다.\n칩을 구매해서 직접 PCB 회로를 만드시거나 리눅스 커널 드라이버를 작성하는 업무를 하시는 분들은 ErrataSheet를 들어보시고 가끔 거기서 문제점을 찾아 다시 부품 선정을 하거나 고려해서 소프트웨어 상으로 실리콘 버그를 해결 하는 경우가 있을 겁니다만\n이렇게 심각한 문제에 대해서 아무런 고지를 하지않고 그냥 아름아름 인터넷상으로 C-State Disable하라는 글에 의존하면서 이러한 이슈를 숨기는것에 대해 매우 실망스럽습니다.\n앞으로는 이러한 메모리 계층 구조(memory hierarchy)에 심각한 문제가 있는 제품의 결함을 제대로 고시하지않는 AMD가 바뀌길 기대하며 memory 를 좋아하는 고양이 사진으로 이 글을 마칩니다. ","date":"2023년 4월 8일","externalUrl":null,"permalink":"/ko/posts/casts_double_amd_desktop_zen_2_and_3_halt_randomly_kr/","section":"Posts","summary":"이제 어느정도 ZEN4가 팔린지도 오래되었으며 ZEN3도 stepping? 내부적인 revision이 몇번 바뀌어 개선이 된 것 같아 적당한 시기다 싶어서 이 글을 작성합니다. 이 글은 다른 커뮤니티에도 올렸고 어떻게 보면 개발과 거리가 있으나 CPU 내부를 다루는 관계로 개발블로그에도 옮깁니다.\n","title":"ZEN 2/3 의 QC/설계결함으로 인한 간혈적 리셋/멈춤 의혹 제기","type":"posts"},{"content":"","date":"2022년 12월 20일","externalUrl":null,"permalink":"/ko/tags/dsp/","section":"Tags","summary":"","title":"DSP","type":"tags"},{"content":"","date":"2022년 12월 20일","externalUrl":null,"permalink":"/ja/tags/english_article/","section":"Tags","summary":"","title":"English_Article","type":"tags"},{"content":"","date":"2022년 12월 20일","externalUrl":null,"permalink":"/ko/categories/math/","section":"Categories","summary":"","title":"Math","type":"categories"},{"content":"","date":"2022년 12월 20일","externalUrl":null,"permalink":"/ko/tags/mathmatics/","section":"Tags","summary":"","title":"Mathmatics","type":"tags"},{"content":"","date":"2022년 12월 20일","externalUrl":null,"permalink":"/ko/tags/signal-processing/","section":"Tags","summary":"","title":"Signal Processing","type":"tags"},{"content":" 1. 연속 신호의 푸리에 급수 계수 # 계수 유도 문제는 주기 신호와 함께 출제됩니다.: \\(x(t) \\rightarrow a_k\\)\n1.1 (CT FS) 연속 푸리에 계수의 기본 개념 # $$ \\begin{gathered} x(t): \\text { Periodic signal } \\ T: \\text { Fundamental Period } \\ \\end{gathered} $$\n$$ \\begin{gathered} \\omega_0=\\frac{2 \\pi}{T} \\quad \u0026amp; \\quad f_0=\\frac{1}{T}(\\text { freq }) \\ \\end{gathered} $$\n$$ \\begin{gathered} \\quad x(t)=\\sum_{k=-\\infty}^{+\\infty} a_k e^{j k \\omega_0 t}=\\sum_{k=-\\infty}^{+\\infty} a_k e^{j k(2 \\pi / T) t} \\end{gathered} $$\n1.2 (CT FS) 연속시간 푸리에 급수 # 주기 신호를 푸리에 계수로 변환 : \\(x(t) \\stackrel{F S}{\\rightarrow} a_k\\)\n$$ \\begin{gathered} a_k=\\frac{1}{T} \\int _T x(t) e^{-j k \\omega_0 t} d t \\ \\end{gathered} $$ $$ or $$\n$$ \\begin{gathered} a_k=\\frac{1}{T} \\int_T x(t) e^{-j k(2 \\pi / T) t} d t \\end{gathered} $$\n1.3 (CT IFS) 연속시간 역 푸리에 급수 # 푸리에 계수를 주기 신호로 변환 : \\(a_k \\stackrel{I F S}{\\longrightarrow} x(t)\\)\n$$ x(t)=\\sum_{k=-\\infty}^{+\\infty} a_k e^{j k \\omega_0 t}=\\sum_{k=-\\infty}^{+\\infty} a_k e^{j k(2 \\pi / T) t} $$\n1.4 연속시간 푸리에 급수의 성질 # 연속시간 신호 \\(x(t)\\)에 대한 푸리에 변환. 대부분의 경우 비주기 신호가 출제됩니다\u0026hellip;\n2. 이산 신호의 푸리에 계수 # $$ \\begin{gathered} x[n] \\rightarrow \\boldsymbol{a}_{\\boldsymbol{k}} \\end{gathered} $$ 계수 유도 문제는 주기 신호와 함께 출제됩니다.\n2.1 (DT FS) 이산 푸리에 계수의 기본 개념 \\(x[n]: Periodic\\) # $$ \\begin{gathered} x[n]: \\text { Periodic signal } \\end{gathered} $$\n$$ N \\text { : Fundamental Period (LCM of } 2 \\pi \\text { ) } $$\n$$ \\begin{gathered} \\omega_0=\\frac{2 \\pi}{N} \\quad \u0026amp; \\quad f_0=\\frac{1}{T}(\\text { freq }) \\end{gathered} $$\n$$ x[n]=\\sum_{k=\\langle N\\rangle} a_k e^{j k \\omega_0 n}=\\sum_{k=\\langle N\\rangle} a_k e^{j k(2 \\pi / N) n} $$\n2.3 (DT FS) 이산시간 푸리에 급수 # $$\\begin{gathered} a_{k}=\\frac{1}{N} \\sum_{n=\\langle N\\rangle} x[n] e^{-j k \\omega_{0} n} \\ a_{k}=\\frac{1}{N} \\sum_{n=\\langle N\\rangle} x[n] e^{-j k(2 \\pi / N) n} \\end{gathered}$$\n$$\\begin{aligned} \u0026amp; x[n] \\stackrel{F S}{\\rightarrow} a_{k} \\end{aligned}$$\n2.4 (DT IFS) 이산시간 역 푸리에 급수 # $$a_{k} \\stackrel{I F S}{\\rightarrow} x[n] \\quad x[n]=\\sum_{k=\\langle N\\rangle} a_{k} e^{j k \\omega_{0} n}=\\sum_{k=\\langle N\\rangle} a_{k} e^{j k(2 \\pi / N) n}$$\n2.5 연속시간 푸리에 급수의 성질 # 3 연속시간 신호 \\(x(t)\\)의 푸리에 변환 : # 3.1 (CT FT) 연속시간 푸리에 변환 (주기) # $$ x(t) \\stackrel{F T}{\\longrightarrow} X(j \\omega) $$\n$$ \\tilde{x}(t): \\text { single sliced periodic sig } \\ $$\n$$ a_k=\\frac{1}{T} \\int_{-\\frac{T}{2}}^{\\frac{T}{2}} \\tilde{x}(t) e^{-j k \\omega_0 t} d t $$ $$ X(j \\omega)=T a_k $$\n3.2 (CT FT) 연속시간 푸리에 변환 (비주기) # $$x(t) \\stackrel{F T}{\\rightarrow} X(j \\omega) \\quad X(j \\omega)=\\int_{-\\infty}^{+\\infty} x(t) e^{-j \\omega t} d t$$\n3.3 (CT IFT) 연속시간 역 푸리에 변환 # $$X(j w) \\stackrel{I F T}{\\rightarrow} x(t) \\quad x(t)=\\frac{1}{2 \\pi} \\int_{-\\infty}^{+\\infty} X(j \\omega) e^{j \\omega t} d \\omega$$\n3.4 연속 푸리에 변환의 성질 # 3.5 기본 연속 푸리에 변환 쌍 # 4 이산시간 신호 \\(x[n]\\)의 푸리에 변환 # 대부분의 경우 비주기 신호가 출제됩니다\u0026hellip;\n4.1 (DT FT) 이산시간 푸리에 변환 # $$x[n] \\stackrel{F T}{\\rightarrow} X\\left(e^{j \\omega}\\right) \\quad X\\left(e^{j \\omega}\\right)=\\sum_{n=-\\infty}^{+\\infty} x[n] e^{-j \\omega n}$$\n4.2 (DT IFT) 이산시간 역 푸리에 변환 # $$X\\left(e^{j \\omega}\\right) \\stackrel{I F T}{\\rightarrow} x[n] \\quad x[n]=\\frac{1}{2 \\pi} \\int_{2 \\pi} X\\left(e^{j \\omega}\\right) e^{j \\omega n} d \\omega$$\n4.3 이산 푸리에 변환의 성질 # 4.4 기본 이산 푸리에 변환 쌍 # PDF 버전 # Related files DSP_Fourier_CheatNote.pdf (275 KBytes) ","date":"2022년 12월 20일","externalUrl":null,"permalink":"/ko/posts/discrete_signal_processing_cheat_note/","section":"Posts","summary":"1. 연속 신호의 푸리에 급수 계수 # 계수 유도 문제는 주기 신호와 함께 출제됩니다.: \\(x(t) \\rightarrow a_k\\)\n","title":"이산 신호 처리 푸리에 변환 치트 노트","type":"posts"},{"content":"","date":"2022년 11월 27일","externalUrl":null,"permalink":"/ko/categories/etc/","section":"Categories","summary":"","title":"Etc","type":"categories"},{"content":"새로 이직한 회사에서 Rust를 쓰고 있습니다. 이직한지 5개월이 지나고 느낀 바를 서술 해보고자 합니다. 문법적인 세세한 장점은 제쳐두고 그냥 간단하게 느낀 바를 서술 합니다.\n장점 # 개발하려는 도메인에 잘아는 개발자가 있으며, 최소 2인에서 코드리뷰를 서로 잘해주면 안전하게 코딩할수 있습니다. C언어와 비교를 하면 매우 편리한점이 많습니다. C언어/펌웨어 만 하던 사람으로서는 다른 현대언어 대비 좀더 친숙하게 느껴지고 대부분의 행위/설계가 reasonable 하게 느껴집니다. 개인적인 의견으로는 프론트엔드 빼고는 많은 부분에 적용할 수 있습니다. [펌웨어, 운영체제 종속 유틸리티, 백엔드] 개발하는 비즈니스 로직에 대한것이 아닌 순수 CS에 대한 공부/도전 요소가 계속 생깁니다. 타겟 아키텍처 (CPU, Operating System)가 어떤 것이 오든, 대응하기 매우 편리합니다. 단점 # 우리는 FullStack을 넘어 EntireStack 개발자가 될 수 있을까?\n각각의 고난포인트 마다 기본적으로 요구하는 지식이 큽니다. 가끔은 개인시간을 넘어드는 공부/도전 요소가 계속 생깁니다. [저에겐 단점이 아니나, 사람에 따라 단점이라고 느낄 수 있다고 생각합니다.] 구인시 제한이 많습니다. 이 언어의 장점이 뭐야? 라는 질문을 받았을 때, 요구하는 지식 범위가 매우 커질 수 밖에 없습니다. 그리고 그 지식범위는 대다수의 관심사 저 멀리 일 수 있습니다. 임베디드에서 사용하고, 국내 개발자 풀을 본다면, 같이 러스트를 쓸 임베디드 개발자를 구하기가 어렵고, 임베디드 개발자에게 추가적으로 요구되는 능력의 풀이 꽤 기하급수적으로 늘어납니다. 임베디드 개발을 주(主)로 하진 않으나 rust를 고려하지않아도 임베디드 개발자 풀이 너무 적습니다. 꼭 제가 쓰려고하는 칩은 rust 임베디드 지원이 애매합니다. (여기에 대한 답은 제가 스스로 기여를 하는 것이긴합니다.) 아직까지는 커뮤니티가 chip-shortage인 상황에 알짜베기 단가/lead time 면에서 쓸만한 칩보다는 toy-project로 쓸만한 칩에 더 치중에 되어있습니다. 기타 # 이전회사에서 코드리뷰관련해서 매우 깐깐하게 했었고 지금 회사에서는 어떻게 되나 걱정했었는데. 제가 초반에 느낀바로는 C언어 대비 문법이 고도화 되어있기에 스타일이 지나치게 개인마다 달라서 리뷰할 때 이 문제가 병목사항이라 생각했습니다만. 많은것 들을 clippy가 어느정도 해주고 typo check와 어느정도 선에서 합의볼수 있는 수준의 test만 있으면 리뷰는 문제없네요. 서로가 자연스레 건전한 CS 주제로 토론을 할 수 있습니다 여러 아키텍처에 적절한 대응이 가능 # 이론이나 개념상으로는 순수히 인터프리터 언어 가 멀티플랫폼 대응에 유리합니다. 하지만 제가 실제로 Rust를 해본 경험 조금 다르게 느꼈습니다. 아무리 이론과 개념상으로 인터프리터 언어가 유리하다고는 하나, 진정으로 모든 아키텍처(CPU Arch와 여러 OS에 대응)를 적절하게 잘 대응 하기에는 Rust가 매우 편했습니다.\n우선 모든 아키텍처를 적절하게 대응한다라는 면은 시스템 프로그래밍 혹은 펌웨어 프로그래밍의 가치 중 하나입니다. 그럼 기존에 이러한 프로그래밍을 하기위해서 어떠한 언어를 썼을까요. 바로 C와 **C++**입니다. 하지만 해당 언어로 바로 빠르게 빠르게 시작(Getting Start) 하기위해서는 Makefile 이나 CMake 설정부터 해줘야 했으며, 아키텍처가 추가될 때 마다 이에 대응해줘야 했습니다. 여기에 해당 아키텍처를 위한 컴파일러, 개발환경, 라이브러리 세팅은 별도입니다.\n그럼 다른 언어와 비교를 해보겠습니다. 현재는 Go-Lang과 Rust를 비교하는 사람은 거의 없으나, 5년전에는 많이들 비교했던 것 같습니다. 시스템 프로그래밍의 영역을 OS위에서만 비교한다고 했을때에는 둘 다 훌륭한 언어입니다. 앞으로 말한 것은 매우 무리수인 발언이나, Rust개념상의 no-std, OS가 없거나 일반적인 OS와는 매우 형질이 다른경우에는 대응이 어렵습니다. [필자는 펌웨어 개발을 이전에 하였으며, 제품 출하가 가능한 펌웨어 개발이 가능한가를 추가로 따지고 있습니다.]\nRust는 당장에 빠르게 프로토타이핑 하기는 어렵다. # 앞에서는 Rust의 장점에 대해 칭찬하였지만 이번 문단에서는 살짝 아쉬운면을 서술합니다. Rust는 쓰기 어려운 언어입니다. 정확히 말하면 Rust의 장점을 최대한 살려서 Rust스럽게, Rust의 장점을 최대한 부각시키며 개발하기 매우 어렵습니다. 현실적으로 모든 언어가 장점을 살려서 개발하기에는 매우 어려울 것입니다. 하지만 영리활동(회사/개발조직에서 사용 언어? 프레임워크)으로서 Rust를 선택한다면, 개인적인 선호는 후순위로 미룬 채 회사의 입장에서 생각해봐야합니다.\n우리가 개발할 수 있는 것을 실현해줄 수 있는 매게체인가. 개발자를 적절히 구인할 수 있는가. 개발 시간 소요가 어떻게 되는가. 빠르고 정확하게 돌아가는가. 구성원들이 쓰고싶어하는가. (다른 의미로 취향) Rust는 (2), (3) 항목에서 낮은 점수를 받을 가능성이 크며, 특히나 (2) 항목에서는 절대적으로 그렇다고 생각합니다.\n위와 같은 단점을 극복하고라도 Rust를 선택해야만 한다면 특히나 (4), (5) 의 원인이 클 것입니다. 이렇게 된다면 개발조직, 개발자 입장에서는 최대한 Rust의 장점을 부각하는 사건이나 결과가 있어야지만 이를 자의적이든 타의적이든 유지하게 될 것 입니다.\n아무리 회사에서 정해주는 언어를 쓰면되지만, 그래도 선택할수 있고 Rust를 계속 쓰고싶다면 부각하고 싶을 겁니다. (좀 서술하기 어려운 부분입니다. 감정적인 영역이 겹쳐져 있어서요)\n그러면 Rust 의 장점을 최대한 살려서 개발하려면 많은 지식을 요구하게 되버립니다. 다른 문장으로 러닝 커브가 높아집니다. 어떻게 보면 스스로 무덤을 파는 행위가 될 수도, 기회가 될 수 도 있습니다.\n하지만 많은 지적 가치를 얻을 수 있는 기회 # 처음에 C언어가 나왔을 때는 멀티 프로세싱/프로세서(SMP) 개념이나 캐시의 개념, GPGPU이 없으며, 세세한 부분에 있어서 현대적인 메모리 모델과는 다르던 시절입니다. 그리고 지금까지는 C언어로 이러한 부분을 핸들링 하고 있습니다. 그리고 이러한 개념들을 고려하면서 개발해야하는 상황에 놓인다면 많은 어려움이 있습니다.\n하지만 Rust는 이를 어느정도 쉽게 극복할 수 있는 인프라가 마련되어 있거나, 앞으로도 더 마련될 여지가 있습니다. 그리고 애매한 문장이지만, Rust를 통해 간접으로 어려운 컴퓨터나 운영체제의 아키텍처 설계에 대해 좀더 면밀히 볼 수 있는 기회가 마련이 되는 것 같습니다. 이는 Rust 컴파일러의 안전을 위한 제약경고를 통해서도 얻을 수 있으며, 우연치 않게 많은 고수들로 이뤄진 시스템 프로그래밍 개발자들이 많은 커뮤니티의 영향이 원인으로 작용한다고 생각합니다. 멀티 플랫폼에 대한 얘기를 조금더 하자면, 커뮤니티의 강력함으로 인해 멀티플랫폼이 매우 잘 대응 된다고도 생각합니다.\n언제 쯤 충분한 Rust 개발자가 되었다고 할 수 있을까? # 나는 ____ 개발자야 라고 다들 가끔 식 말하곤 합니다. 그러면 언제 쯤 우리는 충분한 Rust 개발자가 되었다~ 라고 말할 수 있을까요.\n정답은 없습니다.\n하지만 개인적인 생각으로는 해당 프레임워크 혹은 언어가 가져다주는 장점을 남들이 이해할 수 있게끔 설명할 수 있다면 ____ 개발자라고 말 할 수 있지 않을까? 라고 생각합니다.\n하지만 아쉽게도 Rust 는 이를 서술 하기가 매우 어렵습니다. 당장에 소유권 부터 설명해야 합니다만. 일단 기본적으로 실행 중인 processs의 stack, heap 부터 이해를 해야합니다.\n참고 자료 : 4.1 소유권이 뭔가요 - The Rust Programming Language 한국어 번역\n이러한 문제로 설득시키려고 하는 대상에게 많은것을 설명해줄 능력이 되야하거나, 듣는 대상이 수준이 높기에 정확하고 매우 깊은 설명이 요구되는 상황입니다.\n처음부터 설명의 난이도가 HARD MODE 인 것은 아쉽지만, 혼자 개발하는 세상도 아닐 뿐더러, 우리가 개발을 할때에 Pull-Request를 진정으로 넣고 싶다면 Review를 해주는 사람에게 설명을 잘 하거나, 잘 할수 있도록 코드를 짜는 것은 어느정도 필요하다 생각합니다.\n그러한 과정 속에서 설명을 할 수 있는 지식의 바탕과 말 솜씨를 늘릴 수 있으며, 더 나아가서 서술 한대로 어떠한 기술에 대해 설명할 수 있는 능력이 갖춰지지 않을까 생각합니다.\n다음 혹은 다다음에 회고록을 작성 할 때에는 Rust 회사에서 써서 얻었던 실제의 이득, 손실에 대해서 다뤄보도록 하겠습니다.\n","date":"2022년 11월 27일","externalUrl":null,"permalink":"/ko/posts/five_mothes_ago_from_using_rust_as_work_kr/","section":"Posts","summary":"새로 이직한 회사에서 Rust를 쓰고 있습니다. 이직한지 5개월이 지나고 느낀 바를 서술 해보고자 합니다. 문법적인 세세한 장점은 제쳐두고 그냥 간단하게 느낀 바를 서술 합니다.\n","title":"Rust를 회사 업무로 쓰고난지 5개월 정도","type":"posts"},{"content":"","date":"2022년 10월 4일","externalUrl":null,"permalink":"/ko/tags/armv8a/","section":"Tags","summary":"","title":"ARMv8A","type":"tags"},{"content":"","date":"2022년 10월 4일","externalUrl":null,"permalink":"/ko/tags/cross-compile/","section":"Tags","summary":"","title":"Cross Compile","type":"tags"},{"content":"","date":"2022년 10월 4일","externalUrl":null,"permalink":"/ko/categories/linux/","section":"Categories","summary":"","title":"Linux","type":"categories"},{"content":"","date":"2022년 10월 4일","externalUrl":null,"permalink":"/ko/tags/linux/","section":"Tags","summary":"","title":"Linux","type":"tags"},{"content":"10월 6일 기준, Rust for Linux는 linux-next에 있으며 stable이 아닙니다.\n따라서 이 글은 Linux 6.1 stable이 나오기 전에 구식이 될 수 있습니다.\n현재 Linux 6.1 rc1에는 ARM64용 Rust for Linux가 포함되어 있지 않습니다. 따라서 이 글에서는 https://github.com/Rust-for-Linux/linux/tree/for-next/rust 를 사용합니다.\n소개 # 이 글에서는 x86_64 debian 환경에서 Rust for Linux를 크로스 컴파일하는 방법을 설명합니다. Apple Silicon을 제외하면 아직 arm64 네이티브 커널을 빌드할 만한 충분한 컴퓨팅 파워가 없습니다.\n참고로 이 글은 다음 링크를 참고하여 작성되었습니다.\nhttps://github.com/Rust-for-Linux/linux/blob/rust/Documentation/rust/quick-start.rst https://docs.kernel.org/kbuild/llvm.html#cross-compiling Debian / Ubuntu 패키지 요구사항 # # Install build-requirements for kernel compile with LLVM. # Biggest difference to native build is # crossbuild-essential-arm64 needed to build` for arm64 apt install clang git llvm-dev libclang-dev build-essential \\ bc kmod cpio flex libncurses5-dev libelf-dev libssl-dev \\ dwarves bison lld curl crossbuild-essential-arm64 커널 빌드 전에 필요한 패키지를 설치해야 합니다.\ncurl --proto \u0026#39;=https\u0026#39; --tlsv1.2 -sSf https://sh.rustup.rs | sh rustup default 1.62 rustup component add rust-src # rustfmt and clippy is need for later developing and debugging. rustup component add rustfmt rustup component add clippy curl로 Rust를 설치합니다. 기본 옵션을 선택하면 됩니다. 또한 현재 Rust for Linux는 1.62 버전에서 동작합니다. 최신 버전(1.64 테스트 완료)에서도 네이티브 컴파일은 잘 동작하지만, 크로스 컴파일은 동작하지 않습니다.\nArch 패키지 요구사항 # TBD Rust-For-Linux에서 Linux 클론하기 # 현재 Rust-for-Linux의 상태, 6.0 RC 단계\n# In my case use `Develop` as worksapce, you can replace this word. mkdir -p ~/Develop cd ~/Develop git clone https://github.com/Rust-for-Linux/linux.git -b rust 위와 같이 클론합니다.\nRust-For-Linux에 필요한 Rust 스크립트 # 클론한 Linux 디렉토리에서 실행합니다.\ngit clone --recurse-submodules \\ --branch $(scripts/min-tool-version.sh rustc) \\ https://github.com/rust-lang/rust \\ $(rustc --print sysroot)/lib/rustlib/src/rust 이 작업은 rustlib 저장소를 Rust 툴체인 디렉토리에 클론합니다.\ncargo install --locked --version $(scripts/min-tool-version.sh bindgen) bindgen 이 작업은 기존 C 코드를 Rust 코드에 바인딩하기 위해 필요합니다.\nRUST_AVAILABLE 확인 # cd ~/Develop/linux make LLVM=1 rustavailable $ make LLVM=1 rustavailable *** *** Rust compiler \u0026#39;rustc\u0026#39; is too new. This may or may not work. *** Your version: 1.62.1 *** Expected version: 1.62.0 *** Rust is available! 위와 같은 결과가 나오면 준비 완료입니다. (1.62.1에서도 크로스 컴파일이 잘 되었지만, 최적의 호환을 위해서는 rustup default 1.62.0을 실행하세요.)\nmenuconfig로 Linux 소스코드 설정하기 # make ARCH=arm64 CROSS_COMPILE=aarch64-linux-gnu- defconfig make ARCH=arm64 CROSS_COMPILE=aarch64-linux-gnu- menuconfig General setup -\u0026gt; Rust support # General setup -\u0026gt; Rust support에서 이 옵션을 활성화합니다. 만약 해당 플래그가 보이지 않으면 make LLVM=1 rustavailable 과정이 성공적으로 완료되었는지 다시 확인하세요. For a detailed mailing thread on CONFIG_RUST see here. See details \u0026rharu; Kernel hacking -\u0026gt; Sample kernel code # Rust 커널 코드를 쉽게 개발하기 위해 예제가 필요합니다. 다음 메뉴에서 예제를 활성화할 수 있습니다.\nKernel hacking -\u0026gt; Sample kernel code에서 관심 있는 항목을 활성화합니다 (전부 다 활성화할 필요는 없습니다). 직접 드라이버를 작성할 때는 활성화하지 않는 것을 권장합니다. 시스템이 느려지거나 dmesg에 불필요한 로그가 남을 수 있기 때문입니다. 특히 netfilter 예제는 너무 많은 dmesg를 출력하므로, netfilter 예제를 공부하는 경우가 아니라면 비활성화하는 것을 권장합니다. Kernel hacking -\u0026gt; Rust hacking # Rust 커널 코드나 드라이버를 디버깅하려면 일부 디버그 옵션을 활성화해야 합니다.\nKernel hacking -\u0026gt; Rust hacking에서 해당 메뉴와 하위 메뉴를 활성화합니다.\n크로스 컴파일 # # -j4 for 4 core virtual machine, -j2 for 2 core, -j1 for single core. make ARCH=arm64 CROSS_COMPILE=aarch64-linux-gnu- LLVM=1 -j32 위 명령어로 빌드합니다. 가상 머신에 할당된 코어 수를 고려하여 job 수를 설정해야 합니다. (-j#)\n빌드 중에 일부 플래그에 대해 질문이 나올 수 있습니다. 저는 기본값을 선택했습니다.\n간단한 컴파일 속도 비교 # 머신 / 환경 컴파일 시간 M1 Max 가상 머신 (4코어 8GB RAM, aarch64 debian11) 16분 M1 Asahi Linux (4P+4E 코어 16GB RAM MacMini, 6.1.0-rc6-asahi) 11분 AMD Ryzen 5950x 네이티브 (16코어 32스레드, 64GB, x86_64) 3분 AMD Threadripper Pro 5975wx 네이티브 (32코어 64스레드, 256GB, x86_64) 2분 크로스 컴파일된 커널을 arm64 가상 머신에 설치하기 # TBD, 곧 업데이트 예정입니다. 크로스 컴파일된 커널을 라즈베리 파이에 설치하기 # TBD, 곧 업데이트 예정입니다. ","date":"2022년 10월 4일","externalUrl":null,"permalink":"/ko/posts/cross_compiling_aarch64_rust_for_linux_from_x86_64_linux/","section":"Posts","summary":"10월 6일 기준, Rust for Linux는 linux-next에 있으며 stable이 아닙니다.\n따라서 이 글은 Linux 6.1 stable이 나오기 전에 구식이 될 수 있습니다.\n","title":"x86_64 머신에서 aarch64(arm64) Rust for Linux 크로스 컴파일하기","type":"posts"},{"content":"10월 기준, Rust for Linux는 linux-next에 있으며 stable이 아닙니다.\n따라서 이 글은 Linux 6.1 stable이 나오기 전에 구식이 될 수 있습니다.\nmodules, out-of-tree # 커널 모듈을 개발하는 방법은 크게 두 가지가 있습니다. In-Of-Tree와 Out-Of-Tree 방식입니다. 이 글에서는 Out-Of-Tree 방식으로 Rust 커널 모듈을 만들어 보겠습니다.\n시작하기 전에 # 커널이 CONFIG_RUST=y로 컴파일되었는지 확인하기 # 다음 명령어로 확인합니다.\nzcat /proc/config.gz | grep -i CONFIG_RUST=y 결과가 CONFIG_RUST=y로 나오면 됩니다.\n하지만 배포판 커널 이미지를 다운로드하거나 사전 설치된 경우에는 /proc/config.gz에서 확인할 수 없을 수도 있습니다.\nNeed some build \u0026 install rust support kernel see here. See details \u0026rharu; $KDIR 준비 # $KDIR은 커널 소스의 경로입니다.\n이 글에서는 CONFIG_RUST로 부팅에 사용된 커널 소스의 경로를 의미합니다.\nKDIR and other kernel module descriptions See details \u0026rharu; 제 경우에는 ~/Develop/linux입니다.\n# /home/pmnxis/Develop/linux export KDIR=$HOME/Develop/linux 코드 살펴보기 # 코드 rust_out_of_tree.rs 를 미리 살펴봅시다\u0026hellip;\n라이선스와 import # 1 2 3 4 5 6 7 8 9 10 11 12 13 // SPDX-License-Identifier: GPL-2.0 //! Rust out-of-tree sample use kernel::prelude::*; module! { type: RustOutOfTree, name: \u0026#34;rust_out_of_tree\u0026#34;, author: \u0026#34;Rust for Linux Contributors\u0026#34;, description: \u0026#34;Rust out-of-tree sample\u0026#34;, license: \u0026#34;GPL\u0026#34;, } 1~3번 줄은 파일의 라이선스 정보를 나타냅니다. 회사에서 코드를 작성하는 경우 GPL-2.0 대신 SomeCompanyName을 사용하거나 그대로 GPL-2.0을 유지합니다. 1 2 3 4 5 6 7 8 9 10 11 12 13 // SPDX-License-Identifier: GPL-2.0 //! Rust out-of-tree sample use kernel::prelude::*; module! { type: RustOutOfTree, name: \u0026#34;rust_out_of_tree\u0026#34;, author: \u0026#34;Rust for Linux Contributors\u0026#34;, description: \u0026#34;Rust out-of-tree sample\u0026#34;, license: \u0026#34;GPL\u0026#34;, } 5번 줄은 이 코드에서 사용할 Rust for Linux 라이브러리를 가져오는 것을 의미합니다.\n다음 예제에서 C로 작성된 모듈은 이렇게 include합니다.\n2 3 4 #include \u0026lt;linux/module.h\u0026gt; #include \u0026lt;linux/kthread.h\u0026gt; #include \u0026lt;linux/irq_work.h\u0026gt; 1 2 3 4 5 6 7 8 9 10 11 12 13 // SPDX-License-Identifier: GPL-2.0 //! Rust out-of-tree sample use kernel::prelude::*; module! { type: RustOutOfTree, name: \u0026#34;rust_out_of_tree\u0026#34;, author: \u0026#34;Rust for Linux Contributors\u0026#34;, description: \u0026#34;Rust out-of-tree sample\u0026#34;, license: \u0026#34;GPL\u0026#34;, } 8번 줄은 module trait의 구현체입니다. 9번 줄은 모듈의 이름으로, C로 작성했을 때 *.ko의 name 필드에 해당합니다. 10~12번 줄은 아래의 C로 작성된 예제와 동일한 목적의 필드입니다.\n56 57 58 MODULE_AUTHOR(\u0026#34;Steven Rostedt\u0026#34;); MODULE_DESCRIPTION(\u0026#34;trace-printk\u0026#34;); MODULE_LICENSE(\u0026#34;GPL\u0026#34;); macro_rule! module을 간단히 살펴보겠습니다. 자세한 내용은 여기를 참고하세요.\nDetails for module! See details \u0026rharu; 실제 구현 # 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 struct RustOutOfTree { numbers: Vec\u0026lt;i32\u0026gt;, } impl kernel::Module for RustOutOfTree { fn init(_name: \u0026amp;\u0026#39;static CStr, _module: \u0026amp;\u0026#39;static ThisModule) -\u0026gt; Result\u0026lt;Self\u0026gt; { pr_info!(\u0026#34;Rust out-of-tree sample (init)\\n\u0026#34;); let mut numbers = Vec::new(); numbers.try_push(72)?; numbers.try_push(108)?; numbers.try_push(200)?; Ok(RustOutOfTree { numbers }) } } impl Drop for RustOutOfTree { fn drop(\u0026amp;mut self) { pr_info!(\u0026#34;My numbers are {:?}\\n\u0026#34;, self.numbers); pr_info!(\u0026#34;Rust out-of-tree sample (exit)\\n\u0026#34;); } } 동작을 추측해보면\u0026hellip;\ninit (insmod?) 시, Rust out-of-tree sample (init) 텍스트를 어딘가에 출력 vec\u0026lt;i32\u0026gt;[72, 108, 200]이 RustOutOfTree 구조체와 함께 커널 메모리 공간에 저장됨 모듈을 drop (rmmod?) 할 때, [72, 108, 200] 텍스트를 출력 여기서 주의 깊게 봐야 할 부분이 있습니다.\n23 24 let mut numbers = Vec::new(); numbers.try_push(72)?; 24번 줄에서 try_push는 std::Vec에는 존재하지 않습니다. Rust 커널 프로그래밍에서는 std::Vec::push 대신 try_push를 사용해야 합니다.\nDetails for alloc::vec::Vec See details \u0026rharu; 또한 20번 줄과 33번 줄에 `init`과 `drop` 함수가 있습니다. 이 코드는 `impl for` 패턴으로 해당 함수들을 구현하고 있습니다. Details for Implementation in rust See details \u0026rharu; 구현체와 그 철학에 대해서는 이후 글에서 설명하겠습니다.\n코드 실행 # 빌드하기 # make LLVM=1 Rust를 지원하는 커널 빌드가 LLVM으로 이루어졌으므로,\n커널 모듈도 LLVM으로 컴파일합니다.\n모듈 설치 # sudo insmod ./rust_out_of_tree.ko 컴파일 후 프로젝트 디렉토리 안에 rust_out_of_tree.ko가 생성됩니다.\n기존에 사용하던 것처럼 insmod로 모듈을 설치할 수 있습니다.\n결과 확인 # # do `sudo rmmod rust_out_of_tree` if you already install the module` # clear all of dmesg log sudo dmesg -C # install the module sudo insmod ./rust_out_of_tree.ko # see log dmesg # uninstall the module sudo rmmod rust_out_of_tree # check log again. dmesg 위 명령어로 실제 결과를 확인할 수 있습니다.\n예상한 대로 [72, 108, 200]이 출력됩니다.\n결론 # 이 간단한 커널 모듈에서 다음과 같은 내용을 정리할 수 있습니다.\n요약 # 코드 상단에 use kernel::prelude::*;를 사용해야 합니다. module! 매크로로 설명을 정의하고 자신의 구조체를 커널 모듈에 등록합니다. kernel::Module 템플릿 함수 \u0026hellip;. -WIP- 커널 프로그래밍에서는 std::Vec 대신 alloc::vec::Vec를 사용합니다. pr_info는 C에서 사용하는 방식과 동일합니다. 참고 # https://github.com/Rust-for-Linux/rust-out-of-tree-module https://www.kernel.org/doc/html/latest/kbuild/modules.html https://github.com/Rust-for-Linux/linux https://rust-for-linux.github.io/docs/kernel/prelude/index.html https://rust-for-linux.github.io/docs/kernel/prelude/macro.module.html https://rust-for-linux.github.io/docs/kernel/prelude/struct.Vec.html ","date":"2022년 10월 2일","externalUrl":null,"permalink":"/ko/posts/look_into_simple_rust_out_of_tree/","section":"Posts","summary":"10월 기준, Rust for Linux는 linux-next에 있으며 stable이 아닙니다.\n따라서 이 글은 Linux 6.1 stable이 나오기 전에 구식이 될 수 있습니다.\n","title":"[Rust Driver] 예제 Rust Linux 드라이버를 빌드해보자","type":"posts"},{"content":"","date":"2022년 10월 2일","externalUrl":null,"permalink":"/ko/tags/rust-driver/","section":"Tags","summary":"","title":"Rust Driver","type":"tags"},{"content":"10월 1일 기준, Rust for Linux는 linux-next에 있으며 stable이 아닙니다.\n따라서 이 글은 Linux 6.1 stable이 나오기 전에 구식이 될 수 있습니다.\n이 글에서는 https://github.com/Rust-for-Linux/linux/tree/for-next/rust 를 사용합니다.\n소개 # 현재 Apple Silicon Mac 시리즈는 일반 데스크톱급 워크스테이션 성능을 갖추면서 어디서든 구매할 수 있는 유일한 ARM 워크스테이션입니다. 물론 32GB 이상의 메모리와 최소 8개의 빅 코어를 갖춘 Apple Silicon이어야 합니다.\n참고로 이 글은 https://github.com/Rust-for-Linux/linux/blob/rust/Documentation/rust/quick-start.rst 를 참고하여 작성되었습니다.\nVM 하이퍼바이저 소프트웨어 선택 # UTM : 무료 / 오픈소스, QEMU 기반. 가끔 까다로움. VM Fusion Tech Preview : 현재 무료 / 클로즈드소스, 무난함. Parallels : 유료 / 클로즈드소스, 취향이 아님 (죄송합니다). Asahi Linux로 작업하는 옵션도 있습니다. 하지만 이 글에서는 네이티브 Asahi Linux 환경은 고려하지 않습니다.\n제 경우에는 VM Fusion을 선택했습니다.\n가상 머신 구성 # Debian 11 : https://cdimage.debian.org/debian-cd/current/arm64/iso-dvd/ !! 정상 동작 확인 완료.\nUbuntu : aarch64 Ubuntu apt 저장소에서 clang과 다른 gcc 빌드 도구의 버전 불일치로 인해 apt가 깨지는 이슈가 있었습니다. 하지만 Ubuntu로 시도해볼 수는 있습니다.\nArch Linux : https://gitlab.archlinux.org/tpowa/archboot/-/wikis/Archboot-Homepage#aarch64-architecture 아직 테스트하지 않았습니다. 다만 M1 Mac Mini에서 Asahi Linux로는 테스트했습니다.\nDebian / Ubuntu 패키지 요구사항 # # Install build-requirements for kernel compile with LLVM. apt install clang git llvm-dev libclang-dev build-essential \\ bc kmod cpio flex libncurses5-dev libelf-dev libssl-dev \\ dwarves bison lld curl Asahi Linux 패키지 요구사항 # pacman -S base-devel cpio lld llvm llvm-libs bc libdwarf Rust 준비 # 커널 빌드 전에 필요한 패키지를 설치해야 합니다.\ncurl --proto \u0026#39;=https\u0026#39; --tlsv1.2 -sSf https://sh.rustup.rs | sh rustup default 1.62 rustup component add rust-src # rustfmt and clippy is need for later developing and debugging. rustup component add rustfmt rustup component add clippy curl로 Rust를 설치합니다. 기본 옵션을 선택하면 됩니다. 또한 현재 Rust for Linux는 1.62 버전에서 동작합니다. 최신 버전(1.64 테스트 완료)에서도 네이티브 컴파일은 잘 동작하지만, 크로스 컴파일은 동작하지 않습니다.\nRust-For-Linux에서 Linux 클론하기 # 현재 Rust-for-Linux의 상태, 6.0 RC 단계\n# In my case use `Develop` as worksapce, you can replace this word. mkdir -p ~/Develop cd ~/Develop git clone https://github.com/Rust-for-Linux/linux.git -b rust 위와 같이 클론합니다.\nRust-For-Linux에 필요한 Rust 스크립트 # 클론한 Linux 디렉토리에서 실행합니다.\ngit clone --recurse-submodules \\ --branch $(scripts/min-tool-version.sh rustc) \\ https://github.com/rust-lang/rust \\ $(rustc --print sysroot)/lib/rustlib/src/rust 이 작업은 rustlib 저장소를 Rust 툴체인 디렉토리에 클론합니다.\ncargo install --locked --version $(scripts/min-tool-version.sh bindgen) bindgen 이 작업은 기존 C 코드를 Rust 코드에 바인딩하기 위해 필요합니다.\nRUST_AVAILABLE 확인 # cd ~/Develop/linux make LLVM=1 rustavailable $ make LLVM=1 rustavailable *** *** Rust compiler \u0026#39;rustc\u0026#39; is too new. This may or may not work. *** Your version: 1.64.0 *** Expected version: 1.62.0 *** Rust is available! 위와 같은 결과가 나오면 준비 완료입니다.\nmenuconfig로 Linux 소스코드 설정하기 # make ARCH=arm64 defconfig make menuconfig GCC plugins 비활성화 # General architecture-dependent options -\u0026gt; GCC plugins 현재(6.1 rc*) 시점에서 RUST_CONFIG 설정을 위해 GCC_PLUGINS 설정을 비활성화해야 합니다. 반드시 비활성화하세요.\nGeneral setup -\u0026gt; Rust support # General setup -\u0026gt; Rust support에서 이 옵션을 활성화합니다. 만약 해당 플래그가 보이지 않으면 make LLVM=1 rustavailable 과정이 성공적으로 완료되었는지 다시 확인하세요. For a detailed mailing thread on CONFIG_RUST see here. See details \u0026rharu; Kernel hacking -\u0026gt; Sample kernel code # Rust 커널 코드를 쉽게 개발하기 위해 예제가 필요합니다. 다음 메뉴에서 예제를 활성화할 수 있습니다.\nKernel hacking -\u0026gt; Sample kernel code에서 관심 있는 항목을 활성화합니다 (전부 다 활성화할 필요는 없습니다). 직접 드라이버를 작성할 때는 활성화하지 않는 것을 권장합니다. 시스템이 느려지거나 dmesg에 불필요한 로그가 남을 수 있기 때문입니다. 특히 netfilter 예제는 너무 많은 dmesg를 출력하므로, netfilter 예제를 공부하는 경우가 아니라면 비활성화하는 것을 권장합니다. Kernel hacking -\u0026gt; Rust hacking # Rust 커널 코드나 드라이버를 디버깅하려면 일부 디버그 옵션을 활성화해야 합니다.\nKernel hacking -\u0026gt; Rust hacking에서 해당 메뉴와 하위 메뉴를 활성화합니다.\n가상 머신에서 컴파일 및 설치 # # -j4 for 4 core virtual machine, -j2 for 2 core, -j1 for single core. make LLVM=1 -j4 위 명령어로 빌드합니다. 가상 머신에 할당된 코어 수를 고려하여 job 수를 설정해야 합니다. (-j#)\n빌드 중에 일부 플래그에 대해 질문이 나올 수 있습니다. 저는 기본값을 선택했습니다.\n시간이 꽤 걸립니다 (라즈베리 파이 4보다는 훨씬 낫습니다만), 제 환경(VM 4코어, 8GB)에서 13~14분 정도 소요되었습니다.\n빌드 후 다음 명령어로 설치합니다.\n# should be under the root permision. make modules_install make install update-grub 완료되었습니다! 재부팅 후 커널이 정상적으로 동작하는지 확인합니다.\nLinux lambda-next 6.0.0-rc7-175589-g542379556669 #2 SMP PREEMPT Sun Oct 2 19:02:32 KST 2022 aarch64 The programs included with the Debian GNU/Linux system are free software; the exact distribution terms for each program are described in the individual files in /usr/share/doc/*/copyright. Debian GNU/Linux comes with ABSOLUTELY NO WARRANTY, to the extent permitted by applicable law. Last login: Sun Oct 2 18:20:21 2022 from 192.168.99.1 pmnxis@lambda-next:~$ uname -r 6.0.0-rc7-175589-g542379556669 간단한 컴파일 속도 비교 # 머신 / 환경 컴파일 시간 M1 Max 가상 머신 (4코어 8GB RAM, aarch64 debian11) 16분 M1 Asahi Linux (4P+4E 코어 16GB RAM MacMini, 6.1.0-rc6-asahi) 11분 AMD Ryzen 5950x 네이티브 (16코어 32스레드, 64GB, x86_64) 3분 AMD Threadripper Pro 5975wx 네이티브 (32코어 64스레드, 256GB, x86_64) 2분 ","date":"2022년 10월 1일","externalUrl":null,"permalink":"/ko/posts/rust_for_linux_with_m1/","section":"Posts","summary":"10월 1일 기준, Rust for Linux는 linux-next에 있으며 stable이 아닙니다.\n따라서 이 글은 Linux 6.1 stable이 나오기 전에 구식이 될 수 있습니다.\n","title":"Apple Silicon MacOS에서 Rust For Linux 개발 환경 구축하기","type":"posts"},{"content":" Introduction # ARMv8A는 흔히 aarch64로도 불리며 현재 ARMv7A를 뒤로한채 널리 사용하는 아키텍처중 하나입니다. 본 글에서는 ARMv8A의 메모리 시스템을 IP단위로 보려합니다.\n사용하는 메모리 (DDR4 , LPDDR4 , DDR3 , LPDDR3 , DDR2)나 사용하는 아키텍처(ARM v8.1 or 8.2)에 조금씩 다르나 대체적으로 위 사진과 같은 형태로 구성이 되어있습니다.\nComponents # CPU # Instruction을 처리합니다.\nGIC # Generic Interrupt Controller; GIC는 각종 Nested한 Interrupt를 관리하며, Interrupt발생시 CPU에서 동작중이던 PC/Register를 백업하고 해당하는 Inetrrupt Vector를 Execution하도록 합니다.\nCCI / CCN # Cache Coherent Interconnect / Netowrk\nDMC # DRAM을 관리합니다. DRAM은 휘발성 메모리로서 Read/Write 이외에 Refresh, Callibration 와 같은 작업이 필요합니다. 추가적으로 EEC, RAS에 대한 관리도 수행합니다. Linux드라이버에서는 edac 디렉터리에서 EEC, RAS에 대한 관리 드라이버 코드를 확인 할 수 있습니다.\nNIC # 각종 Peripheral 을 연결하는데 사용합니다.\nMMU # PA/VA (Physical/Virtual Address) 변환 DMA 컨트롤 Reference # CCI-400 ; https://developer.arm.com/Processors/CoreLink%20CCI-400 CCI-500 ; https://developer.arm.com/Processors/CoreLink%20CCI-500 DMC-400 ; DDR3/DDR2 DMC ; https://developer.arm.com/documentation/ddi0466/f/introduction/about-the-dmc-400 DMC-500 ; LPDDR4/LPDDR3 DMC ; https://developer.arm.com/documentation/100131/0000 ","date":"2021년 12월 14일","externalUrl":null,"permalink":"/ko/posts/arm_v8a_memory_ip_review/","section":"Posts","summary":"Introduction # ARMv8A는 흔히 aarch64로도 불리며 현재 ARMv7A를 뒤로한채 널리 사용하는 아키텍처중 하나입니다. 본 글에서는 ARMv8A의 메모리 시스템을 IP단위로 보려합니다.\n","title":"ARMv8A Memory IP Review","type":"posts"},{"content":"","date":"2021년 12월 14일","externalUrl":null,"permalink":"/ko/tags/electronics/","section":"Tags","summary":"","title":"Electronics","type":"tags"},{"content":"","externalUrl":null,"permalink":"/ko/authors/","section":"Authors","summary":"","title":"Authors","type":"authors"},{"content":"","externalUrl":null,"permalink":"/ko/series/","section":"Series","summary":"","title":"Series","type":"series"}]