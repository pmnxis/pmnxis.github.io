<!doctype html><html lang=ko dir=ltr class=scroll-smooth data-default-appearance=dark data-auto-appearance=false><head><meta charset=utf-8><meta http-equiv=content-language content="ko-KR"><meta name=viewport content="width=device-width,initial-scale=1"><meta http-equiv=X-UA-Compatible content="ie=edge"><meta name=theme-color><title>Chama Optics 개발기 &#183; Jinwoo Park Blog</title><meta name=title content="Chama Optics 개발기 &#183; Jinwoo Park Blog"><meta name=description content="EXIF 기반 사진 프레임 + 얼굴 자동인식 프로그램, Rust 코어로 데스크탑부터 모바일까지"><meta name=keywords content="Rust,iOS,Cross-Platform,EXIF,"><link rel=canonical href=https://pmnxis.github.io/ko/posts/chama-optics-dev-story/><meta property="og:url" content="https://pmnxis.github.io/ko/posts/chama-optics-dev-story/"><meta property="og:site_name" content="Jinwoo Park Blog"><meta property="og:title" content="Chama Optics 개발기"><meta property="og:description" content="EXIF 기반 사진 프레임 + 얼굴 자동인식 프로그램, Rust 코어로 데스크탑부터 모바일까지"><meta property="og:locale" content="ko_KR"><meta property="og:type" content="article"><meta property="article:section" content="posts"><meta property="article:published_time" content="2026-02-14T00:00:00+09:00"><meta property="article:modified_time" content="2026-02-14T00:00:00+09:00"><meta property="article:tag" content="Rust"><meta property="article:tag" content="IOS"><meta property="article:tag" content="Cross-Platform"><meta property="article:tag" content="EXIF"><meta property="og:image" content="https://pmnxis.github.io/en/posts/chama-optics-dev-story/feature.webp"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://pmnxis.github.io/en/posts/chama-optics-dev-story/feature.webp"><meta name=twitter:title content="Chama Optics 개발기"><meta name=twitter:description content="EXIF 기반 사진 프레임 + 얼굴 자동인식 프로그램, Rust 코어로 데스크탑부터 모바일까지"><meta name=google-site-verification content="VmKxOzBA6bj36Pwan0cjJGtyjeD7hzi9UDxXJ4kCjhI"><link type=text/css rel=stylesheet href=/css/main.bundle.min.b5bc3f4587655153415b7825fd1716f97df9c99f87c23f81146f4dd4f9f49f04ad031e3b5f0ee5c0416707a1455ca2cfa8fc1f3a19ece1486b0126dcd310a63e.css integrity="sha512-tbw/RYdlUVNBW3gl/RcW+X35yZ+Hwj+BFG9N1Pn0nwStAx47Xw7lwEFnB6FFXKLPqPwfOhns4UhrASbc0xCmPg=="><script type=text/javascript src=/js/appearance.min.6f41174b3a05b680820fe08cadbfa5fb7a7ca347b76a0955cdc68b9d8aca1ce24f0547e138cea33bcc7904d551a90afcb1cc7f2d9fe8557075d501419046c08c.js integrity="sha512-b0EXSzoFtoCCD+CMrb+l+3p8o0e3aglVzcaLnYrKHOJPBUfhOM6jO8x5BNVRqQr8scx/LZ/oVXB11QFBkEbAjA=="></script><script src=/lib/zoom/zoom.min.umd.a527109b68c082a70f3697716dd72a9d5aa8b545cf800cecbbc7399f2ca6f6e0ce3e431f2062b48bbfa47c9ea42822714060bef309be073f49b9c0e30d318d7b.js integrity="sha512-pScQm2jAgqcPNpdxbdcqnVqotUXPgAzsu8c5nyym9uDOPkMfIGK0i7+kfJ6kKCJxQGC+8wm+Bz9JucDjDTGNew=="></script><script defer type=text/javascript id=script-bundle src=/js/main.bundle.min.bdda7dece6cbaf08deef7d254f7f842f3261c2524d247905127c9a20decc03f1011a2950048464c79272c1ce0705a49a41147f39f2b95163bb71d404b33263ef.js integrity="sha512-vdp97ObLrwje730lT3+ELzJhwlJNJHkFEnyaIN7MA/EBGilQBIRkx5Jywc4HBaSaQRR/OfK5UWO7cdQEszJj7w==" data-copy=복사 data-copied=복사되었습니다></script><link rel=apple-touch-icon sizes=180x180 href=/apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=/favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=/favicon-16x16.png><link rel=manifest href=/site.webmanifest><script type=application/ld+json>[{"@context":"https://schema.org","@type":"Article","articleSection":"Posts","name":"Chama Optics 개발기","headline":"Chama Optics 개발기","description":"EXIF 기반 사진 프레임 \u002b 얼굴 자동인식 프로그램, Rust 코어로 데스크탑부터 모바일까지","inLanguage":"ko-KR","url":"https://pmnxis.github.io/ko/posts/chama-optics-dev-story/","author":{"@type":"Person","name":""},"copyrightYear":"2026","dateCreated":"2026-02-14T00:00:00\u002b09:00","datePublished":"2026-02-14T00:00:00\u002b09:00","dateModified":"2026-02-14T00:00:00\u002b09:00","keywords":["Rust","iOS","Cross-Platform","EXIF"],"mainEntityOfPage":"true","wordCount":"18947"}]</script></head><body class="flex flex-col h-screen m-auto leading-7 max-w-7xl px-6 sm:px-14 md:px-24 lg:px-32 text-lg bg-neutral text-neutral-900 dark:bg-neutral-800 dark:text-neutral bf-scrollbar"><div id=the-top class="absolute flex self-center"><a class="px-3 py-1 text-sm -translate-y-8 rounded-b-lg bg-primary-200 focus:translate-y-0 dark:bg-neutral-600" href=#main-content><span class="font-bold text-primary-600 pe-2 dark:text-primary-400">&darr;</span>
본문으로 건너뛰기</a></div><div class="main-menu flex items-center w-full gap-2 p-1 pl-0"><div><a href=/ko/ class=flex><span class=sr-only>Jinwoo Park Blog</span>
<img src=/img/LambdaEE.png width=295 height=182 class="logo max-h-20 max-w-20 object-scale-down object-left nozoom" alt></a></div><a href=/ko/ class="text-base font-medium truncate min-w-0 shrink">Jinwoo Park Blog</a><div class="flex items-center ms-auto"><div class="hidden md:flex"><nav class="flex items-center gap-x-5 h-12"><a href=/ko/posts/ class="flex items-center bf-icon-color-hover" aria-label=Blog title=Posts><span class="text-base font-medium break-normal">Blog
</span></a><a href=/ko/tags/ class="flex items-center bf-icon-color-hover" aria-label=Tags title=Tags><span class="text-base font-medium break-normal">Tags
</span></a><a href=/ko/categories/ class="flex items-center bf-icon-color-hover" aria-label=Categories title=Categories><span class="text-base font-medium break-normal">Categories
</span></a><a href=https://github.com/pmnxis target=_blank class="flex items-center bf-icon-color-hover" aria-label=GitHub title><span class="text-base font-medium break-normal">GitHub</span></a><div class="translation nested-menu"><button class="cursor-pointer flex items-center">
<span class=me-1><span class="relative block icon"><svg viewBox="0 0 640 512"><path fill="currentColor" d="M0 128C0 92.7 28.7 64 64 64H256h48 16H576c35.3.0 64 28.7 64 64V384c0 35.3-28.7 64-64 64H320 304 256 64c-35.3.0-64-28.7-64-64V128zm320 0V384H576V128H320zM178.3 175.9c-3.2-7.2-10.4-11.9-18.3-11.9s-15.1 4.7-18.3 11.9l-64 144c-4.5 10.1.1 21.9 10.2 26.4s21.9-.1 26.4-10.2l8.9-20.1h73.6l8.9 20.1c4.5 10.1 16.3 14.6 26.4 10.2s14.6-16.3 10.2-26.4l-64-144zM160 233.2 179 276H141l19-42.8zM448 164c11 0 20 9 20 20v4h44 16c11 0 20 9 20 20s-9 20-20 20h-2l-1.6 4.5c-8.9 24.4-22.4 46.6-39.6 65.4.9.6 1.8 1.1 2.7 1.6l18.9 11.3c9.5 5.7 12.5 18 6.9 27.4s-18 12.5-27.4 6.9L467 333.8c-4.5-2.7-8.8-5.5-13.1-8.5-10.6 7.5-21.9 14-34 19.4l-3.6 1.6c-10.1 4.5-21.9-.1-26.4-10.2s.1-21.9 10.2-26.4l3.6-1.6c6.4-2.9 12.6-6.1 18.5-9.8L410 286.1c-7.8-7.8-7.8-20.5.0-28.3s20.5-7.8 28.3.0l14.6 14.6.5.5c12.4-13.1 22.5-28.3 29.8-45H448 376c-11 0-20-9-20-20s9-20 20-20h52v-4c0-11 9-20 20-20z"/></svg></span>
</span><span class="text-sm font-medium bf-icon-color-hover" title="Chama Optics 개발기">KO</span></button><ul class=menuhide><li class="rounded-xl backdrop-blur shadow-2xl p-2 flex flex-col gap-1"><a href=/ko/posts/chama-optics-dev-story/ class="flex items-center bf-icon-color-hover px-3 py-1"><span class="text-sm font-sm" title="Chama Optics 개발기">KO
</span></a><a href=/ja/posts/chama-optics-dev-story/ class="flex items-center bf-icon-color-hover px-3 py-1"><span class="text-sm font-sm" title="Chama Optics 開発記">JA
</span></a><a href=/en/posts/chama-optics-dev-story/ class="flex items-center bf-icon-color-hover px-3 py-1"><span class="text-sm font-sm" title="Chama Optics Development Story">EN</span></a></li></ul></div><button id=search-button aria-label=Search class="text-base bf-icon-color-hover" title="검색하기 (/)">
<span class="relative block icon"><svg aria-hidden="true" focusable="false" data-prefix="fas" data-icon="search" class="svg-inline--fa fa-search fa-w-16" role="img" viewBox="0 0 512 512"><path fill="currentColor" d="M505 442.7 405.3 343c-4.5-4.5-10.6-7-17-7H372c27.6-35.3 44-79.7 44-128C416 93.1 322.9.0 208 0S0 93.1.0 208s93.1 208 208 208c48.3.0 92.7-16.4 128-44v16.3c0 6.4 2.5 12.5 7 17l99.7 99.7c9.4 9.4 24.6 9.4 33.9.0l28.3-28.3c9.4-9.4 9.4-24.6.1-34zM208 336c-70.7.0-128-57.2-128-128 0-70.7 57.2-128 128-128 70.7.0 128 57.2 128 128 0 70.7-57.2 128-128 128z"/></svg></span></button><div class="flex items-center"><button id=appearance-switcher aria-label="Dark mode switcher" type=button class="text-base bf-icon-color-hover"><div class="flex items-center justify-center dark:hidden"><span class="relative block icon"><svg viewBox="0 0 512 512"><path fill="currentColor" d="M32 256C32 132.2 132.3 32 255.8 32c11.36.0 29.7 1.668 40.9 3.746 9.616 1.777 11.75 14.63 3.279 19.44C245 86.5 211.2 144.6 211.2 207.8c0 109.7 99.71 193 208.3 172.3 9.561-1.805 16.28 9.324 10.11 16.95C387.9 448.6 324.8 480 255.8 480 132.1 480 32 379.6 32 256z"/></svg></span></div><div class="items-center justify-center hidden dark:flex"><span class="relative block icon"><svg viewBox="0 0 512 512"><path fill="currentColor" d="M256 159.1c-53.02.0-95.1 42.98-95.1 95.1s41.2 96.9 95.1 96.9 95.1-42.98 95.1-95.1S309 159.1 256 159.1zM509.3 347l-63.2-91.9 63.15-91.01c6.332-9.125 1.104-21.74-9.826-23.72l-109-19.7-19.7-109c-1.975-10.93-14.59-16.16-23.72-9.824L256 65.89 164.1 2.736c-9.125-6.332-21.74-1.107-23.72 9.824L121.6 121.6 12.56 141.3C1.633 143.2-3.596 155.9 2.736 164.1L65.89 256 2.74 347.01c-6.332 9.125-1.105 21.74 9.824 23.72l109 19.7 19.7 109c1.975 10.93 14.59 16.16 23.72 9.824L256 446.1l91.01 63.15c9.127 6.334 21.75 1.107 23.72-9.822l19.7-109 109-19.7C510.4 368.8 515.6 356.1 509.3 347zM256 383.1c-70.69.0-127.1-57.31-127.1-127.1.0-70.69 57.31-127.1 127.1-127.1S383.1 186.2 383.1 256c0 70.7-56.4 127.1-127.1 127.1z"/></svg></span></div></button></div></nav></div><div class="flex md:hidden"><div class="flex items-center h-14 gap-4"><button id=search-button-mobile aria-label=Search class="flex items-center justify-center bf-icon-color-hover" title="검색하기 (/)">
<span class="relative block icon"><svg aria-hidden="true" focusable="false" data-prefix="fas" data-icon="search" class="svg-inline--fa fa-search fa-w-16" role="img" viewBox="0 0 512 512"><path fill="currentColor" d="M505 442.7 405.3 343c-4.5-4.5-10.6-7-17-7H372c27.6-35.3 44-79.7 44-128C416 93.1 322.9.0 208 0S0 93.1.0 208s93.1 208 208 208c48.3.0 92.7-16.4 128-44v16.3c0 6.4 2.5 12.5 7 17l99.7 99.7c9.4 9.4 24.6 9.4 33.9.0l28.3-28.3c9.4-9.4 9.4-24.6.1-34zM208 336c-70.7.0-128-57.2-128-128 0-70.7 57.2-128 128-128 70.7.0 128 57.2 128 128 0 70.7-57.2 128-128 128z"/></svg>
</span></button>
<button id=appearance-switcher-mobile type=button aria-label="Dark mode switcher" class="flex items-center justify-center text-neutral-900 hover:text-primary-600 dark:text-neutral-200 dark:hover:text-primary-400"><div class=dark:hidden><span class="relative block icon"><svg viewBox="0 0 512 512"><path fill="currentColor" d="M32 256C32 132.2 132.3 32 255.8 32c11.36.0 29.7 1.668 40.9 3.746 9.616 1.777 11.75 14.63 3.279 19.44C245 86.5 211.2 144.6 211.2 207.8c0 109.7 99.71 193 208.3 172.3 9.561-1.805 16.28 9.324 10.11 16.95C387.9 448.6 324.8 480 255.8 480 132.1 480 32 379.6 32 256z"/></svg></span></div><div class="hidden dark:block"><span class="relative block icon"><svg viewBox="0 0 512 512"><path fill="currentColor" d="M256 159.1c-53.02.0-95.1 42.98-95.1 95.1s41.2 96.9 95.1 96.9 95.1-42.98 95.1-95.1S309 159.1 256 159.1zM509.3 347l-63.2-91.9 63.15-91.01c6.332-9.125 1.104-21.74-9.826-23.72l-109-19.7-19.7-109c-1.975-10.93-14.59-16.16-23.72-9.824L256 65.89 164.1 2.736c-9.125-6.332-21.74-1.107-23.72 9.824L121.6 121.6 12.56 141.3C1.633 143.2-3.596 155.9 2.736 164.1L65.89 256 2.74 347.01c-6.332 9.125-1.105 21.74 9.824 23.72l109 19.7 19.7 109c1.975 10.93 14.59 16.16 23.72 9.824L256 446.1l91.01 63.15c9.127 6.334 21.75 1.107 23.72-9.822l19.7-109 109-19.7C510.4 368.8 515.6 356.1 509.3 347zM256 383.1c-70.69.0-127.1-57.31-127.1-127.1.0-70.69 57.31-127.1 127.1-127.1S383.1 186.2 383.1 256c0 70.7-56.4 127.1-127.1 127.1z"/></svg></span></div></button>
<input type=checkbox id=mobile-menu-toggle autocomplete=off class="hidden peer">
<label for=mobile-menu-toggle class="flex items-center justify-center cursor-pointer bf-icon-color-hover"><span class="relative block icon"><svg viewBox="0 0 448 512"><path fill="currentColor" d="M0 96C0 78.33 14.33 64 32 64H416c17.7.0 32 14.33 32 32 0 17.7-14.3 32-32 32H32C14.33 128 0 113.7.0 96zM0 256c0-17.7 14.33-32 32-32H416c17.7.0 32 14.3 32 32s-14.3 32-32 32H32c-17.67.0-32-14.3-32-32zM416 448H32c-17.67.0-32-14.3-32-32s14.33-32 32-32H416c17.7.0 32 14.3 32 32s-14.3 32-32 32z"/></svg></span></label><div role=dialog aria-modal=true style=scrollbar-gutter:stable class="fixed inset-0 z-50 invisible overflow-y-auto px-6 py-20 opacity-0 transition-[opacity,visibility] duration-300 peer-checked:visible peer-checked:opacity-100 bg-neutral-50/97 dark:bg-neutral-900/99
bf-scrollbar"><label for=mobile-menu-toggle class="fixed end-8 top-5 flex items-center justify-center z-50 h-12 w-12 cursor-pointer select-none rounded-full bf-icon-color-hover border bf-border-color bf-border-color-hover bg-neutral-50 dark:bg-neutral-900"><span class="relative block icon"><svg viewBox="0 0 320 512"><path fill="currentColor" d="M310.6 361.4c12.5 12.5 12.5 32.75.0 45.25C304.4 412.9 296.2 416 288 416s-16.38-3.125-22.62-9.375L160 301.3 54.63 406.6C48.38 412.9 40.19 416 32 416S15.63 412.9 9.375 406.6c-12.5-12.5-12.5-32.75.0-45.25l105.4-105.4L9.375 150.6c-12.5-12.5-12.5-32.75.0-45.25s32.75-12.5 45.25.0L160 210.8l105.4-105.4c12.5-12.5 32.75-12.5 45.25.0s12.5 32.75.0 45.25l-105.4 105.4L310.6 361.4z"/></svg></span></label><nav class="mx-auto max-w-md space-y-6"><div class=px-2><a href=/ko/posts/ aria-label=Blog class="flex items-center gap-4 group bf-icon-color-hover text-neutral-700 dark:text-neutral-200"><span title=Posts class="text-2xl font-bold tracking-tight">Blog</span></a></div><div class=px-2><a href=/ko/tags/ aria-label=Tags class="flex items-center gap-4 group bf-icon-color-hover text-neutral-700 dark:text-neutral-200"><span title=Tags class="text-2xl font-bold tracking-tight">Tags</span></a></div><div class=px-2><a href=/ko/categories/ aria-label=Categories class="flex items-center gap-4 group bf-icon-color-hover text-neutral-700 dark:text-neutral-200"><span title=Categories class="text-2xl font-bold tracking-tight">Categories</span></a></div><div class=px-2><a href=https://github.com/pmnxis aria-label=GitHub target=_blank class="flex items-center gap-4 group bf-icon-color-hover text-neutral-700 dark:text-neutral-200"><span title class="text-2xl font-bold tracking-tight">GitHub</span></a></div><div class="flex flex-wrap items-center [&_span]:text-2xl [&_.translation_button_.icon]:text-4xl! [&_.translation_button_span]:text-base! [&_.translation_.menuhide_span]:text-sm! gap-x-6 ps-2 mt-8 pt-8 border-t bf-border-color"><div class="translation nested-menu"><button class="cursor-pointer flex items-center">
<span class=me-1><span class="relative block icon"><svg viewBox="0 0 640 512"><path fill="currentColor" d="M0 128C0 92.7 28.7 64 64 64H256h48 16H576c35.3.0 64 28.7 64 64V384c0 35.3-28.7 64-64 64H320 304 256 64c-35.3.0-64-28.7-64-64V128zm320 0V384H576V128H320zM178.3 175.9c-3.2-7.2-10.4-11.9-18.3-11.9s-15.1 4.7-18.3 11.9l-64 144c-4.5 10.1.1 21.9 10.2 26.4s21.9-.1 26.4-10.2l8.9-20.1h73.6l8.9 20.1c4.5 10.1 16.3 14.6 26.4 10.2s14.6-16.3 10.2-26.4l-64-144zM160 233.2 179 276H141l19-42.8zM448 164c11 0 20 9 20 20v4h44 16c11 0 20 9 20 20s-9 20-20 20h-2l-1.6 4.5c-8.9 24.4-22.4 46.6-39.6 65.4.9.6 1.8 1.1 2.7 1.6l18.9 11.3c9.5 5.7 12.5 18 6.9 27.4s-18 12.5-27.4 6.9L467 333.8c-4.5-2.7-8.8-5.5-13.1-8.5-10.6 7.5-21.9 14-34 19.4l-3.6 1.6c-10.1 4.5-21.9-.1-26.4-10.2s.1-21.9 10.2-26.4l3.6-1.6c6.4-2.9 12.6-6.1 18.5-9.8L410 286.1c-7.8-7.8-7.8-20.5.0-28.3s20.5-7.8 28.3.0l14.6 14.6.5.5c12.4-13.1 22.5-28.3 29.8-45H448 376c-11 0-20-9-20-20s9-20 20-20h52v-4c0-11 9-20 20-20z"/></svg></span>
</span><span class="text-sm font-medium bf-icon-color-hover" title="Chama Optics 개발기">KO</span></button><ul class=menuhide><li class="rounded-xl backdrop-blur shadow-2xl p-2 flex flex-col gap-1"><a href=/ko/posts/chama-optics-dev-story/ class="flex items-center bf-icon-color-hover px-3 py-1"><span class="text-sm font-sm" title="Chama Optics 개발기">KO
</span></a><a href=/ja/posts/chama-optics-dev-story/ class="flex items-center bf-icon-color-hover px-3 py-1"><span class="text-sm font-sm" title="Chama Optics 開発記">JA
</span></a><a href=/en/posts/chama-optics-dev-story/ class="flex items-center bf-icon-color-hover px-3 py-1"><span class="text-sm font-sm" title="Chama Optics Development Story">EN</span></a></li></ul></div></div></nav></div></div></div></div></div><div class="relative flex flex-col grow"><main id=main-content class=grow><article><header id=single_header class="mt-5 max-w-prose"><h1 class="mt-0 text-4xl font-extrabold text-neutral-900 dark:text-neutral">Chama Optics 개발기</h1><div class="mt-1 mb-6 text-base text-neutral-500 dark:text-neutral-400 print:hidden"><div class="flex flex-row flex-wrap items-center"><time datetime=2026-02-14T00:00:00+09:00>2026년 2월 14일</time><span class="px-2 text-primary-500">&#183;</span><span title="읽는 시간">38 분</span></div><div class="flex flex-row flex-wrap items-center"><a class="relative mt-[0.5rem] me-2" href=/ko/categories/chama-optics/><span class="flex cursor-pointer"><span class="rounded-md border border-primary-400 px-1 py-[1px] text-xs font-normal text-primary-700 dark:border-primary-600 dark:text-primary-400">Chama Optics
</span></span></a><a class="relative mt-[0.5rem] me-2" href=/ko/tags/rust/><span class="flex cursor-pointer"><span class="rounded-md border border-primary-400 px-1 py-[1px] text-xs font-normal text-primary-700 dark:border-primary-600 dark:text-primary-400">Rust
</span></span></a><a class="relative mt-[0.5rem] me-2" href=/ko/tags/ios/><span class="flex cursor-pointer"><span class="rounded-md border border-primary-400 px-1 py-[1px] text-xs font-normal text-primary-700 dark:border-primary-600 dark:text-primary-400">IOS
</span></span></a><a class="relative mt-[0.5rem] me-2" href=/ko/tags/cross-platform/><span class="flex cursor-pointer"><span class="rounded-md border border-primary-400 px-1 py-[1px] text-xs font-normal text-primary-700 dark:border-primary-600 dark:text-primary-400">Cross-Platform
</span></span></a><a class="relative mt-[0.5rem] me-2" href=/ko/tags/exif/><span class="flex cursor-pointer"><span class="rounded-md border border-primary-400 px-1 py-[1px] text-xs font-normal text-primary-700 dark:border-primary-600 dark:text-primary-400">EXIF</span></span></a></div></div><div class="flex author"><div class=place-self-center><div class="text-2xl sm:text-lg"></div></div></div><div class=mb-5></div></header><section class="flex flex-col max-w-full mt-0 prose dark:prose-invert lg:flex-row"><div class="order-first lg:ms-auto px-0 lg:order-last lg:ps-8 lg:max-w-2xs"><div class="toc ps-5 print:hidden lg:sticky lg:top-10"><details open id=TOCView class="toc-right mt-0 overflow-y-auto overscroll-contain bf-scrollbar rounded-lg -ms-5 ps-5 pe-2 hidden lg:block"><summary class="block py-1 text-lg font-semibold cursor-pointer bg-neutral-100 text-neutral-800 -ms-5 ps-5 dark:bg-neutral-700 dark:text-neutral-100 lg:hidden">목차</summary><div class="min-w-[220px] py-2 border-dotted border-s-1 -ms-5 ps-5 dark:border-neutral-600"><nav id=TableOfContents><ul><li><a href=#프로젝트-소개>프로젝트 소개</a></li><li><a href=#시작-exif-프레임을-좀-더-편하게>시작: EXIF 프레임을 좀 더 편하게</a></li><li><a href=#방향-전환-행사장에서-맥북을-꺼낼-순-없잖아>방향 전환: &ldquo;행사장에서 맥북을 꺼낼 순 없잖아&rdquo;</a><ul><li><a href=#행사-문화의-차이--animenyc에서-느낀-것>행사 문화의 차이 — AnimeNYC에서 느낀 것</a></li><li><a href=#곧-다가올-홀로라이브-엑스포>곧 다가올 홀로라이브 엑스포</a></li><li><a href=#주변의-요청>주변의 요청</a></li></ul></li><li><a href=#아키텍처-데스크탑에서-시작해-모바일까지>아키텍처: 데스크탑에서 시작해 모바일까지</a></li><li><a href=#web-버전을-포기하게-된-이유>Web 버전을 포기하게 된 이유</a><ul><li><a href=#heif-wasm-위에-wasm-그-사이에-js>HEIF: WASM 위에 WASM, 그 사이에 JS</a></li><li><a href=#drag--drop-데스크탑-개발자의-기대와-현실>Drag & Drop: 데스크탑 개발자의 기대와 현실</a></li><li><a href=#솔직히-c와-rust밖에-쓸-줄-모른다>솔직히 C와 Rust밖에 쓸 줄 모른다</a></li></ul></li><li><a href=#타임라인으로-보는-개발-여정>타임라인으로 보는 개발 여정</a><ul><li><a href=#v010v011-2025-10-1921--첫-프리릴리즈>v0.1.0~v0.1.1 (2025-10-19~21) — 첫 프리릴리즈</a></li><li><a href=#v012v016-2025-10-2711-24--테마-확장과-워터마크>v0.1.2~v0.1.6 (2025-10-27~11-24) — 테마 확장과 워터마크</a></li><li><a href=#v017-2025-11-2612-19--cjk-렌더링-개선과-오픈소스-기여>v0.1.7 (2025-11-26~12-19) — CJK 렌더링 개선과 오픈소스 기여</a></li><li><a href=#v018-2025-12-2527--ui-리뉴얼과-성능-개선>v0.1.8 (2025-12-25~27) — UI 리뉴얼과 성능 개선</a></li><li><a href=#v019-2026-01-1802-04--얼굴-인식-lut-ios-첫-배포>v0.1.9 (2026-01-18~02-04) — 얼굴 인식, LUT, iOS 첫 배포</a></li></ul></li><li><a href=#기술적-도전과-해결>기술적 도전과 해결</a><ul><li><a href=#1-크로스플랫폼-ffi의-복잡성>1. 크로스플랫폼 FFI의 복잡성</a></li><li><a href=#2-exif-파싱의-끝없는-변수>2. EXIF 파싱의 끝없는 변수</a></li><li><a href=#3-makernote-파싱-제조사별-촬영-설정-추출>3. MakerNote 파싱: 제조사별 촬영 설정 추출</a><ul><li><a href=#exif-ifd-엔트리-구조와-makernote의-offset-문제>EXIF IFD 엔트리 구조와 MakerNote의 offset 문제</a></li></ul></li><li><a href=#4-카메라-제조사-로고-시스템-csv--buildrs--바이너리-임베딩>4. 카메라 제조사 로고 시스템: CSV → build.rs → 바이너리 임베딩</a><ul><li><a href=#컴파일-타임-csv에서-svg-다운로드--임베딩>컴파일 타임: CSV에서 SVG 다운로드 & 임베딩</a></li><li><a href=#런타임-exif--로고-매칭--svg-래스터라이즈>런타임: EXIF → 로고 매칭 → SVG 래스터라이즈</a></li></ul></li><li><a href=#5-cjk-폰트-렌더링과-가변-폰트variable-font-최적화>5. CJK 폰트 렌더링과 가변 폰트(Variable Font) 최적화</a><ul><li><a href=#가변-폰트-weight-재매핑>가변 폰트 weight 재매핑</a></li><li><a href=#여러-폰트-파일을-하나로-합치기--절대적인-파일-사이즈-축소>여러 폰트 파일을 하나로 합치기 — 절대적인 파일 사이즈 축소</a></li><li><a href=#egui에서-가변-폰트-weight-선택-로딩>egui에서 가변 폰트 weight 선택 로딩</a></li><li><a href=#빌트인-폰트와-시스템-폰트>빌트인 폰트와 시스템 폰트</a></li><li><a href=#font-kit-macos-메모리-폭주-디버깅>font-kit macOS 메모리 폭주 디버깅</a></li></ul></li><li><a href=#6-lut-컬러-그레이딩-wagahai-lut의-최적화-철학>6. LUT 컬러 그레이딩: wagahai-lut의 최적화 철학</a><ul><li><a href=#cube-lut이란>CUBE LUT이란?</a></li><li><a href=#wagahai-lut의-최적화-전략>wagahai-lut의 최적화 전략</a></li><li><a href=#벤치마크-결과>벤치마크 결과</a></li></ul></li><li><a href=#7-데스크탑-얼굴-인식-speed-mode와-슬라이딩-윈도우-알고리즘>7. 데스크탑 얼굴 인식: Speed Mode와 슬라이딩 윈도우 알고리즘</a><ul><li><a href=#fastest>Fastest</a></li><li><a href=#fast>Fast</a></li><li><a href=#normal>Normal</a></li><li><a href=#slow>Slow</a></li><li><a href=#slowest>Slowest</a></li></ul></li><li><a href=#8-ios-네이티브-통합>8. iOS 네이티브 통합</a></li><li><a href=#9-mpf-및-내장-프리뷰-이미지-추출>9. MPF 및 내장 프리뷰 이미지 추출</a><ul><li><a href=#jpeg-안에-숨어-있는-이미지들>JPEG 안에 숨어 있는 이미지들</a></li><li><a href=#왜-mpf-프리뷰가-중요한가-메모리와-성능>왜 MPF 프리뷰가 중요한가: 메모리와 성능</a></li></ul></li><li><a href=#10-heifheic-디코더-플랫폼별-전략>10. HEIF/HEIC 디코더: 플랫폼별 전략</a></li><li><a href=#11-테마-파라미터-시스템-rust--json--플랫폼별-ui>11. 테마 파라미터 시스템: Rust → JSON → 플랫폼별 UI</a></li><li><a href=#12-다국어-번역-시스템-yaml-하나로-3개-플랫폼-번역-자동-생성>12. 다국어 번역 시스템: YAML 하나로 3개 플랫폼 번역 자동 생성</a><ul><li><a href=#yaml-번역의-원본>YAML: 번역의 원본</a></li><li><a href=#ios-generate_ios_stringssh>iOS: generate_ios_strings.sh</a></li><li><a href=#android-generate_android_stringssh>Android: generate_android_strings.sh</a></li><li><a href=#세-플랫폼의-키-변환-비교>세 플랫폼의 키 변환 비교</a></li></ul></li></ul></li><li><a href=#오픈소스-기여-활동>오픈소스 기여 활동</a></li><li><a href=#릴리즈-요약>릴리즈 요약</a></li><li><a href=#ai와-함께하는-프로그래밍-바이브-코딩>AI와 함께하는 프로그래밍 (바이브 코딩?)</a></li><li><a href=#앞으로의-계획>앞으로의 계획</a></li><li><a href=#참고-문헌-및-인용>참고 문헌 및 인용</a><ul><li><ul><li><a href=#표준-문서>표준 문서</a></li><li><a href=#라이브러리-및-프레임워크>라이브러리 및 프레임워크</a></li><li><a href=#참고-자료>참고 자료</a></li></ul></li></ul></li><li><a href=#special-thanks>Special Thanks</a></li></ul></nav></div></details><details class="toc-inside mt-0 overflow-hidden rounded-lg -ms-5 ps-5 lg:hidden"><summary class="py-1 text-lg font-semibold cursor-pointer bg-neutral-100 text-neutral-800 -ms-5 ps-5 dark:bg-neutral-700 dark:text-neutral-100 lg:hidden">목차</summary><div class="py-2 border-dotted border-neutral-300 border-s-1 -ms-5 ps-5 dark:border-neutral-600"><nav id=TableOfContents><ul><li><a href=#프로젝트-소개>프로젝트 소개</a></li><li><a href=#시작-exif-프레임을-좀-더-편하게>시작: EXIF 프레임을 좀 더 편하게</a></li><li><a href=#방향-전환-행사장에서-맥북을-꺼낼-순-없잖아>방향 전환: &ldquo;행사장에서 맥북을 꺼낼 순 없잖아&rdquo;</a><ul><li><a href=#행사-문화의-차이--animenyc에서-느낀-것>행사 문화의 차이 — AnimeNYC에서 느낀 것</a></li><li><a href=#곧-다가올-홀로라이브-엑스포>곧 다가올 홀로라이브 엑스포</a></li><li><a href=#주변의-요청>주변의 요청</a></li></ul></li><li><a href=#아키텍처-데스크탑에서-시작해-모바일까지>아키텍처: 데스크탑에서 시작해 모바일까지</a></li><li><a href=#web-버전을-포기하게-된-이유>Web 버전을 포기하게 된 이유</a><ul><li><a href=#heif-wasm-위에-wasm-그-사이에-js>HEIF: WASM 위에 WASM, 그 사이에 JS</a></li><li><a href=#drag--drop-데스크탑-개발자의-기대와-현실>Drag & Drop: 데스크탑 개발자의 기대와 현실</a></li><li><a href=#솔직히-c와-rust밖에-쓸-줄-모른다>솔직히 C와 Rust밖에 쓸 줄 모른다</a></li></ul></li><li><a href=#타임라인으로-보는-개발-여정>타임라인으로 보는 개발 여정</a><ul><li><a href=#v010v011-2025-10-1921--첫-프리릴리즈>v0.1.0~v0.1.1 (2025-10-19~21) — 첫 프리릴리즈</a></li><li><a href=#v012v016-2025-10-2711-24--테마-확장과-워터마크>v0.1.2~v0.1.6 (2025-10-27~11-24) — 테마 확장과 워터마크</a></li><li><a href=#v017-2025-11-2612-19--cjk-렌더링-개선과-오픈소스-기여>v0.1.7 (2025-11-26~12-19) — CJK 렌더링 개선과 오픈소스 기여</a></li><li><a href=#v018-2025-12-2527--ui-리뉴얼과-성능-개선>v0.1.8 (2025-12-25~27) — UI 리뉴얼과 성능 개선</a></li><li><a href=#v019-2026-01-1802-04--얼굴-인식-lut-ios-첫-배포>v0.1.9 (2026-01-18~02-04) — 얼굴 인식, LUT, iOS 첫 배포</a></li></ul></li><li><a href=#기술적-도전과-해결>기술적 도전과 해결</a><ul><li><a href=#1-크로스플랫폼-ffi의-복잡성>1. 크로스플랫폼 FFI의 복잡성</a></li><li><a href=#2-exif-파싱의-끝없는-변수>2. EXIF 파싱의 끝없는 변수</a></li><li><a href=#3-makernote-파싱-제조사별-촬영-설정-추출>3. MakerNote 파싱: 제조사별 촬영 설정 추출</a><ul><li><a href=#exif-ifd-엔트리-구조와-makernote의-offset-문제>EXIF IFD 엔트리 구조와 MakerNote의 offset 문제</a></li></ul></li><li><a href=#4-카메라-제조사-로고-시스템-csv--buildrs--바이너리-임베딩>4. 카메라 제조사 로고 시스템: CSV → build.rs → 바이너리 임베딩</a><ul><li><a href=#컴파일-타임-csv에서-svg-다운로드--임베딩>컴파일 타임: CSV에서 SVG 다운로드 & 임베딩</a></li><li><a href=#런타임-exif--로고-매칭--svg-래스터라이즈>런타임: EXIF → 로고 매칭 → SVG 래스터라이즈</a></li></ul></li><li><a href=#5-cjk-폰트-렌더링과-가변-폰트variable-font-최적화>5. CJK 폰트 렌더링과 가변 폰트(Variable Font) 최적화</a><ul><li><a href=#가변-폰트-weight-재매핑>가변 폰트 weight 재매핑</a></li><li><a href=#여러-폰트-파일을-하나로-합치기--절대적인-파일-사이즈-축소>여러 폰트 파일을 하나로 합치기 — 절대적인 파일 사이즈 축소</a></li><li><a href=#egui에서-가변-폰트-weight-선택-로딩>egui에서 가변 폰트 weight 선택 로딩</a></li><li><a href=#빌트인-폰트와-시스템-폰트>빌트인 폰트와 시스템 폰트</a></li><li><a href=#font-kit-macos-메모리-폭주-디버깅>font-kit macOS 메모리 폭주 디버깅</a></li></ul></li><li><a href=#6-lut-컬러-그레이딩-wagahai-lut의-최적화-철학>6. LUT 컬러 그레이딩: wagahai-lut의 최적화 철학</a><ul><li><a href=#cube-lut이란>CUBE LUT이란?</a></li><li><a href=#wagahai-lut의-최적화-전략>wagahai-lut의 최적화 전략</a></li><li><a href=#벤치마크-결과>벤치마크 결과</a></li></ul></li><li><a href=#7-데스크탑-얼굴-인식-speed-mode와-슬라이딩-윈도우-알고리즘>7. 데스크탑 얼굴 인식: Speed Mode와 슬라이딩 윈도우 알고리즘</a><ul><li><a href=#fastest>Fastest</a></li><li><a href=#fast>Fast</a></li><li><a href=#normal>Normal</a></li><li><a href=#slow>Slow</a></li><li><a href=#slowest>Slowest</a></li></ul></li><li><a href=#8-ios-네이티브-통합>8. iOS 네이티브 통합</a></li><li><a href=#9-mpf-및-내장-프리뷰-이미지-추출>9. MPF 및 내장 프리뷰 이미지 추출</a><ul><li><a href=#jpeg-안에-숨어-있는-이미지들>JPEG 안에 숨어 있는 이미지들</a></li><li><a href=#왜-mpf-프리뷰가-중요한가-메모리와-성능>왜 MPF 프리뷰가 중요한가: 메모리와 성능</a></li></ul></li><li><a href=#10-heifheic-디코더-플랫폼별-전략>10. HEIF/HEIC 디코더: 플랫폼별 전략</a></li><li><a href=#11-테마-파라미터-시스템-rust--json--플랫폼별-ui>11. 테마 파라미터 시스템: Rust → JSON → 플랫폼별 UI</a></li><li><a href=#12-다국어-번역-시스템-yaml-하나로-3개-플랫폼-번역-자동-생성>12. 다국어 번역 시스템: YAML 하나로 3개 플랫폼 번역 자동 생성</a><ul><li><a href=#yaml-번역의-원본>YAML: 번역의 원본</a></li><li><a href=#ios-generate_ios_stringssh>iOS: generate_ios_strings.sh</a></li><li><a href=#android-generate_android_stringssh>Android: generate_android_strings.sh</a></li><li><a href=#세-플랫폼의-키-변환-비교>세 플랫폼의 키 변환 비교</a></li></ul></li></ul></li><li><a href=#오픈소스-기여-활동>오픈소스 기여 활동</a></li><li><a href=#릴리즈-요약>릴리즈 요약</a></li><li><a href=#ai와-함께하는-프로그래밍-바이브-코딩>AI와 함께하는 프로그래밍 (바이브 코딩?)</a></li><li><a href=#앞으로의-계획>앞으로의 계획</a></li><li><a href=#참고-문헌-및-인용>참고 문헌 및 인용</a><ul><li><ul><li><a href=#표준-문서>표준 문서</a></li><li><a href=#라이브러리-및-프레임워크>라이브러리 및 프레임워크</a></li><li><a href=#참고-자료>참고 자료</a></li></ul></li></ul></li><li><a href=#special-thanks>Special Thanks</a></li></ul></nav></div></details></div></div><div class="min-w-0 min-h-0 max-w-fit"><div class="article-content max-w-prose mb-20"><blockquote><p>EXIF 기반 사진 프레임 + 얼굴 자동인식 프로그램, Rust 코어로 데스크탑부터 모바일까지</p></blockquote><p>이 블로그에 오타쿠스러운 글을 대놓고 쓰는 건 이번이 아마 처음일 것이다.
솔직히 이 글을 쓰기 시작한 지는 꽤 되었는데, 청자를 개발자에게 맞춰야 할지 VTuber 오타쿠에게 맞춰야 할지 감이 잡히지 않았다.
결국 그냥 의식의 흐름대로 개발하고 기여한 것들을 나열하기로 했다.</p><p>이 블로그에서는 주로 Rust Embedded를 다루고 있었고, 이전에 <a href=https://github.com/pmnxis/billmock-app-rs target=_blank rel=noreferrer>billmock-app-rs</a>라는 Rust Embedded 양산 프로젝트를 진행한 바 있다.</p><p>이 글에서는 <a href=https://github.com/pmnxis/chama-optics target=_blank rel=noreferrer>Chama Optics</a>의 개발 과정을 소개한다.</p><p>2026년 2월 마지막 주에 <strong>0.2.0</strong>에 iOS / Android / macOS / Linux / Windows 의 정식 배포를 할 예정이며 App Store, Google Play 승인 전 개발 과정을 서술하고 있습니다.</p><blockquote><p>🌐 <a href=/en/posts/chama-optics-dev-story/>English Article</a> | <a href=/ja/posts/chama-optics-dev-story/>日本語アーティクル</a></p></blockquote><hr><h2 class="relative group">프로젝트 소개<div id=프로젝트-소개 class=anchor></div><span class="absolute top-0 w-6 transition-opacity opacity-0 -start-6 not-prose group-hover:opacity-100 select-none"><a class="text-primary-300 dark:text-neutral-700 !no-underline" href=#%ed%94%84%eb%a1%9c%ec%a0%9d%ed%8a%b8-%ec%86%8c%ea%b0%9c aria-label=앵커>#</a></span></h2><p><figure><img class="my-0 rounded-md" loading=lazy decoding=async fetchpriority=auto alt="Chama Optics" width=1280 height=720 src=/en/posts/chama-optics-dev-story/haachama-optics_hu_c9db7982d9164695.webp srcset="/en/posts/chama-optics-dev-story/haachama-optics_hu_c9db7982d9164695.webp 800w, /en/posts/chama-optics-dev-story/haachama-optics.webp 1280w" sizes="(min-width: 768px) 50vw, 65vw" data-zoom-src=/en/posts/chama-optics-dev-story/haachama-optics.webp></figure></p><p><strong>Chama Optics</strong>는 DSLR/미러리스 카메라로 촬영한 사진의 EXIF 데이터를 분석하여 다양한 테마 프레임을 적용하고, 워터마크·모자이크·스티커 등의 효과를 추가할 수 있는 사진 후처리 프로그램이다. &ldquo;Chama"라는 이름은 여행 VTuber Akai Haato(赤井はあと)의 별칭에서 유래했다.</p><p>수많은 모바일 기기를 거쳤지만 내 관심은 항상 전자기기를 <strong>만드는</strong> 쪽이었고, 스마트폰 앱 개발과는 거리가 멀었다. 그런 내가 Hololive JP 1기생 아카이 하아토(HAACHAMA)의 팬으로서 오타쿠 생활을 하면서, 임베디드가 아닌 소프트웨어 개발 영역에서 첫 프로젝트를 시작하게 되었다.</p><p>이 프로그램을 처음 구상한 것은 2025년 3월부터이다.
당시에는 웹앱으로 동작하길 원했으며, 라이브러리 테스트, WASM 환경 테스트, libheif 포팅 등을 진행하고 있었다.
2025년 8월, 일본 도쿄에서의 아마네 카나타 솔로라이브 LOCK-ON과 미국 뉴욕에서의 AnimeNYC World Tour + EN Concert(All for one)를 다녀온 뒤, 사진을 빠르게 정리하고 WEBP로 압축해서 게시할 필요성을 절감했다.
동시에 아카이 하아토도 최근 사진 찍는 것을 좋아하여, 멤버십 한정 글로 자기가 쓰는 카메라를 보여주거나 오시카츠하아톤일기(<a href=https://x.com/hashtag/%E6%8E%A8%E3%81%97%E6%B4%BB%E3%81%AF%E3%81%82%E3%81%A8%E3%82%93%E6%97%A5%E8%A8%98 target=_blank rel=noreferrer>#推し活はあとん日記</a>)에서 사진 게시를 유도하고 있었기에, 하아토(HAACHAMA) 이름으로 앱을 하나 개발해주고 싶었다.</p><table><thead><tr><th>최근 3D Live</th><th>Akai Haato X(twitter)</th></tr></thead><tbody><tr><td><blockquote class=twitter-tweet><p lang=ja dir=ltr>/／<br>📢 本日２１：００から‼️<br>\＼<br><br>赤井はあと生誕3D LIVE開催!!🎊<br><br>🎁テーマはホラー⁉️<br>🎁ゲスト多数&告知あり◎<br>🎁演出はこだわり満天🥳<br><br>ダンスや歌も精一杯がんばったので<br>みんな是非！見に来てねっ❕👀✨<a href="https://twitter.com/hashtag/%E8%B5%A4%E4%BA%95%E3%81%AF%E3%81%82%E3%81%A8%E7%88%86%E8%AA%95%E7%A5%AD2025?src=hash&amp;ref_src=twsrc%5Etfw">#赤井はあと爆誕祭2025</a><br><br>【開催場所】<a href=https://t.co/3IUA2stYWi>https://t.co/3IUA2stYWi</a>… <a href=https://t.co/A1OqUBCbsM>pic.twitter.com/A1OqUBCbsM</a></p>&mdash; 赤井はあと❤️‍🔥旅するアイドル (@akaihaato) <a href="https://twitter.com/akaihaato/status/1954294114519851374?ref_src=twsrc%5Etfw">August 9, 2025</a></blockquote><script async src=https://platform.twitter.com/widgets.js></script></td><td><blockquote class=twitter-tweet><p lang=ja dir=ltr>四万温泉ステキな場所でした。<br>ぐんまー帝国、ありがとん❤️‍🔥 <a href=https://t.co/Ov0CwFRF7V>pic.twitter.com/Ov0CwFRF7V</a></p>&mdash; 赤井はあと❤️‍🔥旅するアイドル (@akaihaato) <a href="https://twitter.com/akaihaato/status/1916078150804799563?ref_src=twsrc%5Etfw">April 26, 2025</a></blockquote><script async src=https://platform.twitter.com/widgets.js></script></td></tr></tbody></table><p>프로그램을 개발할 때에는 아래의 철칙을 따랐다.</p><ul><li>데스크탑상에서 어떠한 아키텍처 차별이 있어서는 안 된다.</li><li>MS나 Apple의 개발 생태계에 최소한으로 얽매여야 한다.</li><li>리소스를 많이 사용하면 안 되며 빨라야 한다.</li></ul><p>목표는 무슨 거창한 것처럼 보이지만 내가 그냥 Rust 매니아라서 저게 목표다.</p><hr><h2 class="relative group">시작: EXIF 프레임을 좀 더 편하게<div id=시작-exif-프레임을-좀-더-편하게 class=anchor></div><span class="absolute top-0 w-6 transition-opacity opacity-0 -start-6 not-prose group-hover:opacity-100 select-none"><a class="text-primary-300 dark:text-neutral-700 !no-underline" href=#%ec%8b%9c%ec%9e%91-exif-%ed%94%84%eb%a0%88%ec%9e%84%ec%9d%84-%ec%a2%80-%eb%8d%94-%ed%8e%b8%ed%95%98%ea%b2%8c aria-label=앵커>#</a></span></h2><p>처음부터 거창한 크로스플랫폼 앱을 계획했던 건 아니었다.</p><p>사진기 매니아들 사이에서는 사진을 올릴 때 EXIF 정보를 바탕으로 카메라 모델명, 렌즈, 셔터스피드 등을 프레임에 넣어 공유하는 문화가 있다. 나도 이 방식을 즐겨 사용하고 있었고, 기존에는 <a href=https://github.com/jeonghyeon-net/exif-frame target=_blank rel=noreferrer>exif-frame</a>이라는 웹 기반 도구를 참고하여 사용하고 있었다. 하지만 HEIF 포맷을 지원하지 않는 점과 고해상도 이미지 출력에 제한이 있는 점이 아쉬워서, 직접 만들자는 생각에서 Chama Optics가 시작되었다.</p><p>처음에는 <strong>데스크탑만을 고려</strong>했다. 모바일에 대한 막연한 상상은 있었지만, 여행지에서도 어차피 언제나 맥북을 들고 다녔기에 모바일은 전혀 염두에 두지 않았다. 카메라에서 SD 카드를 빼고, 맥북에서 사진을 정리하고, 프레임을 입혀서 올리는 — 그 워크플로우가 당연했으니까.</p><hr><h2 class="relative group">방향 전환: &ldquo;행사장에서 맥북을 꺼낼 순 없잖아&rdquo;<div id=방향-전환-행사장에서-맥북을-꺼낼-순-없잖아 class=anchor></div><span class="absolute top-0 w-6 transition-opacity opacity-0 -start-6 not-prose group-hover:opacity-100 select-none"><a class="text-primary-300 dark:text-neutral-700 !no-underline" href=#%eb%b0%a9%ed%96%a5-%ec%a0%84%ed%99%98-%ed%96%89%ec%82%ac%ec%9e%a5%ec%97%90%ec%84%9c-%eb%a7%a5%eb%b6%81%ec%9d%84-%ea%ba%bc%eb%82%bc-%ec%88%9c-%ec%97%86%ec%9e%96%ec%95%84 aria-label=앵커>#</a></span></h2><p>방향이 바뀐 건 두 가지 계기가 있었다.</p><h3 class="relative group">행사 문화의 차이 — AnimeNYC에서 느낀 것<div id=행사-문화의-차이--animenyc에서-느낀-것 class=anchor></div><span class="absolute top-0 w-6 transition-opacity opacity-0 -start-6 not-prose group-hover:opacity-100 select-none"><a class="text-primary-300 dark:text-neutral-700 !no-underline" href=#%ed%96%89%ec%82%ac-%eb%ac%b8%ed%99%94%ec%9d%98-%ec%b0%a8%ec%9d%b4--animenyc%ec%97%90%ec%84%9c-%eb%8a%90%eb%82%80-%ea%b2%83 aria-label=앵커>#</a></span></h3><p>2025년 8월, <strong>AnimeNYC</strong>와 <strong>Hololive World Tour / EN Concert</strong>를 위해 미국을 방문했다. 그때 재밌는 차이를 느꼈다. 미국에서는 행사장에서 찍은 사진을 올릴 때 <strong>사람들의 얼굴을 모자이크하지 않는 경향</strong>이 강했다. 하지만 한국과 일본의 행사에서는 <strong>다른 사람의 얼굴을 반드시 모자이크 처리</strong>하는 것이 예의이자 암묵적인 규칙이었다.</p><p><figure><img class="my-0 rounded-md" loading=lazy decoding=async fetchpriority=auto alt="AnimeNYC 행사 사진 예시" width=4072 height=2852 src=/en/posts/chama-optics-dev-story/P1090028-OPTICS_hu_8d712446ebc299fb.webp srcset="/en/posts/chama-optics-dev-story/P1090028-OPTICS_hu_8d712446ebc299fb.webp 800w, /en/posts/chama-optics-dev-story/P1090028-OPTICS_hu_b596c2480f9c7781.webp 1280w" sizes="(min-width: 768px) 50vw, 65vw" data-zoom-src=/en/posts/chama-optics-dev-story/P1090028-OPTICS.webp></figure></p><p>&ldquo;다른 사람 얼굴 모자이크"는 매번 수작업으로 하기엔 너무 번거로운 작업이다. 특히 사진이 수십, 수백 장이 되면 더욱. <strong>자동 얼굴 인식 + 모자이크/스티커 기능</strong>이 필요하다는 생각이 이때부터 강하게 들었다.</p><h3 class="relative group">곧 다가올 홀로라이브 엑스포<div id=곧-다가올-홀로라이브-엑스포 class=anchor></div><span class="absolute top-0 w-6 transition-opacity opacity-0 -start-6 not-prose group-hover:opacity-100 select-none"><a class="text-primary-300 dark:text-neutral-700 !no-underline" href=#%ea%b3%a7-%eb%8b%a4%ea%b0%80%ec%98%ac-%ed%99%80%eb%a1%9c%eb%9d%bc%ec%9d%b4%eb%b8%8c-%ec%97%91%ec%8a%a4%ed%8f%ac aria-label=앵커>#</a></span></h3><p>또 하나의 동기는 <strong>2026년 3월의 홀로라이브 엑스포/페스티벌</strong>이었다. 행사장에서 바로 사진을 찍고, 그 자리에서 프레임을 입히고, 모자이크까지 처리해서 SNS에 올릴 수 있다면? 그런데 행사장에서 맥북을 열 순 없다. <strong>스마트폰에서 바로 처리할 수 있어야 했다.</strong></p><h3 class="relative group">주변의 요청<div id=주변의-요청 class=anchor></div><span class="absolute top-0 w-6 transition-opacity opacity-0 -start-6 not-prose group-hover:opacity-100 select-none"><a class="text-primary-300 dark:text-neutral-700 !no-underline" href=#%ec%a3%bc%eb%b3%80%ec%9d%98-%ec%9a%94%ec%b2%ad aria-label=앵커>#</a></span></h3><p>여기에 주변에서 <strong>iOS 버전 개발에 대한 요청</strong>이 더해졌다. 그래서 iOS용을 개발하기 시작했더니, 이번에는 <strong>Android 버전에 대한 요청</strong>도 들어왔다.</p><p>이렇게 해서 데스크탑 전용이었던 프로그램이 iOS, 나아가 Android까지 지원하는 방향으로 확장되었다. 모바일에서는 미러리스 카메라 사용자보다는 <strong>일반 사용자의 경험</strong>을 더 고려하는 쪽으로 설계 방향을 잡았다. EXIF 프레임이라는 출발점은 그대로지만, &ldquo;행사 현장에서 빠르게 사진을 처리해서 공유한다"는 새로운 사용 시나리오가 추가된 셈이다.</p><hr><h2 class="relative group">아키텍처: 데스크탑에서 시작해 모바일까지<div id=아키텍처-데스크탑에서-시작해-모바일까지 class=anchor></div><span class="absolute top-0 w-6 transition-opacity opacity-0 -start-6 not-prose group-hover:opacity-100 select-none"><a class="text-primary-300 dark:text-neutral-700 !no-underline" href=#%ec%95%84%ed%82%a4%ed%85%8d%ec%b2%98-%eb%8d%b0%ec%8a%a4%ed%81%ac%ed%83%91%ec%97%90%ec%84%9c-%ec%8b%9c%ec%9e%91%ed%95%b4-%eb%aa%a8%eb%b0%94%ec%9d%bc%ea%b9%8c%ec%a7%80 aria-label=앵커>#</a></span></h2><p>처음에는 Rust + egui로 데스크탑 앱만 만들 생각이었다. 그래서 핵심 로직을 모두 Rust로 작성한 것이 결과적으로 좋은 선택이 되었다. iOS/Android로 확장할 때 <strong>이미지 처리, EXIF 파싱, 테마 렌더링, 인코딩/디코딩 같은 핵심 코드를 그대로 재사용</strong>할 수 있었기 때문이다.</p><p><figure><img class="my-0 rounded-md" loading=lazy decoding=async fetchpriority=low alt="ChamaOptics Architecture" src=/en/posts/chama-optics-dev-story/architecture_layers.svg></figure></p><p>데스크탑에서는 Rust 코어를 <strong>직접 링킹</strong>하여 사용하고, iOS에서는 <strong>C FFI를 통해 Swift에서 호출</strong>, Android에서는 <strong>JNA(Java Native Access)를 통해 Kotlin에서 호출</strong>하는 구조다. Rust 코어는 git submodule로 관리되며, EXIF 해석, 이미지 오버레이(텍스트, EXIF, 여백, 스케일링, 인코딩/디코딩) 같은 핵심 기능을 모든 플랫폼에서 공유한다.</p><p>단, 얼굴 인식만은 플랫폼마다 다른 전략을 사용한다.</p><ul><li><strong>데스크탑(macOS/Windows/Linux)</strong>: ONNX Runtime + InsightFace(SCRFD det_10g) 모델. Speed Mode에 따라 640×640 고정 입력 크기의 슬라이딩 윈도우를 다단계(2560/1280/640)로 적용하여 작은 얼굴까지 감지하고, NMS로 중복을 제거하는 파이프라인</li><li><strong>iOS</strong>: Apple Vision Framework를 네이티브로 사용. ONNX 모델 없이도 빠르고 정확하며, 프라이버시 면에서도 유리</li><li><strong>Android</strong>: Google ML Kit (<code>com.google.mlkit:face-detection</code>) 활용 — Google이 제공하는 온디바이스 얼굴 인식 라이브러리, Rust 코어의 speed_mode를 FAST/ACCURATE 퍼포먼스 모드로 매핑</li></ul><hr><h2 class="relative group">Web 버전을 포기하게 된 이유<div id=web-버전을-포기하게-된-이유 class=anchor></div><span class="absolute top-0 w-6 transition-opacity opacity-0 -start-6 not-prose group-hover:opacity-100 select-none"><a class="text-primary-300 dark:text-neutral-700 !no-underline" href=#web-%eb%b2%84%ec%a0%84%ec%9d%84-%ed%8f%ac%ea%b8%b0%ed%95%98%ea%b2%8c-%eb%90%9c-%ec%9d%b4%ec%9c%a0 aria-label=앵커>#</a></span></h2><p>나는 Web App이나 Web과 브라우저의 동작 방식에 대해서 해박하지 않다. 그럼에도 Chama Optics는 초기에 <strong>Web(WASM)에서의 구동을 염두에 두고 있었다.</strong> egui가 WASM을 지원하니까 &ldquo;데스크탑이랑 웹이랑 동시에 되겠지"라는 막연한 기대가 있었다. 하지만 다음 두 가지 기능을 구현하면서 포기하게 되었다.</p><ul><li><strong>HEIF 디코딩</strong></li><li><strong>egui Web에서의 Drag & Drop</strong></li></ul><h3 class="relative group">HEIF: WASM 위에 WASM, 그 사이에 JS<div id=heif-wasm-위에-wasm-그-사이에-js class=anchor></div><span class="absolute top-0 w-6 transition-opacity opacity-0 -start-6 not-prose group-hover:opacity-100 select-none"><a class="text-primary-300 dark:text-neutral-700 !no-underline" href=#heif-wasm-%ec%9c%84%ec%97%90-wasm-%ea%b7%b8-%ec%82%ac%ec%9d%b4%ec%97%90-js aria-label=앵커>#</a></span></h3><p>libheif를 브라우저에서 돌리기 어려운 것 이전에, 근본적인 구조가 납득이 되지 않았다. libheif는 이미 WASM으로 컴파일된 상태이고, egui 앱 또한 WASM이다. 이 둘 사이의 통신을 <strong>JavaScript를 통한 FFI로 몇 번이나 거쳐야 한다</strong>는 것이 이해가 되지 않았다. 대부분의 언어 간 FFI는 C 기반으로 하는 것에 반해, 왜 JS 생태계에서는 이렇게 해야 하는지 이해할 수 없었다.</p><h3 class="relative group">Drag & Drop: 데스크탑 개발자의 기대와 현실<div id=drag--drop-데스크탑-개발자의-기대와-현실 class=anchor></div><span class="absolute top-0 w-6 transition-opacity opacity-0 -start-6 not-prose group-hover:opacity-100 select-none"><a class="text-primary-300 dark:text-neutral-700 !no-underline" href=#drag--drop-%eb%8d%b0%ec%8a%a4%ed%81%ac%ed%83%91-%ea%b0%9c%eb%b0%9c%ec%9e%90%ec%9d%98-%ea%b8%b0%eb%8c%80%ec%99%80-%ed%98%84%ec%8b%a4 aria-label=앵커>#</a></span></h3><p>Drag & Drop 이외에도, WASM이 브라우저로부터 이벤트를 받을 때 JS가 아닌 DOM을 바이너리 형태로 받는다거나, 좀 더 기존 데스크탑/임베디드 개발에서 쓰일 법한 방법이 제공될 줄 알았으나 아니었다.</p><h3 class="relative group">솔직히 C와 Rust밖에 쓸 줄 모른다<div id=솔직히-c와-rust밖에-쓸-줄-모른다 class=anchor></div><span class="absolute top-0 w-6 transition-opacity opacity-0 -start-6 not-prose group-hover:opacity-100 select-none"><a class="text-primary-300 dark:text-neutral-700 !no-underline" href=#%ec%86%94%ec%a7%81%ed%9e%88-c%ec%99%80-rust%eb%b0%96%ec%97%90-%ec%93%b8-%ec%a4%84-%eb%aa%a8%eb%a5%b8%eb%8b%a4 aria-label=앵커>#</a></span></h3><p>나는 <strong>C와 Rust밖에 쓸 줄 모른다.</strong> 즉, Web 개발 자체에 대해서 매우 무지하거나, 과거에 하더라도 이상한 방식으로 개발했다.</p><p>예전에 수많은 데이터를 웹에 나열해야 할 일이 있었는데, 어떻게 할지 몰라서 넣을 데이터들을 CSV로 만들고 <code>,</code>와 <code>\n</code>을 <code>&lt;div></code> 등의 HTML 태그로 변경하는 것을 <strong>hex editor로 전체 치환</strong>해서 static web을 만들어 배포한 적이 있다. 21세기가 25%나 지나간 현대 프로그램 개발에 있어서 스스로도 &ldquo;이게 뭐요&rdquo; 싶었다.</p><p>물론 WASM은 웹이기에 웹 생태계와 개발자들의 방식을 따르는 것이 보편적일 것이다. 하지만 나는 웹 개발자가 아니기 때문에 이해가 되지 않았다. 나는 <strong>JS/Web 생태계와 매우 거리가 멀었고</strong>, 이런 개발 환경 자체의 방향성 차이를 극복하는 것보다 네이티브 모바일 앱을 만드는 게 훨씬 자연스러웠다. v0.1.9-beta에서 공식적으로 WASM 지원을 제거했고, 그 에너지를 iOS/Android 네이티브에 쏟기로 했다.</p><hr><h2 class="relative group">타임라인으로 보는 개발 여정<div id=타임라인으로-보는-개발-여정 class=anchor></div><span class="absolute top-0 w-6 transition-opacity opacity-0 -start-6 not-prose group-hover:opacity-100 select-none"><a class="text-primary-300 dark:text-neutral-700 !no-underline" href=#%ed%83%80%ec%9e%84%eb%9d%bc%ec%9d%b8%ec%9c%bc%eb%a1%9c-%eb%b3%b4%eb%8a%94-%ea%b0%9c%eb%b0%9c-%ec%97%ac%ec%a0%95 aria-label=앵커>#</a></span></h2><h3 class="relative group">v0.1.0~v0.1.1 (2025-10-19~21) — 첫 프리릴리즈<div id=v010v011-2025-10-1921--첫-프리릴리즈 class=anchor></div><span class="absolute top-0 w-6 transition-opacity opacity-0 -start-6 not-prose group-hover:opacity-100 select-none"><a class="text-primary-300 dark:text-neutral-700 !no-underline" href=#v010v011-2025-10-1921--%ec%b2%ab-%ed%94%84%eb%a6%ac%eb%a6%b4%eb%a6%ac%ec%a6%88 aria-label=앵커>#</a></span></h3><p><figure><img class="my-0 rounded-md" loading=lazy decoding=async fetchpriority=low alt="v0.1.0 스크린샷" src=https://github.com/user-attachments/assets/2471db65-8b0b-44e4-9d2b-31701184878e></figure></p><p>macOS/Windows 바이너리 첫 배포. Film 테마 프레임, 일본어 번역, 일괄 저장, 파일명 접두어/접미어 설정. macOS 코드 사이닝 DMG 배포 및 한/영/일 설치 가이드 위키 작성.</p><h3 class="relative group">v0.1.2~v0.1.6 (2025-10-27~11-24) — 테마 확장과 워터마크<div id=v012v016-2025-10-2711-24--테마-확장과-워터마크 class=anchor></div><span class="absolute top-0 w-6 transition-opacity opacity-0 -start-6 not-prose group-hover:opacity-100 select-none"><a class="text-primary-300 dark:text-neutral-700 !no-underline" href=#v012v016-2025-10-2711-24--%ed%85%8c%eb%a7%88-%ed%99%95%ec%9e%a5%ea%b3%bc-%ec%9b%8c%ed%84%b0%eb%a7%88%ed%81%ac aria-label=앵커>#</a></span></h3><table><thead><tr><th style=text-align:center>Film Date 테마</th><th style=text-align:center>Strap 테마</th><th style=text-align:center>Monitor 테마</th><th style=text-align:center>Lightroom 테마</th></tr></thead><tbody><tr><td style=text-align:center><figure><img class="my-0 rounded-md" loading=lazy decoding=async fetchpriority=low alt="Film Date" src=https://github.com/user-attachments/assets/a6bf0e51-d3b1-4779-9d65-080b225958f4></figure></td><td style=text-align:center><figure><img class="my-0 rounded-md" loading=lazy decoding=async fetchpriority=low alt=Strap src=https://github.com/user-attachments/assets/039ab49f-85b1-414b-95e3-2da166cea27f></figure></td><td style=text-align:center><figure><img class="my-0 rounded-md" loading=lazy decoding=async fetchpriority=low alt=Monitor src=https://github.com/user-attachments/assets/e92b81a0-4465-4dad-9097-7e8b4814fc15></figure></td><td style=text-align:center><figure><img class="my-0 rounded-md" loading=lazy decoding=async fetchpriority=low alt=Lightroom src=https://github.com/user-attachments/assets/ce1022cd-aea3-4260-9d5f-5e15997388de></figure></td></tr></tbody></table><p>Film Date/Film Glow/Just Frame/Strap/Monitor/Lightroom 테마 추가. 워터마크(위치 9곳, 투명도, 블렌드 모드), 폰트 선택(내장 + OS 폰트), 내장 카메라 제조사 로고 자동 적용, HEIF 방향 수정, 가변 폰트 초기 지원, Longside 스케일 옵션.</p><h3 class="relative group">v0.1.7 (2025-11-26~12-19) — CJK 렌더링 개선과 오픈소스 기여<div id=v017-2025-11-2612-19--cjk-렌더링-개선과-오픈소스-기여 class=anchor></div><span class="absolute top-0 w-6 transition-opacity opacity-0 -start-6 not-prose group-hover:opacity-100 select-none"><a class="text-primary-300 dark:text-neutral-700 !no-underline" href=#v017-2025-11-2612-19--cjk-%eb%a0%8c%eb%8d%94%eb%a7%81-%ea%b0%9c%ec%84%a0%ea%b3%bc-%ec%98%a4%ed%94%88%ec%86%8c%ec%8a%a4-%ea%b8%b0%ec%97%ac aria-label=앵커>#</a></span></h3><table><thead><tr><th style=text-align:center>One Line 테마</th><th style=text-align:center>Shot On Two Line 테마</th></tr></thead><tbody><tr><td style=text-align:center><figure><img class="my-0 rounded-md" loading=lazy decoding=async fetchpriority=low alt="One Line" src=https://github.com/user-attachments/assets/337337f3-7c17-467a-b965-06481cba98c8></figure></td><td style=text-align:center><figure><img class="my-0 rounded-md" loading=lazy decoding=async fetchpriority=low alt="Shot On 2" src=https://github.com/user-attachments/assets/a9ba4540-6540-418c-8e21-4f9961d7bff7></figure></td></tr></tbody></table><table><thead><tr><th style=text-align:center>Nikon PhotoStyle</th><th style=text-align:center>Lumix Photo Style + LUT</th></tr></thead><tbody><tr><td style=text-align:center><figure><img class="my-0 rounded-md" loading=lazy decoding=async fetchpriority=low alt=Nikon src=https://github.com/user-attachments/assets/28016fd2-2d4d-4043-88e1-c29f7577a32a></figure></td><td style=text-align:center><figure><img class="my-0 rounded-md" loading=lazy decoding=async fetchpriority=low alt=Lumix src=https://github.com/user-attachments/assets/62219e6a-c6cb-49ac-9803-cda29321b998></figure></td></tr></tbody></table><p>One Line/Two Line/Shot On 테마. CJK 글리프 렌더링 대폭 개선 및 SourceHanSans fallback 내장. Lumix LUT·Nikon PhotoStyle 이름을 EXIF에서 추출하기 위해 <a href=https://github.com/kamadak/exif-rs target=_blank rel=noreferrer>exif-rs</a>에 PR 제출 후 선반영.</p><h3 class="relative group">v0.1.8 (2025-12-25~27) — UI 리뉴얼과 성능 개선<div id=v018-2025-12-2527--ui-리뉴얼과-성능-개선 class=anchor></div><span class="absolute top-0 w-6 transition-opacity opacity-0 -start-6 not-prose group-hover:opacity-100 select-none"><a class="text-primary-300 dark:text-neutral-700 !no-underline" href=#v018-2025-12-2527--ui-%eb%a6%ac%eb%89%b4%ec%96%bc%ea%b3%bc-%ec%84%b1%eb%8a%a5-%ea%b0%9c%ec%84%a0 aria-label=앵커>#</a></span></h3><table><thead><tr><th style=text-align:center>이미지 리스트 탭</th><th style=text-align:center>테마 설정 탭</th></tr></thead><tbody><tr><td style=text-align:center><figure><img class="my-0 rounded-md" loading=lazy decoding=async fetchpriority=low alt=Tab1 src=https://github.com/user-attachments/assets/798d9c93-833a-4e9f-876d-ee3fe7182dab></figure></td><td style=text-align:center><figure><img class="my-0 rounded-md" loading=lazy decoding=async fetchpriority=low alt=Tab2 src=https://github.com/user-attachments/assets/4dd969fa-6f75-4f73-8c8a-f89ac66e1b1b></figure></td></tr></tbody></table><p>탭 기반 인터페이스 전환(4개 탭), EXIF 변수 자동완성, 이미지 자동 그룹화, 2MP MPF 프리뷰 기반 테마 미리보기, Rayon 멀티코어 병렬 처리, 시스템 폰트 로딩 메모리 이슈 수정. <a href=https://github.com/emilk/egui target=_blank rel=noreferrer>egui</a>에도 PR 제출.</p><h3 class="relative group">v0.1.9 (2026-01-18~02-04) — 얼굴 인식, LUT, iOS 첫 배포<div id=v019-2026-01-1802-04--얼굴-인식-lut-ios-첫-배포 class=anchor></div><span class="absolute top-0 w-6 transition-opacity opacity-0 -start-6 not-prose group-hover:opacity-100 select-none"><a class="text-primary-300 dark:text-neutral-700 !no-underline" href=#v019-2026-01-1802-04--%ec%96%bc%ea%b5%b4-%ec%9d%b8%ec%8b%9d-lut-ios-%ec%b2%ab-%eb%b0%b0%ed%8f%ac aria-label=앵커>#</a></span></h3><table><thead><tr><th style=text-align:center>얼굴 인식 (데스크탑)</th><th style=text-align:center>모자이크 적용</th></tr></thead><tbody><tr><td style=text-align:center><figure><img class="my-0 rounded-md" loading=lazy decoding=async fetchpriority=low alt="Face Detection" src=https://github.com/user-attachments/assets/a038cdaa-f755-4d8f-97c9-71f57004e739></figure></td><td style=text-align:center><figure><img class="my-0 rounded-md" loading=lazy decoding=async fetchpriority=low alt=Mosaic src=https://github.com/user-attachments/assets/6ed05280-1980-448a-9243-aff0836d2470></figure></td></tr></tbody></table><table><thead><tr><th style=text-align:center>컬러 그레이딩 UI</th><th style=text-align:center>LUT 적용 결과</th></tr></thead><tbody><tr><td style=text-align:center><figure><img class="my-0 rounded-md" loading=lazy decoding=async fetchpriority=low alt="LUT UI" src=https://github.com/user-attachments/assets/554f96b2-217a-4603-93f5-1df41309f77e></figure></td><td style=text-align:center><figure><img class="my-0 rounded-md" loading=lazy decoding=async fetchpriority=low alt="LUT Result" src=https://github.com/user-attachments/assets/4d49174c-2624-4b3c-a8a1-fc2b56d357c1></figure></td></tr></tbody></table><table><thead><tr><th style=text-align:center>iOS 갤러리</th><th style=text-align:center>iOS 편집</th></tr></thead><tbody><tr><td style=text-align:center><figure><img class="my-0 rounded-md" loading=lazy decoding=async fetchpriority=auto alt=Gallery width=2412 height=1311 src=/en/posts/chama-optics-dev-story/previews-d2OPTICS_hu_1ac30e400eb3a375.webp srcset="/en/posts/chama-optics-dev-story/previews-d2OPTICS_hu_1ac30e400eb3a375.webp 800w, /en/posts/chama-optics-dev-story/previews-d2OPTICS_hu_92f7456d73efcbec.webp 1280w" sizes="(min-width: 768px) 50vw, 65vw" data-zoom-src=/en/posts/chama-optics-dev-story/previews-d2OPTICS.webp></figure></td><td style=text-align:center><figure><img class="my-0 rounded-md" loading=lazy decoding=async fetchpriority=auto alt=Editor width=2412 height=1311 src=/en/posts/chama-optics-dev-story/color-themes-d2OPTICS_hu_d6a28de598a9adb.webp srcset="/en/posts/chama-optics-dev-story/color-themes-d2OPTICS_hu_d6a28de598a9adb.webp 800w, /en/posts/chama-optics-dev-story/color-themes-d2OPTICS_hu_e12507295bd67776.webp 1280w" sizes="(min-width: 768px) 50vw, 65vw" data-zoom-src=/en/posts/chama-optics-dev-story/color-themes-d2OPTICS.webp></figure></td></tr></tbody></table><p>데스크탑 단독 릴리즈 마지막이자 iOS 앱 첫 배포 버전. ONNX(InsightFace) 얼굴 감지 + 모자이크/스트로크/스티커 오버레이. 1D/3D LUT 컬러 그레이딩(<a href=https://github.com/pmnxis/wagahai-lut target=_blank rel=noreferrer>wagahai-lut</a>). iOS는 SwiftUI + Vision Framework 네이티브 얼굴 인식, Rust FFI 브리지(<code>ffi_ios.rs</code> + <code>RustBridge.swift</code>). 인도네시아어 번역 추가.</p><hr><h2 class="relative group">기술적 도전과 해결<div id=기술적-도전과-해결 class=anchor></div><span class="absolute top-0 w-6 transition-opacity opacity-0 -start-6 not-prose group-hover:opacity-100 select-none"><a class="text-primary-300 dark:text-neutral-700 !no-underline" href=#%ea%b8%b0%ec%88%a0%ec%a0%81-%eb%8f%84%ec%a0%84%ea%b3%bc-%ed%95%b4%ea%b2%b0 aria-label=앵커>#</a></span></h2><p>프로젝트 전반에 걸쳐 적용된 성능 전략들을 먼저 정리하면 다음과 같다.</p><ul><li><strong>Rayon 병렬 처리</strong> — 대량 이미지 일괄 내보내기 시 멀티코어 활용. 단, 색상 보정 등 픽셀 단위 처리에서는 10만 픽셀 이상인 경우에만 <code>par_chunks_exact_mut()</code>으로 병렬화하고, 작은 이미지는 컨텍스트 스위칭 오버헤드를 피하기 위해 순차 처리한다.</li><li><strong><code>fast_image_resize</code> 기반 리사이징</strong> — <code>image</code> 크레이트의 기본 리사이즈 대신 SIMD 최적화된 <code>fast_image_resize</code>를 사용하여 썸네일 생성 및 프리뷰 리사이징 속도를 크게 개선</li><li><strong>Lazy 로딩과 캐싱</strong> — LUT 파일은 <code>lut_cache: HashMap&lt;Uuid, CubeLut></code>에 최초 사용 시 파싱하여 캐싱하고, EXIF 썸네일도 <code>thumbnail_cache</code>에 지연 로드한다. 백그라운드 스레드용 복제(<code>clone_for_thread()</code>)시에는 캐시를 제외하여 불필요한 메모리 복제를 방지한다.</li><li><strong>퍼셉추얼 해시 기반 이미지 그룹화</strong> — 이미지 로드 시 8×8 그레이스케일 평균 해시(64-bit)를 미리 계산하여, 이후 유사 이미지 그룹화를 해밍 거리 O(1) 비교로 수행. 원본 이미지를 다시 로드하지 않고 메타데이터만으로 그룹화한다.</li><li><strong>빌드 프로파일 최적화</strong> — Release 빌드에서 <code>opt-level = 3</code>, <code>lto = "fat"</code>, <code>codegen-units = 1</code>을 적용하고, Dev 빌드에서도 <code>fast_image_resize</code>, <code>mozjpeg</code>, <code>ab_glyph</code> 등 성능에 민감한 의존성은 <code>opt-level = 3</code>으로 개별 설정하여 디버그 중에도 이미지 처리 성능을 유지한다.</li></ul><h3 class="relative group">1. 크로스플랫폼 FFI의 복잡성<div id=1-크로스플랫폼-ffi의-복잡성 class=anchor></div><span class="absolute top-0 w-6 transition-opacity opacity-0 -start-6 not-prose group-hover:opacity-100 select-none"><a class="text-primary-300 dark:text-neutral-700 !no-underline" href=#1-%ed%81%ac%eb%a1%9c%ec%8a%a4%ed%94%8c%eb%9e%ab%ed%8f%bc-ffi%ec%9d%98-%eb%b3%b5%ec%9e%a1%ec%84%b1 aria-label=앵커>#</a></span></h3><p>Rust 코어를 3개 플랫폼(데스크탑/iOS/Android)에서 사용하기 위해 각각 다른 FFI 전략을 택했다.</p><table><thead><tr><th style=text-align:left>플랫폼</th><th style=text-align:left>FFI 방식</th><th style=text-align:left>특징</th></tr></thead><tbody><tr><td style=text-align:left>데스크탑 (egui)</td><td style=text-align:left>직접 링킹</td><td style=text-align:left>Rust → Rust, FFI 불필요</td></tr><tr><td style=text-align:left>iOS (SwiftUI)</td><td style=text-align:left>C FFI (<code>@_silgen_name</code>)</td><td style=text-align:left>Swift에서 C 함수 직접 호출</td></tr><tr><td style=text-align:left>Android (Compose)</td><td style=text-align:left>JNA (Java Native Access)</td><td style=text-align:left>Kotlin에서 JNA를 통해 .so 호출</td></tr></tbody></table><p>이 브리지 계층을 유지보수하면서도 안정적인 메모리 관리(문자열 할당/해제, 불투명 포인터 핸들 패턴)를 보장하는 것이 주요 과제였다.</p><h3 class="relative group">2. EXIF 파싱의 끝없는 변수<div id=2-exif-파싱의-끝없는-변수 class=anchor></div><span class="absolute top-0 w-6 transition-opacity opacity-0 -start-6 not-prose group-hover:opacity-100 select-none"><a class="text-primary-300 dark:text-neutral-700 !no-underline" href=#2-exif-%ed%8c%8c%ec%8b%b1%ec%9d%98-%eb%81%9d%ec%97%86%eb%8a%94-%eb%b3%80%ec%88%98 aria-label=앵커>#</a></span></h3><p>카메라마다 EXIF 기록 방식이 다르다.</p><ul><li><strong>셔터스피드/F값의 부동소수점 문제</strong> — 1/125초가 <code>0.008000000</code> 같은 지저분한 값으로 기록되는 경우 자동 보정</li><li><strong>HEIF/HEIC 방향 정보 오류</strong> — 일부 이미지에서 방향이 틀어지는 문제</li><li><strong>렌즈 정보 없는 카메라</strong> — Nikon Coolpix 같은 컴팩트 카메라 대응</li><li><strong>MakerNote에 숨겨진 정보</strong> — Lumix LUT명, Nikon PhotoStyle, Sony Creative Look 등 제조사별 비공개 EXIF 필드 파싱</li></ul><p>이를 위해 <a href=https://github.com/kamadak/exif-rs target=_blank rel=noreferrer>exif-rs</a> 라이브러리에 직접 PR을 보내 필요한 기능을 추가했다.</p><h3 class="relative group">3. MakerNote 파싱: 제조사별 촬영 설정 추출<div id=3-makernote-파싱-제조사별-촬영-설정-추출 class=anchor></div><span class="absolute top-0 w-6 transition-opacity opacity-0 -start-6 not-prose group-hover:opacity-100 select-none"><a class="text-primary-300 dark:text-neutral-700 !no-underline" href=#3-makernote-%ed%8c%8c%ec%8b%b1-%ec%a0%9c%ec%a1%b0%ec%82%ac%eb%b3%84-%ec%b4%ac%ec%98%81-%ec%84%a4%ec%a0%95-%ec%b6%94%ec%b6%9c aria-label=앵커>#</a></span></h3><p>최근 미러리스 카메라들은 자체적으로 색감을 맞춰주는 기능이 매우 뛰어나다. Lumix의 Photo Style, Nikon의 Picture Control, Sony의 Creative Look 등이 그것이다. 사진가들 사이에서는 &ldquo;어떤 색감 설정으로 찍었는지"가 카메라 기종이나 렌즈만큼이나 중요한 정보인데, 이 정보를 프레임에 같이 넣어줄 수 있으면 좋겠다는 생각이 들었다.</p><p><a href=https://www.cipa.jp/std/documents/download_e.html?DC-008-Translation-2023-E target=_blank rel=noreferrer>EXIF 표준</a>의 <strong>MakerNote</strong>(Tag 0x927C)는 카메라 제조사가 자유롭게 사용할 수 있는 비표준 영역이다. 포맷이 제조사마다, 심지어 같은 제조사의 모델마다 다르고, 문서화도 빈약하다. 하지만 여기에는 <strong>&ldquo;어떤 색감 설정으로 찍었는지&rdquo;</strong> 같은, 사진가에게 중요한 정보가 숨어 있다.</p><p><figure><img class="my-0 rounded-md" loading=lazy decoding=async fetchpriority=low alt="MakerNote 파싱 흐름" src=/en/posts/chama-optics-dev-story/makernote_parsing.svg></figure></p><p>Chama Optics에서는 <code>exif.maker_note_vendor()</code>로 제조사를 먼저 식별한 뒤, 각 제조사별 전용 파서로 분기한다.</p><p><strong>Nikon</strong> — <code>PictureControlData</code> / <code>PictureControlData2</code> 태그에서 Picture Control 이름을 추출한다. <code>"VitalityFilm_Pmango"</code> 같은 사용자 정의 프로필명이나, <code>"Flat"</code>, <code>"Vivid"</code> 같은 프리셋 이름이 여기에 들어 있다.</p><p><strong>Panasonic (Lumix)</strong> — 가장 풍부한 데이터를 제공한다. <code>PhotoStyleName</code>에서 기본 Photo Style 이름(<code>"NostalgicKintex"</code>)을, <code>LutPrimaryFile</code>/<code>LutSecondaryFile</code>에서 적용된 LUT 파일명(<code>"KintexYellow33.CUBE"</code>)과 Gain 값까지 추출한다. 이 정보는 Chama Optics의 LUT 컬러 그레이딩 기능과 직접 연결된다.</p><p><strong>Sony</strong> — <code>Sony_0x9416</code> 태그에서 Creative Style/Creative Look 정보(<code>"Vivid"</code>, <code>"Standard"</code>, <code>"Portrait"</code> 등)를 추출한다.</p><p>이 MakerNote 파싱 기능은 기존 exif-rs에 없었기 때문에 직접 구현하여 <a href=https://github.com/kamadak/exif-rs/pull/57 target=_blank rel=noreferrer>PR #57</a>로 제출했다.</p><h4 class="relative group">EXIF IFD 엔트리 구조와 MakerNote의 offset 문제<div id=exif-ifd-엔트리-구조와-makernote의-offset-문제 class=anchor></div><span class="absolute top-0 w-6 transition-opacity opacity-0 -start-6 not-prose group-hover:opacity-100 select-none"><a class="text-primary-300 dark:text-neutral-700 !no-underline" href=#exif-ifd-%ec%97%94%ed%8a%b8%eb%a6%ac-%ea%b5%ac%ec%a1%b0%ec%99%80-makernote%ec%9d%98-offset-%eb%ac%b8%ec%a0%9c aria-label=앵커>#</a></span></h4><p>MakerNote를 파싱하려면 먼저 EXIF의 IFD(Image File Directory) 구조를 이해해야 한다. EXIF 데이터는 TIFF 포맷을 기반으로 하며, 각 IFD 엔트리는 정확히 <strong>12바이트</strong>로 구성된다.</p><ul><li><strong>Tag</strong> (2바이트) — 필드 식별자 (예: <code>0x927C</code> = MakerNote)</li><li><strong>Type</strong> (2바이트) — 데이터 타입</li><li><strong>Count</strong> (4바이트) — 값의 개수</li><li><strong>Value/Offset</strong> (4바이트) — 데이터가 4바이트 이하면 값 자체, 초과하면 <strong>데이터의 위치를 가리키는 offset</strong></li></ul><p>표준 EXIF에서 이 offset은 <strong>TIFF 헤더 시작점으로부터의 거리</strong>다. 단순명쾌하다. 그런데 MakerNote 내부의 IFD에서는 이 규칙이 무너진다.</p><p><figure><img class="my-0 rounded-md" loading=lazy decoding=async fetchpriority=low alt="EXIF IFD 엔트리 구조와 MakerNote offset 방식" src=/en/posts/chama-optics-dev-story/exif_makernote_structure.svg></figure></p><p><strong>문제는 이것이다</strong>: MakerNote 내부에도 IFD와 동일한 구조의 엔트리들이 존재하는데, 여기서 offset이 &ldquo;어디를 기준으로 한 거리인지"가 <strong>제조사마다 다르다.</strong></p><ul><li><strong>TIFF-Relative 방식</strong> (Panasonic, Canon, Sony, Leica, Sigma) — MakerNote 안의 offset이 원본 TIFF 헤더 시작점 기준. MakerNote 자체에 TIFF 헤더가 없으며, offset에서 <code>tiff_offset</code>(TIFF 시작점부터 MakerNote까지의 거리)을 빼야 실제 데이터 위치를 찾을 수 있다.</li><li><strong>MakerNote-Relative 방식</strong> (Nikon, Olympus, Fujifilm, Samsung, Apple, Pentax) — MakerNote 안의 offset이 MakerNote 시작점 기준. 자체적으로 완결된 구조(self-contained)이며, Nikon의 경우 MakerNote 안에 독자적인 TIFF 헤더까지 가지고 있다.</li></ul><p>추가로 바이트 오더(엔디안)도 제조사별로 다르다. Nikon은 자체 TIFF 헤더에서, Olympus/Apple은 프로프라이어터리 헤더 내의 <code>"II"</code>/<code>"MM"</code> 바이트에서, Samsung은 IFD 태그 번호의 패턴으로 자동 판별한다.</p><p>결국 10개 제조사(Panasonic, Nikon, Sony, Canon, Olympus, Fujifilm, Samsung, Apple, Sigma, Pentax)에 대해 각각의 헤더 포맷, offset 보정 공식, 바이트 오더 판별 로직을 구현하여, 총 23개 파일 약 5,900줄의 PR이 되었다.</p><h3 class="relative group">4. 카메라 제조사 로고 시스템: CSV → build.rs → 바이너리 임베딩<div id=4-카메라-제조사-로고-시스템-csv--buildrs--바이너리-임베딩 class=anchor></div><span class="absolute top-0 w-6 transition-opacity opacity-0 -start-6 not-prose group-hover:opacity-100 select-none"><a class="text-primary-300 dark:text-neutral-700 !no-underline" href=#4-%ec%b9%b4%eb%a9%94%eb%9d%bc-%ec%a0%9c%ec%a1%b0%ec%82%ac-%eb%a1%9c%ea%b3%a0-%ec%8b%9c%ec%8a%a4%ed%85%9c-csv--buildrs--%eb%b0%94%ec%9d%b4%eb%84%88%eb%a6%ac-%ec%9e%84%eb%b2%a0%eb%94%a9 aria-label=앵커>#</a></span></h3><p>Strap 테마, Film 테마 등에서 사진 프레임에 <strong>카메라 제조사 로고</strong>를 자동으로 삽입하려면 두 가지가 필요하다. (1) EXIF에서 제조사를 인식하는 것, (2) 해당 제조사의 SVG 로고를 렌더링하는 것.</p><h4 class="relative group">컴파일 타임: CSV에서 SVG 다운로드 & 임베딩<div id=컴파일-타임-csv에서-svg-다운로드--임베딩 class=anchor></div><span class="absolute top-0 w-6 transition-opacity opacity-0 -start-6 not-prose group-hover:opacity-100 select-none"><a class="text-primary-300 dark:text-neutral-700 !no-underline" href=#%ec%bb%b4%ed%8c%8c%ec%9d%bc-%ed%83%80%ec%9e%84-csv%ec%97%90%ec%84%9c-svg-%eb%8b%a4%ec%9a%b4%eb%a1%9c%eb%93%9c--%ec%9e%84%eb%b2%a0%eb%94%a9 aria-label=앵커>#</a></span></h4><p>이전에 Rust Embedded 양산 프로젝트에서 <a href=/ko/posts/my_first_commerical_rust_embedded_product_3/><code>const fn</code>/<code>const impl</code>으로 컴파일 타임에 최대한 맡기는 접근</a>과 <a href=/ko/posts/my_first_commerical_rust_embedded_product_4/><code>build.rs</code>를 활용한 빌드 스크립트 기법</a>을 다룬 적이 있다. Chama Optics의 로고 시스템은 이 경험의 연장선에서 <code>build.rs</code> + <code>include_bytes!()</code>를 적극 활용한다.</p><p><figure><img class="my-0 rounded-md" loading=lazy decoding=async fetchpriority=low alt="컴파일 타임 로고 파이프라인" src=/en/posts/chama-optics-dev-story/logo_build_pipeline.svg></figure></p><p><code>assets/logo_mnf.csv</code>에 35개 제조사의 로고 정보가 정의되어 있다. <code>cargo build</code>가 실행되면 <code>build.rs</code>가 이 CSV를 읽어 다음을 수행한다.</p><ol><li><strong>SVG 다운로드</strong> — 각 행의 <code>url</code> 컬럼에서 SVG를 가져온다. Wikimedia Commons URL이면 HTTP로 다운로드하고, 로컬 경로(<code>assets/logo_mnf/contax.svg</code>)이면 직접 읽는다. 네트워크 실패 시 최대 3회, 5초 간격으로 재시도한다.</li><li><strong>MD5 해시 검증</strong> — 다운로드된 파일의 MD5 해시를 CSV의 <code>expected_md5</code> 값과 비교한다. <strong>파일이 이미 존재하고 해시가 일치하면 재다운로드를 건너뛴다.</strong> 해시가 불일치하면 <code>panic!</code>으로 빌드를 중단한다 — Wikimedia 측에서 SVG가 변경되었다면 의도적으로 확인해야 하기 때문이다.</li><li><strong>Rust 코드 생성</strong> — <code>assets/auto_generated/logo_assets.rs</code>를 생성하며, 각 SVG를 <code>include_bytes!()</code>로 바이너리에 임베딩한다. 런타임에 파일 로딩이 필요 없다.</li></ol><div class=highlight-wrapper><div class=highlight><pre tabindex=0 class=chroma><code class=language-rust data-lang=rust><span class=line><span class=cl><span class=c1>// 자동 생성되는 코드 예시
</span></span></span><span class=line><span class=cl><span class=k>pub</span><span class=w> </span><span class=k>const</span><span class=w> </span><span class=no>LOGO_ASSETS</span>: <span class=kp>&amp;</span><span class=p>[</span><span class=n>ArtAsset</span><span class=p>]</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=o>&amp;</span><span class=p>[</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=n>ArtAsset</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=n>key</span>: <span class=s>&#34;canon.svg&#34;</span><span class=p>,</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=n>data</span>: <span class=nc>include_bytes</span><span class=o>!</span><span class=p>(</span><span class=s>&#34;.../assets/download/canon.svg&#34;</span><span class=p>),</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=n>color_type</span>: <span class=nc>ColorType</span>::<span class=n>Color</span><span class=p>,</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=n>mnf</span>: <span class=s>&#34;canon&#34;</span><span class=p>,</span><span class=w> </span><span class=n>model</span>: <span class=s>&#34;&#34;</span><span class=p>,</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=n>mnf_model_rel</span>: <span class=nc>MnfRelation</span>::<span class=n>Any</span><span class=p>,</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=p>},</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=c1>// ... 35개 제조사
</span></span></span><span class=line><span class=cl><span class=p>];</span></span></span></code></pre></div></div><h4 class="relative group">런타임: EXIF → 로고 매칭 → SVG 래스터라이즈<div id=런타임-exif--로고-매칭--svg-래스터라이즈 class=anchor></div><span class="absolute top-0 w-6 transition-opacity opacity-0 -start-6 not-prose group-hover:opacity-100 select-none"><a class="text-primary-300 dark:text-neutral-700 !no-underline" href=#%eb%9f%b0%ed%83%80%ec%9e%84-exif--%eb%a1%9c%ea%b3%a0-%eb%a7%a4%ec%b9%ad--svg-%eb%9e%98%ec%8a%a4%ed%84%b0%eb%9d%bc%ec%9d%b4%ec%a6%88 aria-label=앵커>#</a></span></h4><p><figure><img class="my-0 rounded-md" loading=lazy decoding=async fetchpriority=low alt="런타임 로고 매칭" src=/en/posts/chama-optics-dev-story/logo_runtime_matching.svg></figure></p><p>사진이 로드되면 EXIF의 <code>Tag::Make</code>(제조사)와 <code>Tag::Model</code>(모델명)을 추출하고, <code>LOGO_ASSETS</code> 배열을 순회하며 매칭한다.</p><p>매칭 규칙은 두 가지다.</p><ul><li><strong><code>MnfRelation::Any</code></strong> — 제조사명 <strong>또는</strong> 모델명 중 하나만 일치하면 됨 (대부분의 경우)</li><li><strong><code>MnfRelation::Both</code></strong> — 제조사명 <strong>그리고</strong> 모델명 둘 다 일치해야 함 (특수한 경우)</li></ul><p><code>Both</code>가 필요한 실제 사례: <strong>Sigma</strong>는 2025년에 로고를 변경했다. 새 로고를 사용하는 카메라는 <code>SIGMA BF</code> 모델뿐이므로, CSV에 <code>mnf="sigma", model="sigma bf", mnf_model_rel=Both</code>로 <code>sigma2025.svg</code>(신로고)를 등록하고, 나머지 Sigma 카메라는 <code>mnf="sigma", mnf_model_rel=Any</code>로 <code>sigma.svg</code>(구 로고)를 사용하도록 분리했다.</p><p>매칭된 SVG는 <code>usvg</code>로 파싱 후 <code>resvg</code>+<code>tiny-skia</code>로 래스터라이즈하여, 프레임 내 적절한 위치와 크기로 합성된다. <code>color_type</code>(Black/Color)과 <code>fill_ops</code>(Default/Monochrome)에 따라 렌더링 방식이 달라져, 배경색에 맞는 로고 표현이 가능하다.</p><h3 class="relative group">5. CJK 폰트 렌더링과 가변 폰트(Variable Font) 최적화<div id=5-cjk-폰트-렌더링과-가변-폰트variable-font-최적화 class=anchor></div><span class="absolute top-0 w-6 transition-opacity opacity-0 -start-6 not-prose group-hover:opacity-100 select-none"><a class="text-primary-300 dark:text-neutral-700 !no-underline" href=#5-cjk-%ed%8f%b0%ed%8a%b8-%eb%a0%8c%eb%8d%94%eb%a7%81%ea%b3%bc-%ea%b0%80%eb%b3%80-%ed%8f%b0%ed%8a%b8variable-font-%ec%b5%9c%ec%a0%81%ed%99%94 aria-label=앵커>#</a></span></h3><p>일본어·한국어·중국어 텍스트를 이미지에 렌더링할 때 수많은 문제가 발생했다.</p><ul><li>일부 CJK 한자(ideograph)가 렌더링되지 않는 문제</li><li>가변 폰트에서 글리프 폭이 맞지 않는 문제</li></ul><p>해결책으로 <strong>SourceHanSans를 빌트인 fallback 폰트</strong>로 내장하여, 선택한 폰트에서 지원하지 않는 글리프를 자동으로 대체 렌더링하도록 했다. 구체적으로는 텍스트를 문자 단위로 순회하면서, 주 폰트에서 <code>GlyphId(0)</code> (글리프 없음)이 반환되면 SourceHanSans fallback 폰트로 전환하여 렌더링한다.</p><h4 class="relative group">가변 폰트 weight 재매핑<div id=가변-폰트-weight-재매핑 class=anchor></div><span class="absolute top-0 w-6 transition-opacity opacity-0 -start-6 not-prose group-hover:opacity-100 select-none"><a class="text-primary-300 dark:text-neutral-700 !no-underline" href=#%ea%b0%80%eb%b3%80-%ed%8f%b0%ed%8a%b8-weight-%ec%9e%ac%eb%a7%a4%ed%95%91 aria-label=앵커>#</a></span></h4><p>Chama Optics에서 사용하는 주 폰트인 <strong>BarlowGX.ttf</strong>는 가변 폰트(Variable Font)이지만, 내부 weight 축 값이 <strong>22~188</strong>이라는 비표준 범위를 사용하고 있었다. CSS 표준이나 FreeType 등에서 사용하는 <strong>100~900</strong> 범위와 맞지 않아, <code>ab_glyph</code>에서 <code>set_variation(b"wght", 400.0)</code>으로 Regular weight를 지정해도 의도한 결과가 나오지 않았다. 추가로 기본 width가 wdth=300(Condensed)으로 설정되어 있어 글리프 폭도 맞지 않았다.</p><p>단순히 <code>fvar</code>(Font Variations 메타데이터)만 수정하면 될 줄 알았지만, 실제 글리프 폭을 담고 있는 <code>hmtx</code> 테이블은 여전히 Condensed 기준이었다. <strong>메타데이터만 바꾸면 렌더링 결과는 변하지 않는다.</strong> 결국 BarlowGX.ttf에서 9개 weight 인스턴스를 wdth=500(Regular width)으로 추출하고, 이를 마스터 소스로 사용하여 <code>fontTools.varLib.build()</code>로 가변 폰트를 통째로 재빌드하여 해결했다. 결과물이 <code>Barlow-Variable-Remapped.ttf</code>와 <code>Barlow-Variable-Remapped-Narrow.ttf</code>이다.</p><h4 class="relative group">여러 폰트 파일을 하나로 합치기 — 절대적인 파일 사이즈 축소<div id=여러-폰트-파일을-하나로-합치기--절대적인-파일-사이즈-축소 class=anchor></div><span class="absolute top-0 w-6 transition-opacity opacity-0 -start-6 not-prose group-hover:opacity-100 select-none"><a class="text-primary-300 dark:text-neutral-700 !no-underline" href=#%ec%97%ac%eb%9f%ac-%ed%8f%b0%ed%8a%b8-%ed%8c%8c%ec%9d%bc%ec%9d%84-%ed%95%98%eb%82%98%eb%a1%9c-%ed%95%a9%ec%b9%98%ea%b8%b0--%ec%a0%88%eb%8c%80%ec%a0%81%ec%9d%b8-%ed%8c%8c%ec%9d%bc-%ec%82%ac%ec%9d%b4%ec%a6%88-%ec%b6%95%ec%86%8c aria-label=앵커>#</a></span></h4><p>가변 폰트의 또 다른 장점은 <strong>여러 weight 파일을 하나로 합칠 수 있다</strong>는 점이다. 기존에 Barlow-Thin.ttf, Barlow-Light.ttf, Barlow-Regular.ttf, Barlow-Bold.ttf, Barlow-Black.ttf 등 9개 이상의 정적 폰트 파일이 필요했던 것을, 가변 폰트 하나로 대체할 수 있다.</p><p>CJK 폰트도 마찬가지다. SourceHanSans(한일중 문자를 위한 최적의 선택)는 원래 weight별로 별도 파일이 제공되지만, 가변 폰트 버전(<code>SourceHanSansVF</code>)을 사용하면 하나의 파일로 200~800 범위의 weight를 모두 커버한다. 다만 이 폰트도 BarlowGX와 동일한 문제가 있어 weight 축을 표준 범위로 재매핑하여 <code>SourceHanSansVF-remapped.otf</code>를 생성했다.</p><p>더 나아가 <code>fontTools</code>를 활용하여 <strong>서로 다른 문자 집합을 가진 폰트들을 하나로 병합</strong>하는 작업도 진행했다. 라틴 문자 폰트 + 일본어 폰트 + 한국어 폰트를 합쳐 하나의 파일로 만들 수 있으며, WOFF2 압축 해제, TTC(Font Collection) 처리, 특정 weight로 인스턴스 추출, UTF-8 기반 문자 서브셋팅 등을 조합하여 최종 파일 크기를 최소화했다.</p><p>최종적으로 Chama Optics에 내장되는 폰트 파일은:</p><table><thead><tr><th style=text-align:left>폰트</th><th style=text-align:right>정적 폰트 시 용량</th><th style=text-align:right>가변 폰트 용량</th><th style=text-align:left>절감</th></tr></thead><tbody><tr><td style=text-align:left><code>Barlow-Variable-Remapped.ttf</code> (100~900)</td><td style=text-align:right>~1.35 MB (9 weight)</td><td style=text-align:right><strong>385 KB</strong></td><td style=text-align:left><strong>~3.5x</strong></td></tr><tr><td style=text-align:left><code>Barlow-Variable-Remapped-Narrow.ttf</code> (100~900)</td><td style=text-align:right>~1.45 MB (9 weight)</td><td style=text-align:right><strong>207 KB</strong></td><td style=text-align:left><strong>~7x</strong></td></tr><tr><td style=text-align:left><code>SourceHanSansVF-remapped.otf</code> (200~800)</td><td style=text-align:right>~105 MB (7 weight)</td><td style=text-align:right><strong>30 MB</strong></td><td style=text-align:left><strong>~3.5x</strong></td></tr><tr><td style=text-align:left><code>DejaVuSansMono.ttf</code> (정적)</td><td style=text-align:right>—</td><td style=text-align:right>327 KB</td><td style=text-align:left>—</td></tr><tr><td style=text-align:left><code>digital-7.ttf</code> (정적)</td><td style=text-align:right>—</td><td style=text-align:right>34 KB</td><td style=text-align:left>—</td></tr><tr><td style=text-align:left><strong>합계</strong></td><td style=text-align:right><strong>~108 MB</strong></td><td style=text-align:right><strong>~31 MB</strong></td><td style=text-align:left><strong>~3.5x</strong></td></tr></tbody></table><p>Barlow의 경우가 특히 극적이다. 원본 Barlow 프로젝트에는 9 weight × 3 width × 2 (upright+italic) = 54개 정적 TTF 파일이 있고 합계 <strong>8.5 MB</strong>인데, Chama Optics에서 필요한 normal + narrow 두 가변 폰트는 합쳐서 <strong>592 KB</strong>에 불과하다. 모바일 앱 번들 크기에 민감한 환경에서 이 차이는 결정적이다.</p><h4 class="relative group">egui에서 가변 폰트 weight 선택 로딩<div id=egui에서-가변-폰트-weight-선택-로딩 class=anchor></div><span class="absolute top-0 w-6 transition-opacity opacity-0 -start-6 not-prose group-hover:opacity-100 select-none"><a class="text-primary-300 dark:text-neutral-700 !no-underline" href=#egui%ec%97%90%ec%84%9c-%ea%b0%80%eb%b3%80-%ed%8f%b0%ed%8a%b8-weight-%ec%84%a0%ed%83%9d-%eb%a1%9c%eb%94%a9 aria-label=앵커>#</a></span></h4><p>데스크탑 버전(egui)에서는 가변 폰트의 weight를 <strong>사용자가 자유롭게 조절</strong>할 수 있다. 핵심은 <code>ab_glyph</code> 크레이트의 <code>set_variation</code> API다.</p><div class=highlight-wrapper><div class=highlight><pre tabindex=0 class=chroma><code class=language-rust data-lang=rust><span class=line><span class=cl><span class=k>pub</span><span class=w> </span><span class=k>struct</span> <span class=nc>VariableFontPack</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=k>pub</span><span class=w> </span><span class=n>label</span>: <span class=kp>&amp;</span><span class=nb>&#39;static</span> <span class=kt>str</span><span class=p>,</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=k>pub</span><span class=w> </span><span class=n>font</span>: <span class=nc>ab_glyph</span>::<span class=n>FontRef</span><span class=o>&lt;</span><span class=nb>&#39;static</span><span class=o>&gt;</span><span class=p>,</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=k>pub</span><span class=w> </span><span class=n>default</span>: <span class=kt>u16</span><span class=p>,</span><span class=w>       </span><span class=c1>// 기본 weight (예: 300)
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=k>pub</span><span class=w> </span><span class=n>start</span>: <span class=kt>u16</span><span class=p>,</span><span class=w>         </span><span class=c1>// 최소 weight (예: 100)
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=k>pub</span><span class=w> </span><span class=n>end_include</span>: <span class=kt>u16</span><span class=p>,</span><span class=w>   </span><span class=c1>// 최대 weight (예: 900)
</span></span></span><span class=line><span class=cl><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=k>impl</span><span class=w> </span><span class=n>VariableFontPack</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=k>pub</span><span class=w> </span><span class=k>fn</span> <span class=nf>get_font_by_weight</span><span class=p>(</span><span class=o>&amp;</span><span class=bp>self</span><span class=p>,</span><span class=w> </span><span class=n>weight</span>: <span class=kt>u16</span><span class=p>)</span><span class=w> </span>-&gt; <span class=nc>ab_glyph</span>::<span class=n>FontArc</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=kd>let</span><span class=w> </span><span class=n>clamped</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>weight</span><span class=p>.</span><span class=n>clamp</span><span class=p>(</span><span class=bp>self</span><span class=p>.</span><span class=n>start</span><span class=p>,</span><span class=w> </span><span class=bp>self</span><span class=p>.</span><span class=n>end_include</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=kd>let</span><span class=w> </span><span class=k>mut</span><span class=w> </span><span class=n>font</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=bp>self</span><span class=p>.</span><span class=n>font</span><span class=p>.</span><span class=n>clone</span><span class=p>();</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=n>font</span><span class=p>.</span><span class=n>set_variation</span><span class=p>(</span><span class=sa>b</span><span class=s>&#34;wght&#34;</span><span class=p>,</span><span class=w> </span><span class=n>clamped</span><span class=w> </span><span class=k>as</span><span class=w> </span><span class=kt>f32</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=n>font</span><span class=p>.</span><span class=n>into</span><span class=p>()</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=p>}</span></span></span></code></pre></div></div><p>사용자가 테마 설정에서 weight 슬라이더를 조절하면, 해당 weight 값으로 <code>set_variation(b"wght", weight)</code>를 호출하여 런타임에 폰트의 굵기가 변경된다. 100(Thin)부터 900(Black)까지 연속적인 값을 지정할 수 있으며, 350이나 450 같은 중간값도 보간(interpolation)되어 부드러운 weight 전환이 가능하다.</p><p>이 로직은 데스크탑뿐 아니라 iOS/Android에서도 동일하게 동작한다. iOS에서는 <code>FontSelectionView</code>에서 가변 폰트인 경우에만 weight 슬라이더를 표시하고, 선택된 weight 값을 FFI를 통해 Rust 코어에 전달한다. Android에서도 Kotlin에서 <code>fontWeight</code> 파라미터로 Rust FFI에 전달하는 동일한 구조다.</p><p>CJK fallback도 weight를 반영한다. 주 폰트가 Barlow weight 700(Bold)이고 CJK 문자가 나오면, SourceHanSans도 700에 가까운 weight로 렌더링하여 <strong>라틴 문자와 CJK 문자의 굵기가 일관되게</strong> 보이도록 했다.</p><h4 class="relative group">빌트인 폰트와 시스템 폰트<div id=빌트인-폰트와-시스템-폰트 class=anchor></div><span class="absolute top-0 w-6 transition-opacity opacity-0 -start-6 not-prose group-hover:opacity-100 select-none"><a class="text-primary-300 dark:text-neutral-700 !no-underline" href=#%eb%b9%8c%ed%8a%b8%ec%9d%b8-%ed%8f%b0%ed%8a%b8%ec%99%80-%ec%8b%9c%ec%8a%a4%ed%85%9c-%ed%8f%b0%ed%8a%b8 aria-label=앵커>#</a></span></h4><p>Chama Optics에서 사용하는 폰트는 두 종류로 나뉜다. <strong>빌트인(builtin) 폰트</strong>와 <strong>시스템(OS) 폰트</strong>.</p><p>빌트인 폰트는 앱에 기본 내장되는 폰트로, Barlow(라틴), SourceHanSans(CJK fallback), D2Coding(모노스페이스), Digital-7(Segment Display 스타일) 등이 있다. 시스템 폰트는 사용자의 OS에 설치된 폰트를 가져와서 테마에 적용할 수 있도록 하는 기능이다. EXIF 프레임에 표시되는 텍스트의 폰트를 사용자가 자유롭게 선택할 수 있어야 하기 때문에, 빌트인 폰트만으로는 부족하다.</p><p><strong>데스크탑에서는 <code>include_bytes!</code>로 폰트를 바이너리에 내장</strong>한다.</p><div class=highlight-wrapper><div class=highlight><pre tabindex=0 class=chroma><code class=language-rust data-lang=rust><span class=line><span class=cl><span class=k>pub</span><span class=p>(</span><span class=k>crate</span><span class=p>)</span><span class=w> </span><span class=k>const</span><span class=w> </span><span class=no>FONT_BARLOW</span>: <span class=nc>BuiltInFonts</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>BuiltInFonts</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=n>name</span>: <span class=s>&#34;Barlow&#34;</span><span class=p>,</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=n>data</span>: <span class=nc>include_bytes</span><span class=o>!</span><span class=p>(</span><span class=s>&#34;../../assets/fonts/Barlow-Variable-Remapped.ttf&#34;</span><span class=p>),</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=p>};</span></span></span></code></pre></div></div><p>데스크탑은 실행 파일 하나로 배포하는 것이 편리하기 때문에, 폰트 파일을 컴파일 시점에 바이너리에 포함시킨다. 별도의 폰트 디렉토리 없이 실행 파일만 있으면 바로 동작한다.</p><p>반면 <strong>iOS/Android에서는 폰트를 파일 경로로 동적 로딩</strong>한다. 모바일 앱은 바이너리 크기에 민감하고, 앱 번들 내에 리소스 파일로 분리하는 것이 플랫폼 관례이기도 하다. Swift/Kotlin에서 FFI를 통해 폰트 디렉토리 경로를 Rust 코어에 전달하면, Rust 쪽에서 <code>std::fs::read()</code>로 필요한 시점에 파일을 읽어 로딩한다.</p><p>시스템 폰트는 데스크탑에서만 지원한다. <code>font-kit</code> 크레이트의 <code>SystemSource</code>를 사용하여 OS에 설치된 폰트 목록을 열거하고, 사용자가 선택한 폰트를 로드한다. 이 작업은 UI를 블로킹하지 않도록 백그라운드 스레드에서 수행되며, <code>Arc&lt;RwLock&lt;Vec&lt;SystemFont>>></code>로 스레드 안전하게 공유한다.</p><h4 class="relative group">font-kit macOS 메모리 폭주 디버깅<div id=font-kit-macos-메모리-폭주-디버깅 class=anchor></div><span class="absolute top-0 w-6 transition-opacity opacity-0 -start-6 not-prose group-hover:opacity-100 select-none"><a class="text-primary-300 dark:text-neutral-700 !no-underline" href=#font-kit-macos-%eb%a9%94%eb%aa%a8%eb%a6%ac-%ed%8f%ad%ec%a3%bc-%eb%94%94%eb%b2%84%ea%b9%85 aria-label=앵커>#</a></span></h4><p>시스템 폰트 열거를 구현한 뒤 macOS에서 심각한 문제가 발생했다. 앱 실행 직후 <strong>메모리 사용량이 1.0GB, 피크 1.5GB까지 치솟는</strong> 현상이었다. (<a href=https://github.com/pmnxis/chama-optics/issues/5 target=_blank rel=noreferrer>#5</a>)</p><p><code>MallocStackLogging</code>과 <code>malloc_history</code>로 추적한 결과, 원인은 <code>font-kit</code>의 macOS 백엔드(<code>core_text</code>)에 있었다. <code>font_kit::SystemSource::all_fonts()</code>가 시스템 폰트 목록을 열거하면서, <strong>각 폰트의 전체 파일 데이터를 메모리에 읽어들이고 있었다</strong>:</p><div class=highlight-wrapper><div class=highlight><pre tabindex=0 class=chroma><code class=language-text data-lang=text><span class=line><span class=cl>435 calls for 2045941700 bytes:  ← 약 2GB
</span></span><span class=line><span class=cl>  font_kit::sources::core_text::create_handles_from_core_text_collection
</span></span><span class=line><span class=cl>    font_kit::utils::slurp_file    ← 폰트 파일 전체를 메모리로 읽음
</span></span><span class=line><span class=cl>      alloc::raw_vec::RawVecInner::try_allocate_in</span></span></code></pre></div></div><p>macOS에는 수백 개의 시스템 폰트가 설치되어 있고, CJK 폰트(예: Apple SD Gothic Neo, Hiragino 등)는 개별 파일이 수십 MB에 달한다. <code>slurp_file</code>이 이 파일들을 전부 메모리에 올리면서 435개 폰트에 대해 약 2GB를 할당한 것이다. (Windows에서는 동일 코드에서 약 90MB 수준이었다.)</p><p>해결 방법은 <code>font-kit</code>를 포크하여 <code>all_fonts()</code> 호출 시 <strong>폰트 데이터를 읽지 않고 메타데이터(이름, 경로)만 수집</strong>하도록 수정하는 것이었다. 수정 후 메모리 사용량은 <strong>144.9MB</strong>(피크 389.4MB)로 대폭 감소했다.</p><h3 class="relative group">6. LUT 컬러 그레이딩: wagahai-lut의 최적화 철학<div id=6-lut-컬러-그레이딩-wagahai-lut의-최적화-철학 class=anchor></div><span class="absolute top-0 w-6 transition-opacity opacity-0 -start-6 not-prose group-hover:opacity-100 select-none"><a class="text-primary-300 dark:text-neutral-700 !no-underline" href=#6-lut-%ec%bb%ac%eb%9f%ac-%ea%b7%b8%eb%a0%88%ec%9d%b4%eb%94%a9-wagahai-lut%ec%9d%98-%ec%b5%9c%ec%a0%81%ed%99%94-%ec%b2%a0%ed%95%99 aria-label=앵커>#</a></span></h3><p>라이브러리 이름의 유래는 <a href=https://x.com/wagahaida_L target=_blank rel=noreferrer>wagahaida_L(라플라스 다크니스)</a>의 트윗에서 따왔다.</p><table><thead><tr><th>LaplusDarknesss</th><th>wagahaida_L</th></tr></thead><tbody><tr><td><blockquote class=twitter-tweet><p lang=qme dir=ltr><a href=https://t.co/dKCBGYJobj>pic.twitter.com/dKCBGYJobj</a></p>&mdash; ラプラス・ダークネス🛸💜 (@LaplusDarknesss) <a href="https://twitter.com/LaplusDarknesss/status/1940063453647147386?ref_src=twsrc%5Etfw">July 1, 2025</a></blockquote><script async src=https://platform.twitter.com/widgets.js></script></td><td><blockquote class=twitter-tweet><p lang=zxx dir=ltr><a href=https://t.co/WjplefTDWX>https://t.co/WjplefTDWX</a> <a href=https://t.co/8L19fSqYBg>pic.twitter.com/8L19fSqYBg</a></p>&mdash; ラプ様 (@wagahaida_L) <a href="https://twitter.com/wagahaida_L/status/1992881206682423708?ref_src=twsrc%5Etfw">November 24, 2025</a></blockquote><script async src=https://platform.twitter.com/widgets.js></script></td></tr></tbody></table><blockquote><p>여담으로 v0.2.0에서 준비 중인 체키풍(폴라로이드) 이미지 자동 생성 기능 또한 라플라스 다크니스에게서 아이디어를 얻었다. 요망하게 머리가 좋다고 생각한다.</p></blockquote><p>v0.1.9에서 추가된 LUT 컬러 그레이딩 기능은 직접 개발한 <a href=https://github.com/pmnxis/wagahai-lut target=_blank rel=noreferrer>wagahai-lut</a> (<a href=https://crates.io/crates/wagahai-lut target=_blank rel=noreferrer>crates.io</a>) 라이브러리를 사용한다.</p><h4 class="relative group">CUBE LUT이란?<div id=cube-lut이란 class=anchor></div><span class="absolute top-0 w-6 transition-opacity opacity-0 -start-6 not-prose group-hover:opacity-100 select-none"><a class="text-primary-300 dark:text-neutral-700 !no-underline" href=#cube-lut%ec%9d%b4%eb%9e%80 aria-label=앵커>#</a></span></h4><p>CUBE LUT(Look-Up Table)은 <a href=https://web.archive.org/web/20220220033515/https://wwwimages2.adobe.com/content/dam/acom/en/products/speedgrade/cc/pdfs/cube-lut-specification-1.0.pdf target=_blank rel=noreferrer>Adobe가 정의한 <code>.cube</code> 파일 포맷</a>으로, 색상 변환 정보를 담고 있다. 1D LUT과 3D LUT 두 종류가 있다.</p><p><figure><img class="my-0 rounded-md" loading=lazy decoding=async fetchpriority=low alt="CUBE LUT 개념" src=/en/posts/chama-optics-dev-story/lut_cube_concept.svg></figure></p><p><strong>1D LUT</strong>은 R, G, B 각 채널을 독립적으로 변환한다. 입력값을 테이블에서 찾아 출력값으로 바꾸는 단순한 구조다. 밝기/대비 조정에 적합하지만, 채널 간 상호작용(예: 빨간색을 파란색으로 바꾸는 것)은 불가능하다. 테이블 크기는 보통 1,024(10-bit)에서 65,536(16-bit)개 엔트리이며, 인접한 두 엔트리 사이의 값은 선형 보간(linear interpolation)으로 계산한다.</p><p><strong>3D LUT</strong>은 RGB 3차원 색상 공간 전체를 매핑한다. 입력 (R, G, B)가 완전히 다른 (R&rsquo;, G&rsquo;, B&rsquo;)로 변환될 수 있어, 영화/사진의 크리에이티브 색감 보정(film look, color grading)에 사용된다. 큐브 내부의 격자점(lattice point)이 알려진 매핑을 정의하고, 격자점 사이의 값은 주변 8개 꼭짓점으로부터 <strong>삼선형 보간</strong>(trilinear interpolation)으로 계산한다. 일반적인 크기는 17³(4,913점), 33³(35,937점), 65³(274,625점)이다.</p><h4 class="relative group">wagahai-lut의 최적화 전략<div id=wagahai-lut의-최적화-전략 class=anchor></div><span class="absolute top-0 w-6 transition-opacity opacity-0 -start-6 not-prose group-hover:opacity-100 select-none"><a class="text-primary-300 dark:text-neutral-700 !no-underline" href=#wagahai-lut%ec%9d%98-%ec%b5%9c%ec%a0%81%ed%99%94-%ec%a0%84%eb%9e%b5 aria-label=앵커>#</a></span></h4><p>기존 Rust LUT 라이브러리들은 범용성에 초점이 맞춰져 있었다. wagahai-lut은 &ldquo;24MP 사진 수십 장을 일괄 처리해도 빨라야 한다"는 Chama Optics의 요구사항에 맞춰, 메모리 레이아웃부터 SIMD 수준까지 최적화했다. 다만 x86_64와 ARM64 양쪽을 모두 지원해야 하므로 직접 어셈블리를 작성하는 대신 <a href=https://crates.io/crates/wide target=_blank rel=noreferrer><code>wide</code></a> 크레이트를 사용하여 아키텍처에 구애받지 않는 보편적인 벡터 최적화를 택했다.</p><p><figure><img class="my-0 rounded-md" loading=lazy decoding=async fetchpriority=low alt="wagahai-lut 최적화 전략" src=/en/posts/chama-optics-dev-story/lut_optimization.svg></figure></p><p><strong>1) Structure of Arrays (SoA) 메모리 레이아웃</strong></p><p>일반적인 3D LUT 구현은 <code>[Rgb, Rgb, Rgb, ...]</code> 형태의 AoS(Array of Structures) 레이아웃을 사용한다. 하지만 삼선형 보간은 한 번에 한 채널씩 8개 꼭짓점 값을 읽어야 하므로, AoS에서는 캐시 라인에 불필요한 채널 데이터가 함께 로드된다.</p><p>wagahai-lut은 3D LUT을 <code>r: Vec&lt;f32></code>, <code>g: Vec&lt;f32></code>, <code>b: Vec&lt;f32></code> 세 개의 분리된 배열로 저장한다. 이 SoA 레이아웃 덕분에 한 채널의 보간에 필요한 8개 값이 메모리상 가까이 위치하여 CPU 캐시 적중률이 높아진다.</p><p><strong>2) SIMD 병렬 처리 (<code>wide::f32x4</code>)</strong></p><p>1D LUT 처리에서는 <code>wide</code> 크레이트의 <code>f32x4</code> SIMD 벡터를 사용하여 R, G, B 세 채널의 선형 보간을 <strong>단일 벡터 연산</strong>으로 수행한다. 4개 레인 중 3개를 R, G, B에 할당하고, 곱셈·덧셈이 한 번의 명령어로 처리된다.</p><p><strong>3) 고정 크기 특수화 (Fixed-Size Specialization)</strong></p><p>1D LUT은 <code>Bit10(1024)</code>, <code>Bit12(4096)</code>, <code>Bit14(16384)</code>, <code>Bit16(65536)</code> 등 일반적인 크기에 대해 <code>Box&lt;[Rgb; SIZE]></code> 고정 크기 배열을 사용한다. 컴파일 타임에 크기가 결정되므로 경계 검사(bounds checking)를 건너뛰고 <code>get_unchecked()</code>로 직접 접근이 가능하다. 3D LUT도 17³, 33³, 65³ 같은 일반적인 크기를 별도 타입으로 제공한다.</p><p><strong>4) In-Place 처리와 루프 최적화</strong></p><p><code>apply_rgb_mut()</code> / <code>apply_rgba_mut()</code> 함수는 이미지 버퍼를 제자리에서(in-place) 수정하여 추가 메모리 할당이 전혀 없다. 핫 루프에서는 도메인 범위의 역수(<code>inv_domain_range</code>)를 루프 밖에서 미리 계산하고, 원시 포인터(raw pointer) 연산으로 <code>get_pixel()</code>/<code>put_pixel()</code> 호출 오버헤드를 제거하며, 바이트 슬라이스를 선형으로 순회하여 CPU 캐시 프리페치를 극대화한다.</p><h4 class="relative group">벤치마크 결과<div id=벤치마크-결과 class=anchor></div><span class="absolute top-0 w-6 transition-opacity opacity-0 -start-6 not-prose group-hover:opacity-100 select-none"><a class="text-primary-300 dark:text-neutral-700 !no-underline" href=#%eb%b2%a4%ec%b9%98%eb%a7%88%ed%81%ac-%ea%b2%b0%ea%b3%bc aria-label=앵커>#</a></span></h4><p>M4 Max(Stable Rust) 기준 처리 시간 (JPEG 디코딩/인코딩 시간 포함):</p><table><thead><tr><th style=text-align:left>해상도</th><th style=text-align:right>1D LUT</th><th style=text-align:right>3D LUT</th></tr></thead><tbody><tr><td style=text-align:left>1920×1080 (FHD)</td><td style=text-align:right>14.39 ms</td><td style=text-align:right>19.40 ms</td></tr><tr><td style=text-align:left>6000×4000 (24MP)</td><td style=text-align:right>159.91 ms</td><td style=text-align:right>223.15 ms</td></tr><tr><td style=text-align:left>8144×5424 (44MP)</td><td style=text-align:right>294.34 ms</td><td style=text-align:right>417.09 ms</td></tr></tbody></table><p>24MP 사진 기준 3D LUT 적용이 약 0.22초로, Chama Optics에서 수십 장의 사진을 일괄 처리할 때 Rayon 병렬화와 결합하면 실용적인 속도를 달성할 수 있다.</p><h3 class="relative group">7. 데스크탑 얼굴 인식: Speed Mode와 슬라이딩 윈도우 알고리즘<div id=7-데스크탑-얼굴-인식-speed-mode와-슬라이딩-윈도우-알고리즘 class=anchor></div><span class="absolute top-0 w-6 transition-opacity opacity-0 -start-6 not-prose group-hover:opacity-100 select-none"><a class="text-primary-300 dark:text-neutral-700 !no-underline" href=#7-%eb%8d%b0%ec%8a%a4%ed%81%ac%ed%83%91-%ec%96%bc%ea%b5%b4-%ec%9d%b8%ec%8b%9d-speed-mode%ec%99%80-%ec%8a%ac%eb%9d%bc%ec%9d%b4%eb%94%a9-%ec%9c%88%eb%8f%84%ec%9a%b0-%ec%95%8c%ea%b3%a0%eb%a6%ac%ec%a6%98 aria-label=앵커>#</a></span></h3><p>데스크탑에서는 ONNX Runtime + InsightFace(det_10g) 모델을 사용한다. 이 모델의 입력 크기는 <strong>고정 640×640 픽셀</strong>이다. 하지만 실제 사진은 24MP(6000×4000) 이상인 경우가 대부분이고, 640×640으로 전체 이미지를 축소하면 인물이 작게 촬영된 단체 사진에서는 얼굴을 놓치게 된다.</p><p>이 문제를 해결하기 위해 <strong>Speed Mode에 따른 다단계 슬라이딩 윈도우 알고리즘</strong>을 구현했다.</p><table><thead><tr><th style=text-align:left>모드</th><th style=text-align:center>max_depth</th><th style=text-align:left>Depth Loop 윈도우 크기</th><th style=text-align:left>전체 동작</th></tr></thead><tbody><tr><td style=text-align:left>Fastest</td><td style=text-align:center>0</td><td style=text-align:left>(없음)</td><td style=text-align:left>전체 이미지 → 640×640 리사이즈 → 단일 추론</td></tr><tr><td style=text-align:left>Fast</td><td style=text-align:center>1</td><td style=text-align:left>(없음, depth loop 미실행)</td><td style=text-align:left>+ 짧은변(<code>min(W,H)</code>) 크기 슬라이딩 윈도우</td></tr><tr><td style=text-align:left>Normal</td><td style=text-align:center>1</td><td style=text-align:left>640×640</td><td style=text-align:left>+ 640×640 세밀 윈도우</td></tr><tr><td style=text-align:left>Slow</td><td style=text-align:center>2</td><td style=text-align:left>1280×1280 → 640×640</td><td style=text-align:left>+ 1280→640 다단계 윈도우</td></tr><tr><td style=text-align:left>Slowest</td><td style=text-align:center>3</td><td style=text-align:left>2560×2560 → 1280×1280 → 640×640</td><td style=text-align:left>+ 2560→1280→640 전체 다단계 윈도우</td></tr></tbody></table><blockquote><p><strong>Depth Loop 윈도우 크기 공식</strong>: <code>window = 640 × 2^(max_depth - depth - 1)</code></p><p>예: Slowest(max_depth=3) → depth 0: 2560, depth 1: 1280, depth 2: 640</p></blockquote><p>알고리즘의 흐름은 다음과 같다.</p><ol><li><strong>1단계 (공통)</strong>: 전체 이미지를 640×640으로 리사이즈하여 단일 추론. 큰 얼굴은 이 단계에서 잡힌다.</li><li><strong>2단계 (Fast 이상)</strong>: 이미지의 짧은 변(<code>min(width, height)</code>) 크기의 슬라이딩 윈도우를 10% 겹침으로 이동시키며 각 윈도우를 640×640으로 축소하여 추론. 비정상적인 종횡비(파노라마 등)에서의 누락을 방지.</li><li><strong>3단계 (Normal 이상)</strong>: <code>640 × 2^(max_depth - depth - 1)</code> 크기의 윈도우를 depth별로 순회. Slowest는 2560→1280→640, Slow는 1280→640, Normal은 640 단일 depth.</li><li><strong>최종</strong>: NMS(Non-Maximum Suppression, IoU 임계값 0.4)로 중복 감지 제거.</li></ol><p>각 Speed Mode의 동작을 시각화한 다이어그램 (6000×4000 원본 이미지 기준):</p><h4 class="relative group">Fastest<div id=fastest class=anchor></div><span class="absolute top-0 w-6 transition-opacity opacity-0 -start-6 not-prose group-hover:opacity-100 select-none"><a class="text-primary-300 dark:text-neutral-700 !no-underline" href=#fastest aria-label=앵커>#</a></span></h4><p><figure><img class="my-0 rounded-md" loading=lazy decoding=async fetchpriority=low alt="Speed Mode: Fastest" src=/en/posts/chama-optics-dev-story/speed_mode_fastest.svg></figure></p><h4 class="relative group">Fast<div id=fast class=anchor></div><span class="absolute top-0 w-6 transition-opacity opacity-0 -start-6 not-prose group-hover:opacity-100 select-none"><a class="text-primary-300 dark:text-neutral-700 !no-underline" href=#fast aria-label=앵커>#</a></span></h4><p><figure><img class="my-0 rounded-md" loading=lazy decoding=async fetchpriority=low alt="Speed Mode: Fast" src=/en/posts/chama-optics-dev-story/speed_mode_fast.svg></figure></p><h4 class="relative group">Normal<div id=normal class=anchor></div><span class="absolute top-0 w-6 transition-opacity opacity-0 -start-6 not-prose group-hover:opacity-100 select-none"><a class="text-primary-300 dark:text-neutral-700 !no-underline" href=#normal aria-label=앵커>#</a></span></h4><p><figure><img class="my-0 rounded-md" loading=lazy decoding=async fetchpriority=low alt="Speed Mode: Normal" src=/en/posts/chama-optics-dev-story/speed_mode_normal.svg></figure></p><h4 class="relative group">Slow<div id=slow class=anchor></div><span class="absolute top-0 w-6 transition-opacity opacity-0 -start-6 not-prose group-hover:opacity-100 select-none"><a class="text-primary-300 dark:text-neutral-700 !no-underline" href=#slow aria-label=앵커>#</a></span></h4><p><figure><img class="my-0 rounded-md" loading=lazy decoding=async fetchpriority=low alt="Speed Mode: Slow" src=/en/posts/chama-optics-dev-story/speed_mode_slow.svg></figure></p><h4 class="relative group">Slowest<div id=slowest class=anchor></div><span class="absolute top-0 w-6 transition-opacity opacity-0 -start-6 not-prose group-hover:opacity-100 select-none"><a class="text-primary-300 dark:text-neutral-700 !no-underline" href=#slowest aria-label=앵커>#</a></span></h4><p><figure><img class="my-0 rounded-md" loading=lazy decoding=async fetchpriority=low alt="Speed Mode: Slowest" src=/en/posts/chama-optics-dev-story/speed_mode_slowest.svg></figure></p><p>아래는 Slowest 모드로 처리한 실제 행사 사진 예시다. 대규모 단체 사진에서 뒷줄 구석의 작은 얼굴까지 빠짐없이 검출하여 모자이크 처리한 결과물이다.</p><p><figure><img class="my-0 rounded-md" loading=lazy decoding=async fetchpriority=auto alt="Slowest 모드 적용 예시" width=4072 height=1644 src=/en/posts/chama-optics-dev-story/P1167220-OPTICS_hu_15c3e6f46edc9351.webp srcset="/en/posts/chama-optics-dev-story/P1167220-OPTICS_hu_15c3e6f46edc9351.webp 800w, /en/posts/chama-optics-dev-story/P1167220-OPTICS_hu_155c228295382ce9.webp 1280w" sizes="(min-width: 768px) 50vw, 65vw" data-zoom-src=/en/posts/chama-optics-dev-story/P1167220-OPTICS.webp></figure></p><blockquote><p>2025년 AGF 아마네 카나타 팬 단체 사진회</p></blockquote><p>각 모드의 사용 시나리오:</p><table><thead><tr><th style=text-align:left>모드</th><th style=text-align:left>평균 소요 시간</th><th style=text-align:left>적합한 상황</th></tr></thead><tbody><tr><td style=text-align:left>Fastest</td><td style=text-align:left>~0.5초</td><td style=text-align:left>1~2명 인물 사진</td></tr><tr><td style=text-align:left>Fast</td><td style=text-align:left>~0.6초</td><td style=text-align:left>파노라마 등 비정상 종횡비의 1~2명 사진</td></tr><tr><td style=text-align:left>Normal</td><td style=text-align:left>~7초</td><td style=text-align:left>약 10명 정도의 단체 사진</td></tr><tr><td style=text-align:left>Slow</td><td style=text-align:left>~13초</td><td style=text-align:left>40~50명 규모의 단체 사진</td></tr><tr><td style=text-align:left>Slowest</td><td style=text-align:left>~28초</td><td style=text-align:left>50명 이상의 대규모 단체 사진</td></tr></tbody></table><p>Fastest가 전체를 640×640 하나로 축소하여 ~0.5초만에 끝나는 반면, Slowest는 2560/1280/640 세 단계의 윈도우를 겹치며 탐색하기 때문에 ~28초가 걸린다. 하지만 행사장 단체 사진에서 뒷줄 구석의 작은 얼굴까지 잡아내려면 이 정도의 탐색이 필요하다.</p><p>실행 환경(Execution Provider)도 플랫폼별로 최적화되어 있다.</p><ul><li><strong>macOS/iOS</strong>: CoreML Execution Provider 자동 선택 — Apple의 Neural Engine/GPU 가속 활용</li><li><strong>Windows/Linux</strong>: CPU 또는 OnnxAuto (자동 감지)</li></ul><p>macOS에서는 사용자가 CPU를 선택하더라도 내부적으로 CoreML로 자동 전환되어 <strong>Apple Silicon의 Neural Engine을 활용</strong>한다. 이는 CPU 대비 수 배의 성능 향상을 가져온다.</p><p>한편 iOS와 Android에서는 이 ONNX 파이프라인 대신 각 플랫폼의 네이티브 얼굴 인식 API를 사용한다.</p><ul><li><strong>iOS</strong>: Apple Vision Framework — ONNX 모델 없이도 빠르고 정확</li><li><strong>Android</strong>: Google ML Kit (<code>com.google.mlkit:face-detection</code>) — FAST/ACCURATE 성능 모드를 Rust 코어의 speed_mode와 매핑 (Fastest/Fast → FAST 퍼포먼스, Slow 이상 → ACCURATE 퍼포먼스)</li></ul><h3 class="relative group">8. iOS 네이티브 통합<div id=8-ios-네이티브-통합 class=anchor></div><span class="absolute top-0 w-6 transition-opacity opacity-0 -start-6 not-prose group-hover:opacity-100 select-none"><a class="text-primary-300 dark:text-neutral-700 !no-underline" href=#8-ios-%eb%84%a4%ec%9d%b4%ed%8b%b0%eb%b8%8c-%ed%86%b5%ed%95%a9 aria-label=앵커>#</a></span></h3><p>iOS 앱은 단순히 Rust 코어를 감싸는 것이 아니라, 플랫폼의 장점을 최대한 활용했다.</p><ul><li><strong>Vision Framework</strong> — 얼굴 인식을 iOS 네이티브로 처리하여 ONNX 모델 없이도 빠르고 정확한 인식</li><li><strong>PhotosUI</strong> — iOS 사진 라이브러리에서 직접 이미지 선택</li><li><strong>Metal 렌더링</strong> — GPU 가속 이미지 처리</li><li><strong>iPad 지원</strong> — 넓은 화면에 최적화된 레이아웃</li></ul><h3 class="relative group">9. MPF 및 내장 프리뷰 이미지 추출<div id=9-mpf-및-내장-프리뷰-이미지-추출 class=anchor></div><span class="absolute top-0 w-6 transition-opacity opacity-0 -start-6 not-prose group-hover:opacity-100 select-none"><a class="text-primary-300 dark:text-neutral-700 !no-underline" href=#9-mpf-%eb%b0%8f-%eb%82%b4%ec%9e%a5-%ed%94%84%eb%a6%ac%eb%b7%b0-%ec%9d%b4%eb%af%b8%ec%a7%80-%ec%b6%94%ec%b6%9c aria-label=앵커>#</a></span></h3><p>JPEG 파일 안에 숨어 있는 서브 이미지를 추출하는 기능은 Chama Optics의 성능에 결정적인 역할을 한다. 이 기능은 <a href=https://github.com/kamadak/exif-rs/pull/58 target=_blank rel=noreferrer>exif-rs PR #58</a> (<a href=https://github.com/kamadak/exif-rs/pull/58 target=_blank rel=noreferrer>+1,364줄</a>, PR #57 기반)로 구현했다.</p><h4 class="relative group">JPEG 안에 숨어 있는 이미지들<div id=jpeg-안에-숨어-있는-이미지들 class=anchor></div><span class="absolute top-0 w-6 transition-opacity opacity-0 -start-6 not-prose group-hover:opacity-100 select-none"><a class="text-primary-300 dark:text-neutral-700 !no-underline" href=#jpeg-%ec%95%88%ec%97%90-%ec%88%a8%ec%96%b4-%ec%9e%88%eb%8a%94-%ec%9d%b4%eb%af%b8%ec%a7%80%eb%93%a4 aria-label=앵커>#</a></span></h4><p>JPEG 파일 하나 안에는 실제로 여러 개의 이미지가 들어 있을 수 있다.</p><p><figure><img class="my-0 rounded-md" loading=lazy decoding=async fetchpriority=low alt="JPEG 파일 구조와 MPF 서브 이미지" src=/en/posts/chama-optics-dev-story/jpeg_mpf_structure.svg></figure></p><p>JPEG 안에 내장된 이미지는 크게 세 가지 소스에서 추출할 수 있다.</p><ol><li><strong>EXIF IFD(1) 썸네일</strong> — 표준 EXIF 썸네일 (보통 160×120)</li><li><strong>APP2 세그먼트 (MPF)</strong> — <a href=https://www.cipa.jp/std/documents/download_e.html?DC-007-Translation-2021-E target=_blank rel=noreferrer>CIPA DC-007</a> 표준에 정의된 Multi-Picture Format. 메인 EOI 이후에 별도의 완전한 JPEG 스트림으로 저장된다.</li><li><strong>MakerNote 내부 프리뷰</strong> — 제조사별 비표준 프리뷰 이미지</li></ol><h4 class="relative group">왜 MPF 프리뷰가 중요한가: 메모리와 성능<div id=왜-mpf-프리뷰가-중요한가-메모리와-성능 class=anchor></div><span class="absolute top-0 w-6 transition-opacity opacity-0 -start-6 not-prose group-hover:opacity-100 select-none"><a class="text-primary-300 dark:text-neutral-700 !no-underline" href=#%ec%99%9c-mpf-%ed%94%84%eb%a6%ac%eb%b7%b0%ea%b0%80-%ec%a4%91%ec%9a%94%ed%95%9c%ea%b0%80-%eb%a9%94%eb%aa%a8%eb%a6%ac%ec%99%80-%ec%84%b1%eb%8a%a5 aria-label=앵커>#</a></span></h4><p>사진 목록에서 썸네일을 보여줄 때, 가장 단순한 방법은 <strong>원본 이미지를 로드한 뒤 리사이즈</strong>하는 것이다. 하지만 이건 끔찍하게 비효율적이다.</p><table><thead><tr><th style=text-align:left>방식</th><th style=text-align:left>메모리 사용</th><th style=text-align:left>처리 시간</th></tr></thead><tbody><tr><td style=text-align:left>원본(24MP) 로드 → 리사이즈</td><td style=text-align:left>~72MB (24M × 3bytes)</td><td style=text-align:left>느림</td></tr><tr><td style=text-align:left>IFD(1) 썸네일 사용</td><td style=text-align:left>~76KB (160×120)</td><td style=text-align:left>빠름, 하지만 너무 작아서 흐림</td></tr><tr><td style=text-align:left><strong>MPF 프리뷰(~2MP) 사용</strong></td><td style=text-align:left><strong>~8MB</strong></td><td style=text-align:left><strong>빠르고, 시각적으로 충분</strong></td></tr></tbody></table><p>IFD(1)의 썸네일은 너무 작아서 목록용으로는 괜찮지만 미리보기용으로는 흐릿하다. 원본을 로드하면 24MP 이미지가 메모리에 <del>72MB를 차지하고 디코딩 시간도 오래 걸린다. **MPF에 포함된 1</del>2MP 프리뷰 이미지**는 이 둘 사이의 달콤한 지점이다 — 시각적으로 충분히 선명하면서도 메모리와 CPU 오버헤드가 원본의 1/10 이하다.</p><p>특히 Chama Optics처럼 <strong>수십 장의 사진을 동시에 리스트로 보여주고, 테마 미리보기까지 제공</strong>해야 하는 프로그램에서는 이 차이가 결정적이다. 50장의 24MP 사진을 원본으로 로드하면 ~3.6GB, MPF 프리뷰로 로드하면 ~400MB — 약 9배의 차이다.</p><p>기존 exif-rs 사용자에게 영향을 주지 않기 위해 <code>mpf</code> feature flag로 제공하도록 하였다.</p><h3 class="relative group">10. HEIF/HEIC 디코더: 플랫폼별 전략<div id=10-heifheic-디코더-플랫폼별-전략 class=anchor></div><span class="absolute top-0 w-6 transition-opacity opacity-0 -start-6 not-prose group-hover:opacity-100 select-none"><a class="text-primary-300 dark:text-neutral-700 !no-underline" href=#10-heifheic-%eb%94%94%ec%bd%94%eb%8d%94-%ed%94%8c%eb%9e%ab%ed%8f%bc%eb%b3%84-%ec%a0%84%eb%9e%b5 aria-label=앵커>#</a></span></h3><p>최근 JPEG 외에 HEIF(High Efficiency Image Format)로 사진을 저장하는 기기가 늘고 있다. 특히 iOS는 촬영 시 HEIF를 기본으로 사용하며, 사진을 외부로 전달할 때 JPEG로 변환할지 HEIF 그대로 줄지를 OS가 자체적으로 판단한다 — 앱에서 이를 통제하기가 쉽지 않다. 일부 미러리스 카메라(Sony, Canon 등)도 HEIF 촬영을 지원하기 시작했다. 호환성 때문에 JPEG만 쓰는 사용자도 있지만, HEIF로 들어오는 파일을 처리하지 못하면 사진 앱으로서 치명적이다. 문제는 HEIF 디코딩 지원이 플랫폼마다 크게 다르다는 점이다.</p><p>Chama Optics는 <strong>가능한 한 OS 네이티브 디코더를 사용하고, 네이티브 지원이 없는 플랫폼에서만 libheif를 사용</strong>하는 전략을 택했다.</p><p><figure><img class="my-0 rounded-md" loading=lazy decoding=async fetchpriority=low alt="HEIF 디코더 전략" src=/en/posts/chama-optics-dev-story/heif_decoder_strategy.svg></figure></p><p><strong>iOS/macOS</strong> — Apple의 ImageIO 프레임워크가 HEIF를 네이티브로 지원한다. 별도의 외부 라이브러리 없이 OS API만으로 디코딩이 가능하다. iOS에서는 Swift 앱 레이어에서 디코딩한 픽셀 버퍼를 C FFI로 Rust에 전달하고, macOS에서는 Rust가 직접 macOS API 바인딩을 통해 호출한다.</p><p><strong>Android</strong> — API 26(Android 8.0) 이상에서 BitmapFactory와 MediaCodec이 HEIF를 네이티브로 지원한다. Kotlin 앱에서 디코딩한 뒤 JNA를 통해 Rust에 전달한다.</p><p><strong>Windows/Linux</strong> — 네이티브 HEIF 디코더가 없거나 제한적이다. 이 경우 <a href=https://crates.io/crates/libheif-rs target=_blank rel=noreferrer>libheif_rs</a>(libheif의 Rust 바인딩)를 사용한다. C FFI는 libheif_rs가 내부적으로 처리하므로 Rust 코드에서는 안전한 API만 호출하면 된다. libheif는 내부적으로 libde265(HEVC 디코더)와 libaom(AV1/AVIF)을 사용한다.</p><p>이 전략의 핵심은 <code>#[cfg(target_os)]</code> 조건부 컴파일이다. 네이티브 디코더가 있는 플랫폼에서는 외부 의존성 없이 최적의 성능을 얻고, libheif_rs가 필요한 플랫폼에서만 링킹한다. 결과적으로 macOS 빌드에서는 libheif 관련 코드가 아예 컴파일되지 않는다.</p><h3 class="relative group">11. 테마 파라미터 시스템: Rust → JSON → 플랫폼별 UI<div id=11-테마-파라미터-시스템-rust--json--플랫폼별-ui class=anchor></div><span class="absolute top-0 w-6 transition-opacity opacity-0 -start-6 not-prose group-hover:opacity-100 select-none"><a class="text-primary-300 dark:text-neutral-700 !no-underline" href=#11-%ed%85%8c%eb%a7%88-%ed%8c%8c%eb%9d%bc%eb%af%b8%ed%84%b0-%ec%8b%9c%ec%8a%a4%ed%85%9c-rust--json--%ed%94%8c%eb%9e%ab%ed%8f%bc%eb%b3%84-ui aria-label=앵커>#</a></span></h3><p>Chama Optics의 테마에는 40개 이상의 설정 파라미터가 있다 — 폰트 weight, 워터마크 위치·투명도, 프레임 스타일, 로고 표시 여부, 색상, 여백 등. 이 파라미터들이 데스크탑과 모바일에서 <strong>동일한 결과</strong>를 보장해야 한다는 것이 핵심 요구사항이었다.</p><p><figure><img class="my-0 rounded-md" loading=lazy decoding=async fetchpriority=low alt="테마 파라미터 시스템" src=/en/posts/chama-optics-dev-story/theme_param_json.svg></figure></p><p>데스크탑(egui)에서는 Rust 구조체를 <strong>직접 참조</strong>하여 UI 위젯을 그린다. <code>Slider::new(&amp;mut config.font_weight, 100..=900)</code> 같은 코드로 구조체 필드가 곧 UI 상태가 된다 — JSON 직렬화도, 중간 변환도 없다.</p><p>문제는 모바일이다. iOS(SwiftUI)와 Android(Jetpack Compose)는 Rust 구조체에 직접 접근할 수 없다. 40개 이상의 파라미터 각각에 대해 Swift/Kotlin 쪽에서 수동으로 UI를 만들고, FFI로 값을 주고받는 코드를 일일이 작성한다면? 파라미터가 하나 추가될 때마다 Rust, Swift, Kotlin 세 곳을 동시에 수정해야 한다.</p><p>이 문제를 <code>proc_macro</code>로 해결했다. Rust 구조체 정의에 <code>#[derive(ThemeParam)]</code>을 붙이면, 컴파일 타임에 다음이 자동 생성된다.</p><ul><li><strong>JSON 스키마</strong>: 각 필드의 UI 타입(슬라이더, 토글, enum 선택, 색상 피커 등), 범위, 기본값을 포함하는 JSON</li><li><strong>FFI 함수</strong>: <code>get_param_json()</code>, <code>set_param()</code> 등 모바일에서 호출할 수 있는 C ABI 함수</li><li><strong>역직렬화 로직</strong>: JSON으로 받은 값을 Rust 구조체에 반영하는 코드</li></ul><p>모바일 앱은 이 JSON을 파싱하여 <strong>네이티브 UI 요소를 동적으로 생성</strong>한다. <code>"type": "slider"</code> → SwiftUI의 <code>Slider</code>, Jetpack Compose의 <code>Slider()</code>. <code>"type": "toggle"</code> → <code>Toggle</code> / <code>Switch</code>. 사용자가 값을 변경하면 FFI를 통해 Rust 코어에 전달되고, Rust 코어는 동일한 렌더링 파이프라인으로 결과를 반환한다.</p><p>결과적으로 Rust 구조체 하나가 <strong>UI 명세이자 데이터 모델이자 직렬화 포맷</strong>의 역할을 동시에 한다. 새 파라미터를 추가할 때 Rust에 필드 하나를 추가하고 어트리뷰트로 UI 힌트를 달면, proc_macro가 JSON 스키마를 갱신하고, 모바일 앱은 다음 빌드에서 자동으로 해당 UI를 표시한다. Swift/Kotlin 코드를 수정할 필요가 없다.</p><p>임베디드에서의 <code>build.rs</code> 남발과 <code>const fn</code> 집착이 이런 식으로 응용되었다. 솔직히 proc_macro로 하는 것이 깔끔한지는 모르겠다 — 본인도 &ldquo;괴랄하다"고 생각하는 부분이다. 하지만 <strong>40개 이상의 파라미터를 3개 플랫폼에서 수동 동기화하는 것보다는 확실히 낫다.</strong> Rust의 절차형 매크로(procedural macro)에 대해 더 알고 싶다면 <a href=https://priver.dev/blog/rust/procedural-macros/ target=_blank rel=noreferrer>이 글</a>이 좋은 참고가 된다.</p><h3 class="relative group">12. 다국어 번역 시스템: YAML 하나로 3개 플랫폼 번역 자동 생성<div id=12-다국어-번역-시스템-yaml-하나로-3개-플랫폼-번역-자동-생성 class=anchor></div><span class="absolute top-0 w-6 transition-opacity opacity-0 -start-6 not-prose group-hover:opacity-100 select-none"><a class="text-primary-300 dark:text-neutral-700 !no-underline" href=#12-%eb%8b%a4%ea%b5%ad%ec%96%b4-%eb%b2%88%ec%97%ad-%ec%8b%9c%ec%8a%a4%ed%85%9c-yaml-%ed%95%98%eb%82%98%eb%a1%9c-3%ea%b0%9c-%ed%94%8c%eb%9e%ab%ed%8f%bc-%eb%b2%88%ec%97%ad-%ec%9e%90%eb%8f%99-%ec%83%9d%ec%84%b1 aria-label=앵커>#</a></span></h3><p>4개 언어(영어, 한국어, 일본어, 인도네시아어)를 지원하면서 <strong>번역 문자열이 3개 플랫폼에서 동기화되어야 한다.</strong> 번역 키 하나를 추가하거나 문구를 수정할 때마다 iOS의 <code>.strings</code>, Android의 <code>strings.xml</code>, 데스크탑의 Rust 코드를 각각 손으로 고쳐야 한다면? 결국 빠뜨리거나 어긋나게 된다.</p><p>해결 방식은 단순하다. <strong>rust-core의 YAML 파일을 유일한 원본으로 두고, 빌드 시점에 각 플랫폼 포맷으로 자동 변환</strong>하는 것이다.</p><p><figure><img class="my-0 rounded-md" loading=lazy decoding=async fetchpriority=low alt="i18n 빌드 파이프라인" src=/en/posts/chama-optics-dev-story/i18n_build_pipeline.svg></figure></p><h4 class="relative group">YAML: 번역의 원본<div id=yaml-번역의-원본 class=anchor></div><span class="absolute top-0 w-6 transition-opacity opacity-0 -start-6 not-prose group-hover:opacity-100 select-none"><a class="text-primary-300 dark:text-neutral-700 !no-underline" href=#yaml-%eb%b2%88%ec%97%ad%ec%9d%98-%ec%9b%90%eb%b3%b8 aria-label=앵커>#</a></span></h4><p><code>rust-core/locales/</code> 디렉토리에 23개의 YAML 파일이 있다. <code>common.yml</code>, <code>gallery.yml</code>, <code>theme.yml</code>, <code>face_detection.yml</code> 등 기능 단위로 분리되어 있으며, 총 약 3,900줄이다.</p><div class=highlight-wrapper><div class=highlight><pre tabindex=0 class=chroma><code class=language-yaml data-lang=yaml><span class=line><span class=cl><span class=c># rust-core/locales/gallery.yml</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=nt>gallery</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=nt>empty_state_title</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=nt>en</span><span class=p>:</span><span class=w> </span><span class=s2>&#34;No Images Yet&#34;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=nt>ko</span><span class=p>:</span><span class=w> </span><span class=s2>&#34;이미지 없음&#34;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=nt>ja</span><span class=p>:</span><span class=w> </span><span class=s2>&#34;画像がありません&#34;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=nt>id</span><span class=p>:</span><span class=w> </span><span class=s2>&#34;Belum Ada Gambar&#34;</span></span></span></code></pre></div></div><p>이 구조는 <code>rust_i18n</code> 크레이트가 요구하는 형식 그대로다. 데스크탑에서는 <code>rust_i18n::i18n!("locales")</code>로 컴파일 타임에 YAML을 임베딩하고, <code>t!("gallery.empty_state_title")</code>로 호출한다. 별도의 변환이 필요 없다. <code>build.rs</code>에서 <code>cargo:rerun-if-changed=locales</code>를 선언해두었으므로, YAML이 수정되면 자동으로 재컴파일된다.</p><p>문제는 iOS와 Android다.</p><h4 class="relative group">iOS: generate_ios_strings.sh<div id=ios-generate_ios_stringssh class=anchor></div><span class="absolute top-0 w-6 transition-opacity opacity-0 -start-6 not-prose group-hover:opacity-100 select-none"><a class="text-primary-300 dark:text-neutral-700 !no-underline" href=#ios-generate_ios_stringssh aria-label=앵커>#</a></span></h4><p>iOS는 <code>NSLocalizedString</code>과 <code>.strings</code> 파일을 사용한다. <code>generate_ios_strings.sh</code>는 Python3 + PyYAML로 YAML을 파싱하여, 각 로케일별 <code>Localizable.strings</code>를 생성한다.</p><div class=highlight-wrapper><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl><span class=c1># build_ios.sh 에서 자동 호출</span>
</span></span><span class=line><span class=cl>./generate_ios_strings.sh</span></span></code></pre></div></div><p>YAML의 계층 구조를 점(<code>.</code>) 표기법으로 평탄화하여 <code>.strings</code> 포맷으로 변환한다.</p><div class=highlight-wrapper><div class=highlight><pre tabindex=0 class=chroma><code class=language-text data-lang=text><span class=line><span class=cl>/* Auto-generated from rust-core/locales - DO NOT EDIT */
</span></span><span class=line><span class=cl>&#34;gallery.empty_state_title&#34; = &#34;이미지 없음&#34;;
</span></span><span class=line><span class=cl>&#34;common.actions.save&#34; = &#34;저장&#34;;</span></span></code></pre></div></div><p>iOS 고유의 요구사항도 있었다. 같은 키라도 iOS에서는 다른 문구를 사용해야 하는 경우가 있다 — 예를 들어 데스크탑에서 &ldquo;파일 불러오기"라고 쓰는 곳을 iOS에서는 &ldquo;사진 선택"이라고 써야 자연스럽다. 이를 위해 <strong><code>_ios</code> 접미어 오버라이드</strong>를 구현했다. YAML에서 <code>import.label_ios</code>가 정의되어 있으면 iOS 빌드에서는 <code>import.label</code> 대신 이 값을 사용한다. 데스크탑과 Android에는 영향을 주지 않는다.</p><p>이 스크립트는 <code>build_ios.sh</code>에서 Rust 크로스 컴파일 전에 자동으로 호출되므로, YAML을 수정하고 Xcode 빌드를 돌리면 번역이 자동 반영된다.</p><h4 class="relative group">Android: generate_android_strings.sh<div id=android-generate_android_stringssh class=anchor></div><span class="absolute top-0 w-6 transition-opacity opacity-0 -start-6 not-prose group-hover:opacity-100 select-none"><a class="text-primary-300 dark:text-neutral-700 !no-underline" href=#android-generate_android_stringssh aria-label=앵커>#</a></span></h4><p>Android는 <code>strings.xml</code>과 <code>R.string.*</code> 리소스 시스템을 사용한다. 핵심적인 차이가 두 가지 있다.</p><p><strong>첫째, 키 포맷이 다르다.</strong> Android 리소스 이름에는 점(<code>.</code>)을 사용할 수 없다. YAML의 <code>gallery.empty_state_title</code>을 Android에서는 <code>gallery_empty_state_title</code>로 변환해야 한다.</p><div class=highlight-wrapper><div class=highlight><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=k>def</span> <span class=nf>yml_key_to_android_key</span><span class=p>(</span><span class=n>yml_key</span><span class=p>):</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>yml_key</span><span class=o>.</span><span class=n>replace</span><span class=p>(</span><span class=s1>&#39;.&#39;</span><span class=p>,</span> <span class=s1>&#39;_&#39;</span><span class=p>)</span></span></span></code></pre></div></div><p><strong>둘째, 로케일 디렉토리 규칙이 다르다.</strong> Android는 인도네시아어를 <code>id</code>가 아닌 <code>in</code>으로 표기한다 — <code>values-in/strings.xml</code>. 이 매핑을 스크립트에서 처리한다.</p><div class=highlight-wrapper><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>ANDROID_LOCALE_MAP<span class=o>[</span><span class=s2>&#34;en&#34;</span><span class=o>]=</span><span class=s2>&#34;values&#34;</span>
</span></span><span class=line><span class=cl>ANDROID_LOCALE_MAP<span class=o>[</span><span class=s2>&#34;ko&#34;</span><span class=o>]=</span><span class=s2>&#34;values-ko&#34;</span>
</span></span><span class=line><span class=cl>ANDROID_LOCALE_MAP<span class=o>[</span><span class=s2>&#34;ja&#34;</span><span class=o>]=</span><span class=s2>&#34;values-ja&#34;</span>
</span></span><span class=line><span class=cl>ANDROID_LOCALE_MAP<span class=o>[</span><span class=s2>&#34;id&#34;</span><span class=o>]=</span><span class=s2>&#34;values-in&#34;</span>    <span class=c1># Android uses &#34;in&#34; for Indonesian</span></span></span></code></pre></div></div><p>iOS 스크립트와 또 다른 점은 <strong>diff 기반 동기화</strong>라는 것이다. iOS는 매번 파일을 통째로 덮어쓰지만, Android 스크립트는 기존 <code>strings.xml</code>에 이미 있는 키는 건드리지 않고 <strong>누락된 키만 추가</strong>한다. Android 쪽에서 수동으로 관리하는 엔트리(앱 이름 등)를 보존하기 위해서다. <code>--check</code> 모드로 실행하면 파일을 수정하지 않고 누락된 번역만 보고한다.</p><p>Android에서 이 키들을 실제로 사용할 때는 <code>ThemeI18n.kt</code>에서 YAML 점 표기법 키를 <code>R.string.*</code> 리소스 ID로 매핑한다.</p><div class=highlight-wrapper><div class=highlight><pre tabindex=0 class=chroma><code class=language-kotlin data-lang=kotlin><span class=line><span class=cl><span class=k>object</span> <span class=nc>ThemeI18n</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>fun</span> <span class=nf>translate</span><span class=p>(</span><span class=n>context</span><span class=p>:</span> <span class=n>Context</span><span class=p>,</span> <span class=n>key</span><span class=p>:</span> <span class=n>String</span><span class=p>):</span> <span class=n>String</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=k>val</span> <span class=py>resourceId</span> <span class=p>=</span> <span class=n>keyToResourceId</span><span class=p>(</span><span class=n>key</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=k>if</span> <span class=p>(</span><span class=n>resourceId</span> <span class=o>!=</span> <span class=mi>0</span><span class=p>)</span> <span class=n>context</span><span class=p>.</span><span class=n>getString</span><span class=p>(</span><span class=n>resourceId</span><span class=p>)</span> <span class=k>else</span> <span class=n>key</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span></span></span></code></pre></div></div><h4 class="relative group">세 플랫폼의 키 변환 비교<div id=세-플랫폼의-키-변환-비교 class=anchor></div><span class="absolute top-0 w-6 transition-opacity opacity-0 -start-6 not-prose group-hover:opacity-100 select-none"><a class="text-primary-300 dark:text-neutral-700 !no-underline" href=#%ec%84%b8-%ed%94%8c%eb%9e%ab%ed%8f%bc%ec%9d%98-%ed%82%a4-%eb%b3%80%ed%99%98-%eb%b9%84%ea%b5%90 aria-label=앵커>#</a></span></h4><table><thead><tr><th style=text-align:left>요소</th><th style=text-align:left>Desktop (Rust)</th><th style=text-align:left>iOS (Swift)</th><th style=text-align:left>Android (Kotlin)</th></tr></thead><tbody><tr><td style=text-align:left><strong>원본</strong></td><td style=text-align:left><code>t!("gallery.empty_state_title")</code></td><td style=text-align:left><code>NSLocalizedString("gallery.empty_state_title")</code></td><td style=text-align:left><code>R.string.gallery_empty_state_title</code></td></tr><tr><td style=text-align:left><strong>키 구분자</strong></td><td style=text-align:left><code>.</code> (점)</td><td style=text-align:left><code>.</code> (점)</td><td style=text-align:left><code>_</code> (밑줄)</td></tr><tr><td style=text-align:left><strong>생성 방식</strong></td><td style=text-align:left>컴파일 타임 임베딩</td><td style=text-align:left>빌드 스크립트 자동 생성</td><td style=text-align:left>빌드 스크립트 diff 동기화</td></tr><tr><td style=text-align:left><strong>플랫폼 오버라이드</strong></td><td style=text-align:left>—</td><td style=text-align:left><code>_ios</code> 접미어</td><td style=text-align:left>—</td></tr><tr><td style=text-align:left><strong>인도네시아어 코드</strong></td><td style=text-align:left><code>id</code></td><td style=text-align:left><code>id</code></td><td style=text-align:left><code>in</code></td></tr></tbody></table><p>이 구조 덕분에 번역을 추가하거나 수정할 때 <strong>YAML 파일 하나만 고치면</strong> 세 플랫폼 모두에 반영된다. 23개 YAML 파일, 4개 언어, 3개 플랫폼을 수동으로 동기화하는 것은 현실적으로 불가능하다 — 내가 생각한 방법은 자동화뿐이었다.</p><hr><h2 class="relative group">오픈소스 기여 활동<div id=오픈소스-기여-활동 class=anchor></div><span class="absolute top-0 w-6 transition-opacity opacity-0 -start-6 not-prose group-hover:opacity-100 select-none"><a class="text-primary-300 dark:text-neutral-700 !no-underline" href=#%ec%98%a4%ed%94%88%ec%86%8c%ec%8a%a4-%ea%b8%b0%ec%97%ac-%ed%99%9c%eb%8f%99 aria-label=앵커>#</a></span></h2><p>Chama Optics 개발 과정에서 의존하는 오픈소스 프로젝트들에도 적극적으로 기여했다.</p><table><thead><tr><th style=text-align:left>프로젝트</th><th style=text-align:left>기여 내용</th></tr></thead><tbody><tr><td style=text-align:left><a href=https://github.com/kamadak/exif-rs target=_blank rel=noreferrer>exif-rs</a></td><td style=text-align:left>MakerNote 파싱 — 10개 제조사 지원 (<a href=https://github.com/kamadak/exif-rs/pull/57 target=_blank rel=noreferrer>PR #57</a>, +5,946 lines)</td></tr><tr><td style=text-align:left><a href=https://github.com/kamadak/exif-rs target=_blank rel=noreferrer>exif-rs</a></td><td style=text-align:left>MPF 및 내장 프리뷰 이미지 추출 (<a href=https://github.com/kamadak/exif-rs/pull/58 target=_blank rel=noreferrer>PR #58</a>, +1,364 lines)</td></tr><tr><td style=text-align:left><a href=https://github.com/kamadak/exif-rs target=_blank rel=noreferrer>exif-rs</a></td><td style=text-align:left>TIFF field 접근 개선 (<a href=https://github.com/kamadak/exif-rs/pull/51 target=_blank rel=noreferrer>PR #51</a>, approved)</td></tr><tr><td style=text-align:left><a href=https://github.com/servo/font-kit target=_blank rel=noreferrer>font-kit</a></td><td style=text-align:left>macOS 시스템 폰트 열거 시 메모리 폭주 수정 (<a href=https://github.com/servo/font-kit/pull/271 target=_blank rel=noreferrer>PR #271</a>)</td></tr><tr><td style=text-align:left><a href=https://github.com/emilk/egui target=_blank rel=noreferrer>egui</a></td><td style=text-align:left>variable font 로드 시 main weight 설정 기능 개선 (<a href=https://github.com/emilk/egui/pull/7790 target=_blank rel=noreferrer>PR #7790</a>, approved)</td></tr><tr><td style=text-align:left><a href=https://github.com/pmnxis/wagahai-lut target=_blank rel=noreferrer>wagahai-lut</a></td><td style=text-align:left>1D/3D LUT 컬러 그레이딩 라이브러리 (<a href=https://crates.io/crates/wagahai-lut target=_blank rel=noreferrer>crates.io</a>)</td></tr></tbody></table><hr><h2 class="relative group">릴리즈 요약<div id=릴리즈-요약 class=anchor></div><span class="absolute top-0 w-6 transition-opacity opacity-0 -start-6 not-prose group-hover:opacity-100 select-none"><a class="text-primary-300 dark:text-neutral-700 !no-underline" href=#%eb%a6%b4%eb%a6%ac%ec%a6%88-%ec%9a%94%ec%95%bd aria-label=앵커>#</a></span></h2><table><thead><tr><th style=text-align:left>버전</th><th style=text-align:left>날짜</th><th style=text-align:left>주요 변경사항</th></tr></thead><tbody><tr><td style=text-align:left>v0.1.0</td><td style=text-align:left>2025-10-19</td><td style=text-align:left>첫 프리릴리즈, macOS/Windows, Film 테마</td></tr><tr><td style=text-align:left>v0.1.1</td><td style=text-align:left>2025-10-19</td><td style=text-align:left>일본어 번역, 일괄 저장, 접두어/접미어</td></tr><tr><td style=text-align:left>v0.1.2</td><td style=text-align:left>2025-10-27</td><td style=text-align:left>Glow 효과, Film Date/Glow 테마</td></tr><tr><td style=text-align:left>v0.1.3</td><td style=text-align:left>2025-11-03</td><td style=text-align:left>워터마크(9곳 위치), 폰트 선택</td></tr><tr><td style=text-align:left>v0.1.4~5</td><td style=text-align:left>2025-11-05~12</td><td style=text-align:left>Just Frame, Strap 테마, 카메라 로고</td></tr><tr><td style=text-align:left>v0.1.6</td><td style=text-align:left>2025-11-24</td><td style=text-align:left>Monitor, Lightroom 테마, Longside 스케일</td></tr><tr><td style=text-align:left>v0.1.7</td><td style=text-align:left>2025-12-19</td><td style=text-align:left>One/Two Line, Shot On 테마, CJK 수정, PhotoStyle</td></tr><tr><td style=text-align:left>v0.1.8</td><td style=text-align:left>2025-12-27</td><td style=text-align:left>탭 UI, 그룹화, 테마 미리보기, 멀티코어</td></tr><tr><td style=text-align:left>v0.1.9</td><td style=text-align:left>2026-02-04</td><td style=text-align:left>얼굴 인식, LUT 컬러 그레이딩, <strong>iOS TestFlight 첫 배포</strong></td></tr></tbody></table><hr><h2 class="relative group">AI와 함께하는 프로그래밍 (바이브 코딩?)<div id=ai와-함께하는-프로그래밍-바이브-코딩 class=anchor></div><span class="absolute top-0 w-6 transition-opacity opacity-0 -start-6 not-prose group-hover:opacity-100 select-none"><a class="text-primary-300 dark:text-neutral-700 !no-underline" href=#ai%ec%99%80-%ed%95%a8%ea%bb%98%ed%95%98%eb%8a%94-%ed%94%84%eb%a1%9c%ea%b7%b8%eb%9e%98%eb%b0%8d-%eb%b0%94%ec%9d%b4%eb%b8%8c-%ec%bd%94%eb%94%a9 aria-label=앵커>#</a></span></h2><p>처음에는 AI 코딩에 대해서 회의적이었다.</p><p>그래서 데스크탑 버전의 대다수는 아직도 내 손코딩 + <code>cargo fmt/clippy/check</code>에 의존하고 있다. Rust Embedded에서의 습관인 <code>const</code> 남발을 데스크탑에서도 적용하려는 내 의도를 AI(Claude)는 여전히 제대로 파악하지 못하고 있다.</p><p>하지만 모바일용을 개발하면서 <strong>혼자서 이걸 다 하는 건 미친 짓</strong>이라고 생각했다. 기존 데스크탑 버전과 동일한 결과를 모바일에서 제공하는 것이 우선 사항이었고, 네이티브 API와 Rust FFI를 직접 호출하는 형태가 많을 것으로 예상되었다.</p><p>그러던 참에 친구 결혼식 청첩장 모임을 가면서, 같이 차를 타고 있던 친구가 &ldquo;<strong>Flutter에서 iOS 26에서 현재 Liquid UI가 제대로 안 돼</strong>&ldquo;라는 말을 했다. 개발하더라도 네이티브로만 개발해야겠다는 생각이 굳어졌고, 동시에 AI에게 모바일용 코드를 맡기기로 결정했다.</p><p>결과적으로 <strong>Rust 코어는 내가 직접</strong>, <strong>모바일 UI(SwiftUI/Jetpack Compose)와 FFI 브리지는 AI와 함께</strong> 작성하는 분업 체제가 만들어졌다. Rust 쪽은 내가 의도한 패턴과 스타일이 있어서 AI가 잘 맞추지 못하지만, Swift/Kotlin처럼 내가 잘 모르는 언어로 플랫폼 네이티브 코드를 작성하는 데에는 AI가 큰 도움이 되었다.</p><p>이 경험을 하고 나니, Flutter 같은 크로스플랫폼 프레임워크의 위치에 대해 생각하게 되었다. 물론 Flutter나 React Native가 해결하는 문제 — 하나의 코드베이스로 여러 플랫폼을 커버하는 것 — 는 여전히 유효하다. 하지만 AI가 각 플랫폼의 네이티브 코드를 충분히 잘 작성해줄 수 있는 시대가 되면, &ldquo;네이티브를 몰라서 크로스플랫폼을 선택한다"는 동기는 점점 약해질 수 있다. 모바일 개발을 전혀 몰랐던 내가 AI의 도움만으로 SwiftUI와 Jetpack Compose를 각각 네이티브로 작성할 수 있었다는 사실이, 그 가능성을 보여주는 하나의 사례가 아닐까 싶다.</p><hr><h2 class="relative group">앞으로의 계획<div id=앞으로의-계획 class=anchor></div><span class="absolute top-0 w-6 transition-opacity opacity-0 -start-6 not-prose group-hover:opacity-100 select-none"><a class="text-primary-300 dark:text-neutral-700 !no-underline" href=#%ec%95%9e%ec%9c%bc%eb%a1%9c%ec%9d%98-%ea%b3%84%ed%9a%8d aria-label=앵커>#</a></span></h2><p>v0.1.9를 기점으로 데스크탑 단독 릴리즈는 종료하고, v0.2.0부터는 iOS, Android 모바일 앱과 함께 릴리즈할 예정이다. 추가적인 기능보다는 간간이 안정화와 테마 추가에 집중할 생각이다.</p><p>당장의 목표는 <strong>2026년 3월 홀로라이브 엑스포/페스티벌</strong>에서 실전 투입하는 것이다. 행사장에서 미러리스로 사진을 찍고, iPhone에서 바로 프레임을 입히고, 얼굴을 자동으로 모자이크 처리해서 SNS에 올리는 — 카메라 사용자든 일반 스마트폰 사용자든, 각자의 환경에서 편하게 쓸 수 있는 워크플로우를 제공하는 것이 방향이다.</p><p>사이드 프로젝트로서 Chama Optics는 &ldquo;사진을 찍는 사람이 사진을 더 잘 보여줄 수 있게 돕는 도구"를 목표로, 좀 더 편한 워크플로우를 제공해 나갈 것이다. 그리고 이번 개발에서 쌓은 절차형 매크로와 최적화 경험을 바탕으로, 다시 Rust Embedded 쪽에도 좀 더 신경 써볼 예정이다.</p><hr><h2 class="relative group">참고 문헌 및 인용<div id=참고-문헌-및-인용 class=anchor></div><span class="absolute top-0 w-6 transition-opacity opacity-0 -start-6 not-prose group-hover:opacity-100 select-none"><a class="text-primary-300 dark:text-neutral-700 !no-underline" href=#%ec%b0%b8%ea%b3%a0-%eb%ac%b8%ed%97%8c-%eb%b0%8f-%ec%9d%b8%ec%9a%a9 aria-label=앵커>#</a></span></h2><h4 class="relative group">표준 문서<div id=표준-문서 class=anchor></div><span class="absolute top-0 w-6 transition-opacity opacity-0 -start-6 not-prose group-hover:opacity-100 select-none"><a class="text-primary-300 dark:text-neutral-700 !no-underline" href=#%ed%91%9c%ec%a4%80-%eb%ac%b8%ec%84%9c aria-label=앵커>#</a></span></h4><ul><li>CIPA DC-008 — <a href=https://www.cipa.jp/std/documents/download_e.html?DC-008-Translation-2023-E target=_blank rel=noreferrer>Exchangeable image file format (Exif) Version 3.0</a></li><li>CIPA DC-007 — <a href=https://www.cipa.jp/std/documents/download_e.html?DC-007-Translation-2021-E target=_blank rel=noreferrer>Multi-Picture Format (MPF)</a></li><li>Adobe — <a href=https://web.archive.org/web/20220220033515/https://wwwimages2.adobe.com/content/dam/acom/en/products/speedgrade/cc/pdfs/cube-lut-specification-1.0.pdf target=_blank rel=noreferrer>Adobe Cube LUT Spec 1.0</a></li></ul><h4 class="relative group">라이브러리 및 프레임워크<div id=라이브러리-및-프레임워크 class=anchor></div><span class="absolute top-0 w-6 transition-opacity opacity-0 -start-6 not-prose group-hover:opacity-100 select-none"><a class="text-primary-300 dark:text-neutral-700 !no-underline" href=#%eb%9d%bc%ec%9d%b4%eb%b8%8c%eb%9f%ac%eb%a6%ac-%eb%b0%8f-%ed%94%84%eb%a0%88%ec%9e%84%ec%9b%8c%ed%81%ac aria-label=앵커>#</a></span></h4><ul><li><a href=https://github.com/kamadak/exif-rs target=_blank rel=noreferrer>exif-rs</a> — Rust EXIF 파싱 라이브러리</li><li><a href=https://github.com/emilk/egui target=_blank rel=noreferrer>egui</a> — Rust 즉시 모드 GUI 프레임워크</li><li><a href=https://github.com/servo/font-kit target=_blank rel=noreferrer>font-kit</a> — 크로스플랫폼 폰트 로딩 라이브러리</li><li><a href=https://github.com/pmnxis/wagahai-lut target=_blank rel=noreferrer>wagahai-lut</a> (<a href=https://crates.io/crates/wagahai-lut target=_blank rel=noreferrer>crates.io</a>) — 1D/3D LUT 컬러 그레이딩 라이브러리</li><li><a href=https://crates.io/crates/libheif-rs target=_blank rel=noreferrer>libheif-rs</a> — libheif Rust 바인딩</li><li><a href=https://crates.io/crates/wide target=_blank rel=noreferrer>wide</a> — 크로스플랫폼 SIMD 벡터 크레이트</li><li><a href=https://onnxruntime.ai/ target=_blank rel=noreferrer>ONNX Runtime</a> — 크로스플랫폼 ML 추론 엔진</li><li><a href=https://github.com/deepinsight/insightface/tree/master/detection/scrfd target=_blank rel=noreferrer>InsightFace SCRFD</a> — 얼굴 감지 모델 (det_10g)</li><li><a href=https://github.com/jeonghyeon-net/exif-frame target=_blank rel=noreferrer>exif-frame</a> — EXIF 프레임 웹 도구 (Chama Optics의 초기 참고)</li></ul><h4 class="relative group">참고 자료<div id=참고-자료 class=anchor></div><span class="absolute top-0 w-6 transition-opacity opacity-0 -start-6 not-prose group-hover:opacity-100 select-none"><a class="text-primary-300 dark:text-neutral-700 !no-underline" href=#%ec%b0%b8%ea%b3%a0-%ec%9e%90%eb%a3%8c aria-label=앵커>#</a></span></h4><ul><li><a href=https://priver.dev/blog/rust/procedural-macros/ target=_blank rel=noreferrer>Rust Procedural Macros</a> — 절차형 매크로 참고</li><li><a href=https://exiftool.org/TagNames/ target=_blank rel=noreferrer>ExifTool TagNames</a> — 제조사별 MakerNote 태그 참고</li><li><a href=https://exiv2.org/makernote.html target=_blank rel=noreferrer>Exiv2 MakerNote Documentation</a> — MakerNote 구조 및 제조사별 포맷 참고</li></ul><hr><h2 class="relative group">Special Thanks<div id=special-thanks class=anchor></div><span class="absolute top-0 w-6 transition-opacity opacity-0 -start-6 not-prose group-hover:opacity-100 select-none"><a class="text-primary-300 dark:text-neutral-700 !no-underline" href=#special-thanks aria-label=앵커>#</a></span></h2><ul><li><a href=https://github.com/SkuldNorniern target=_blank rel=noreferrer>SkuldNorniern</a> — 디버깅 및 얼굴 인식 관련 도움</li><li><a href=https://github.com/miniex target=_blank rel=noreferrer>miniex</a> — 폰트 시스템 디버깅 및 얼굴 인식 관련 도움</li><li><a href=https://github.com/jcm7612 target=_blank rel=noreferrer>jcm7612</a> — 디버깅 및 피드백</li><li><a href=https://x.com/shiemika324 target=_blank rel=noreferrer>shiemika324</a> — 일러스트 및 아이콘 일러스트 제공</li></ul></div><section class="flex flex-row flex-wrap justify-center pt-4 text-xl"><a target=_blank class="m-1 rounded bg-neutral-300 p-1.5 text-neutral-700 hover:bg-primary-500 hover:text-neutral dark:bg-neutral-700 dark:text-neutral-300 dark:hover:bg-primary-400 dark:hover:text-neutral-800" href="https://www.linkedin.com/shareArticle?mini=true&amp;url=https://pmnxis.github.io/ko/posts/chama-optics-dev-story/&amp;title=Chama%20Optics%20%ea%b0%9c%eb%b0%9c%ea%b8%b0" title="LinkedIn에서 공유" aria-label="LinkedIn에서 공유"><span class="relative block icon"><svg viewBox="0 0 448 512"><path fill="currentColor" d="M416 32H31.9C14.3 32 0 46.5.0 64.3v383.4C0 465.5 14.3 480 31.9 480H416c17.6.0 32-14.5 32-32.3V64.3c0-17.8-14.4-32.3-32-32.3zM135.4 416H69V202.2h66.5V416zm-33.2-243c-21.3.0-38.5-17.3-38.5-38.5S80.9 96 102.2 96c21.2.0 38.5 17.3 38.5 38.5.0 21.3-17.2 38.5-38.5 38.5zm282.1 243h-66.4V312c0-24.8-.5-56.7-34.5-56.7-34.6.0-39.9 27-39.9 54.9V416h-66.4V202.2h63.7v29.2h.9c8.9-16.8 30.6-34.5 62.9-34.5 67.2.0 79.7 44.3 79.7 101.9V416z"/></svg>
</span></a><a target=_blank class="m-1 rounded bg-neutral-300 p-1.5 text-neutral-700 hover:bg-primary-500 hover:text-neutral dark:bg-neutral-700 dark:text-neutral-300 dark:hover:bg-primary-400 dark:hover:text-neutral-800" href="https://twitter.com/intent/tweet/?url=https://pmnxis.github.io/ko/posts/chama-optics-dev-story/&amp;text=Chama%20Optics%20%ea%b0%9c%eb%b0%9c%ea%b8%b0" title="Twitter에 트윗" aria-label="Twitter에 트윗"><span class="relative block icon"><svg viewBox="0 0 512 512"><path fill="currentColor" d="M389.2 48h70.6L305.6 224.2 487 464H345L233.7 318.6 106.5 464H35.8L200.7 275.5 26.8 48H172.4L272.9 180.9 389.2 48zM364.4 421.8h39.1L151.1 88h-42L364.4 421.8z"/></svg></span>
</a><a target=_blank class="m-1 rounded bg-neutral-300 p-1.5 text-neutral-700 hover:bg-primary-500 hover:text-neutral dark:bg-neutral-700 dark:text-neutral-300 dark:hover:bg-primary-400 dark:hover:text-neutral-800" href="https://reddit.com/submit/?url=https://pmnxis.github.io/ko/posts/chama-optics-dev-story/&amp;resubmit=true&amp;title=Chama%20Optics%20%ea%b0%9c%eb%b0%9c%ea%b8%b0" title="Reddit에 게시" aria-label="Reddit에 게시"><span class="relative block icon"><svg viewBox="0 0 512 512"><path fill="currentColor" d="M201.5 305.5c-13.8.0-24.9-11.1-24.9-24.6.0-13.8 11.1-24.9 24.9-24.9 13.6.0 24.6 11.1 24.6 24.9.0 13.6-11.1 24.6-24.6 24.6zM504 256c0 137-111 248-248 248S8 393 8 256 119 8 256 8s248 111 248 248zm-132.3-41.2c-9.4.0-17.7 3.9-23.8 10-22.4-15.5-52.6-25.5-86.1-26.6l17.4-78.3 55.4 12.5c0 13.6 11.1 24.6 24.6 24.6 13.8.0 24.9-11.3 24.9-24.9s-11.1-24.9-24.9-24.9c-9.7.0-18 5.8-22.1 13.8l-61.2-13.6c-3-.8-6.1 1.4-6.9 4.4l-19.1 86.4c-33.2 1.4-63.1 11.3-85.5 26.8-6.1-6.4-14.7-10.2-24.1-10.2-34.9.0-46.3 46.9-14.4 62.8-1.1 5-1.7 10.2-1.7 15.5.0 52.6 59.2 95.2 132 95.2 73.1.0 132.3-42.6 132.3-95.2.0-5.3-.6-10.8-1.9-15.8 31.3-16 19.8-62.5-14.9-62.5zM302.8 331c-18.2 18.2-76.1 17.9-93.6.0-2.2-2.2-6.1-2.2-8.3.0-2.5 2.5-2.5 6.4.0 8.6 22.8 22.8 87.3 22.8 110.2.0 2.5-2.2 2.5-6.1.0-8.6-2.2-2.2-6.1-2.2-8.3.0zm7.7-75c-13.6.0-24.6 11.1-24.6 24.9.0 13.6 11.1 24.6 24.6 24.6 13.8.0 24.9-11.1 24.9-24.6.0-13.8-11-24.9-24.9-24.9z"/></svg>
</span></a><a target=_blank class="m-1 rounded bg-neutral-300 p-1.5 text-neutral-700 hover:bg-primary-500 hover:text-neutral dark:bg-neutral-700 dark:text-neutral-300 dark:hover:bg-primary-400 dark:hover:text-neutral-800" href="https://www.facebook.com/sharer/sharer.php?u=https://pmnxis.github.io/ko/posts/chama-optics-dev-story/&amp;quote=Chama%20Optics%20%ea%b0%9c%eb%b0%9c%ea%b8%b0" title="Facebook에서 공유" aria-label="Facebook에서 공유"><span class="relative block icon"><svg viewBox="0 0 512 512"><path fill="currentColor" d="M504 256C504 119 393 8 256 8S8 119 8 256c0 123.78 90.69 226.38 209.25 245V327.69h-63V256h63v-54.64c0-62.15 37-96.48 93.67-96.48 27.14.0 55.52 4.84 55.52 4.84v61h-31.28c-30.8.0-40.41 19.12-40.41 38.73V256h68.78l-11 71.69h-57.78V501C413.31 482.38 504 379.78 504 256z"/></svg>
</span></a><a target=_blank class="m-1 rounded bg-neutral-300 p-1.5 text-neutral-700 hover:bg-primary-500 hover:text-neutral dark:bg-neutral-700 dark:text-neutral-300 dark:hover:bg-primary-400 dark:hover:text-neutral-800" href="mailto:?body=https://pmnxis.github.io/ko/posts/chama-optics-dev-story/&amp;subject=Chama%20Optics%20%ea%b0%9c%eb%b0%9c%ea%b8%b0" title="이메일로 전송" aria-label="이메일로 전송"><span class="relative block icon"><svg viewBox="0 0 512 512"><path fill="currentColor" d="M207.8 20.73c-93.45 18.32-168.7 93.66-187 187.1-27.64 140.9 68.65 266.2 199.1 285.1 19.01 2.888 36.17-12.26 36.17-31.49l1e-4-.6631c0-15.74-11.44-28.88-26.84-31.24-84.35-12.98-149.2-86.13-149.2-174.2.0-102.9 88.61-185.5 193.4-175.4 91.54 8.869 158.6 91.25 158.6 183.2v16.16c0 22.09-17.94 40.05-40 40.05s-40.01-17.96-40.01-40.05v-120.1c0-8.847-7.161-16.02-16.01-16.02l-31.98.0036c-7.299.0-13.2 4.992-15.12 11.68-24.85-12.15-54.24-16.38-86.06-5.106-38.75 13.73-68.12 48.91-73.72 89.64-9.483 69.01 43.81 128 110.9 128 26.44.0 50.43-9.544 69.59-24.88 24 31.3 65.23 48.69 109.4 37.49C465.2 369.3 496 324.1 495.1 277.2V256.3c0-149.2-133.9-265.632-287.3-235.57zM239.1 304.3c-26.47.0-48-21.56-48-48.05s21.53-48.05 48-48.05 48 21.56 48 48.05-20.6 48.05-48 48.05z"/></svg></span></a></section></div></section><footer class="pt-8 max-w-prose print:hidden"><div class=pt-8><hr class="border-dotted border-neutral-300 dark:border-neutral-600"><div class="flex justify-between pt-3"><span class="flex flex-col"><a class="flex text-neutral-700 hover:text-primary-600 dark:text-neutral dark:hover:text-primary-400" href=/ko/posts/my_first_commerical_rust_embedded_product_4/><span class=leading-6><span class="inline-block rtl:rotate-180">&larr;</span>&ensp;러스트 임베디드 양산 제품 개발기 - 4 빌드 스크립트 활용
</span></a><span class="ms-6 mt-1 text-xs text-neutral-500 dark:text-neutral-400"><time datetime=2023-11-13T21:00:00+09:00>2023년 11월 13일</time>
</span></span><span class="flex flex-col items-end"></span></div></div><div class=pt-3><hr class="border-dotted border-neutral-300 dark:border-neutral-600"><div class=pt-3><script src=https://utteranc.es/client.js repo=pmnxis/pmnxis.github.io issue-term=pathname label=Comment theme=dark-blue crossorigin=anonymous async></script></div></div></footer></article><div id=scroll-to-top class="fixed bottom-6 end-6 z-50 transform translate-y-4 opacity-0 duration-200"><a href=#the-top class="pointer-events-auto flex h-12 w-12 items-center justify-center rounded-full bg-neutral/50 text-xl text-neutral-700 hover:text-primary-600 dark:bg-neutral-800/50 dark:text-neutral dark:hover:text-primary-400" aria-label="맨 위로 스크롤" title="맨 위로 스크롤">&uarr;</a></div></main><footer id=site-footer class="py-10 print:hidden"><nav class="flex flex-row pb-4 text-base font-medium text-neutral-500 dark:text-neutral-400"><ul class="flex list-none flex-col sm:flex-row"><li class="flex mb-1 text-end sm:mb-0 sm:me-7 sm:last:me-0"><a class="decoration-primary-500 hover:underline hover:decoration-2 hover:underline-offset-2 flex items-center" href=/ko/categories/ title=Categories>Categories</a></li><li class="flex mb-1 text-end sm:mb-0 sm:me-7 sm:last:me-0"><a class="decoration-primary-500 hover:underline hover:decoration-2 hover:underline-offset-2 flex items-center" href=/ko/tags/ title=Tags>Tags</a></li></ul></nav><div class="flex items-center justify-between"><p class="text-sm text-neutral-500 dark:text-neutral-400">&copy;
2026</p><p class="text-xs text-neutral-500 dark:text-neutral-400"><a class="hover:underline hover:decoration-primary-400 hover:text-primary-500" href=https://gohugo.io/ target=_blank rel="noopener noreferrer">Hugo</a> & <a class="hover:underline hover:decoration-primary-400 hover:text-primary-500" href=https://blowfish.page/ target=_blank rel="noopener noreferrer">Blowfish</a> 로 제공됨</p></div><script>mediumZoom(document.querySelectorAll("img:not(.nozoom)"),{margin:24,background:"rgba(0,0,0,0.5)",scrollOffset:0})</script></footer><div id=search-wrapper class="invisible fixed inset-0 flex h-screen w-screen cursor-default flex-col bg-neutral-500/50 p-4 backdrop-blur-sm dark:bg-neutral-900/50 sm:p-6 md:p-[10vh] lg:p-[12vh] z-500" data-url=https://pmnxis.github.io/ko/><div id=search-modal class="flex flex-col w-full max-w-3xl min-h-0 mx-auto border rounded-md shadow-lg top-20 border-neutral-200 bg-neutral dark:border-neutral-700 dark:bg-neutral-800"><header class="relative z-10 flex items-center justify-between flex-none px-2"><form class="flex items-center flex-auto min-w-0"><div class="flex items-center justify-center w-8 h-8 text-neutral-400"><span class="relative block icon"><svg aria-hidden="true" focusable="false" data-prefix="fas" data-icon="search" class="svg-inline--fa fa-search fa-w-16" role="img" viewBox="0 0 512 512"><path fill="currentColor" d="M505 442.7 405.3 343c-4.5-4.5-10.6-7-17-7H372c27.6-35.3 44-79.7 44-128C416 93.1 322.9.0 208 0S0 93.1.0 208s93.1 208 208 208c48.3.0 92.7-16.4 128-44v16.3c0 6.4 2.5 12.5 7 17l99.7 99.7c9.4 9.4 24.6 9.4 33.9.0l28.3-28.3c9.4-9.4 9.4-24.6.1-34zM208 336c-70.7.0-128-57.2-128-128 0-70.7 57.2-128 128-128 70.7.0 128 57.2 128 128 0 70.7-57.2 128-128 128z"/></svg></span></div><input type=search id=search-query class="flex flex-auto h-12 mx-1 bg-transparent appearance-none focus:outline-dotted focus:outline-2 focus:outline-transparent" placeholder=검색 tabindex=0></form><button id=close-search-button class="flex items-center justify-center w-8 h-8 text-neutral-700 hover:text-primary-600 dark:text-neutral dark:hover:text-primary-400" title="닫기 (Esc)">
<span class="relative block icon"><svg viewBox="0 0 320 512"><path fill="currentColor" d="M310.6 361.4c12.5 12.5 12.5 32.75.0 45.25C304.4 412.9 296.2 416 288 416s-16.38-3.125-22.62-9.375L160 301.3 54.63 406.6C48.38 412.9 40.19 416 32 416S15.63 412.9 9.375 406.6c-12.5-12.5-12.5-32.75.0-45.25l105.4-105.4L9.375 150.6c-12.5-12.5-12.5-32.75.0-45.25s32.75-12.5 45.25.0L160 210.8l105.4-105.4c12.5-12.5 32.75-12.5 45.25.0s12.5 32.75.0 45.25l-105.4 105.4L310.6 361.4z"/></svg></span></button></header><section class="flex-auto px-2 overflow-auto"><ul id=search-results></ul></section></div></div></div></body></html>